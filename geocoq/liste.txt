Liste
cong_reflexivity
Proof.
    intros.
    apply (cong_inner_transitivity B A A B); apply cong_pseudo_reflexivity.
Qed.
cong_symmetry
Proof.
    intros.
    eapply cong_inner_transitivity.
      apply H.
    apply cong_reflexivity.
Qed.
cong_transitivity
Proof.
    intros.
    eapply cong_inner_transitivity; eauto using cong_symmetry.
Qed.
cong_left_commutativity
Proof.
    intros.
    eapply cong_inner_transitivity.
      apply cong_symmetry.
      apply cong_pseudo_reflexivity.
    assumption.
Qed.
cong_right_commutativity
Proof.
    intros.
    apply cong_symmetry.
    apply cong_symmetry in H.
    apply cong_left_commutativity.
    assumption.
Qed.
cong_3421
Proof.
    auto using cong_symmetry, cong_right_commutativity.
Qed.
cong_4312
Proof.
    auto using cong_symmetry, cong_right_commutativity.
Qed.
cong_4321
Proof.
    auto using cong_symmetry, cong_right_commutativity.
Qed.
cong_trivial_identity
Proof.
    intros.
    prolong A B E A A.
    eapply cong_inner_transitivity.
      apply H0.
    assert(B=E).
      eapply cong_identity.
      apply H0.
    subst.
    apply cong_reflexivity.
Qed.
cong_reverse_identity
Proof.
    intros.
    apply cong_symmetry in H.
    eapply cong_identity.
    apply H.
Qed.
cong_commutativity
Proof.
    intros.
    apply cong_left_commutativity.
    apply cong_right_commutativity.
    assumption.
Qed.
not_cong_2134
Proof.
auto with cong.
Qed.
not_cong_1243
Proof.
auto with cong.
Qed.
not_cong_2143
Proof.
auto with cong.
Qed.
not_cong_3412
Proof.
auto with cong.
Qed.
not_cong_4312
Proof.
auto with cong.
Qed.
not_cong_3421
Proof.
auto with cong.
Qed.
not_cong_4321
Proof.
auto with cong.
Qed.
five_segment_with_def
Proof.
    unfold OFSC.
    intros;spliter.
    apply (five_segment A A' B B'); assumption.
Qed.
cong_diff
Proof.
    intros.
    intro.
    subst.
    apply H.
    eauto using cong_identity.
Qed.
cong_diff_2
Proof.
    intros.
    intro;subst.
    apply H.
    symmetry.
    eauto using cong_identity, cong_symmetry.
Qed.
cong_diff_3
Proof.
    intros.
    intro;subst.
    apply H.
    eauto using cong_identity, cong_symmetry.
Qed.
cong_diff_4
Proof.
    intros.
    intro;subst.
    apply H.
    symmetry.
    eauto using cong_identity, cong_symmetry.
Qed.
cong_3_sym
Proof.
    unfold Cong_3.
    intuition.
Qed.
cong_3_swap
Proof.
    unfold Cong_3.
    intuition.
Qed.
cong_3_swap_2
Proof.
    unfold Cong_3.
    intuition.
Qed.
cong3_transitivity
Proof.
    unfold Cong_3.
    intros.
    spliter.
    repeat split; eapply cong_transitivity; eCong.
Qed.
eq_dec_points
Proof. exact point_equality_decidability. Qed.
l2_11
Proof.
    intros.
    induction (eq_dec_points A B).
      subst B.
      assert (A' = B') by
     (apply (cong_identity A' B' A); Cong).
      subst; Cong.
    apply cong_commutativity; apply (five_segment A A' B B' C C' A A'); Cong.
Qed.
bet_cong3
Proof.
    intros.
    assert (exists x, Bet A' B' x /\ Cong B' x B C) by (apply segment_construction).
    ex_and H1 x.
    assert (Cong A C A' x).
      eapply l2_11.
        apply H.
        apply H1.
        assumption.
      Cong.
    exists x;unfold Cong_3; repeat split;Cong.
Qed.
construction_uniqueness
Proof.
    intros.
    assert (Cong A X A Y) by (apply cong_transitivity with B C; Cong).
    assert (Cong Q X Q Y) by (apply (l2_11 Q A X Q A Y);Cong).
    assert(OFSC Q A X Y Q A X X) by (unfold OFSC;repeat split;Cong).
    apply five_segment_with_def in H6; try assumption.
    apply cong_identity with X. Cong.
Qed.
Cong_cases
Proof.
    intros.
    decompose [or] H;clear H; Cong.
Qed.
Cong_perm
Proof.
    intros.
    repeat split; Cong.
Qed.
bet_col
Proof.
    intros;unfold Col;auto.
Qed.
between_trivial
Proof.
    intros.
    prolong A B x B B.
    assert (x = B) by (apply cong_reverse_identity with B; Cong).
    subst;assumption.
Qed.
between_symmetry
Proof.
    intros.
    assert (Bet B C C) by (apply between_trivial).
    assert(exists x, Bet B x B /\ Bet C x A) by (apply inner_pasch with C;auto).
    ex_and H1 x.
    apply between_identity in H1; subst; assumption.
Qed.
Bet_cases
Proof.
    intros.
    decompose [or] H; auto using between_symmetry.
Qed.
Bet_perm
Proof.
    intros.
    auto using between_symmetry.
Qed.
between_trivial2
Proof.
    intros.
    apply between_symmetry.
    apply between_trivial.
Qed.
between_equality
Proof.
    intros.
    assert (exists x, Bet B x B /\ Bet A x A) by (apply (inner_pasch A B C);assumption).
    ex_and H1 x.
    apply between_identity in H1.
    apply between_identity in H2.
    congruence.
Qed.
between_equality_2
Proof.
    intros.
    apply between_equality with A; auto using between_symmetry.
Qed.
between_exchange3
Proof.
intros.
assert (exists x, Bet C x C /\ Bet B x D)
  by (apply inner_pasch with A; apply between_symmetry; auto).
ex_and H1 x.
assert (C = x) by (apply between_identity; auto); subst; auto.
Qed.
bet_neq12__neq
Proof.
    intros A B C HBet HAB Heq.
    subst C; apply HAB, between_identity; trivial.
Qed.
bet_neq21__neq
Proof.
    intros A B C HBet HAB.
    apply bet_neq12__neq with B; auto.
Qed.
bet_neq23__neq
Proof.
    intros A B C HBet HBC Heq.
    subst C; apply HBC; symmetry.
    apply between_identity; trivial.
Qed.
bet_neq32__neq
Proof.
    intros A B C HBet HAB.
    apply bet_neq23__neq with B; auto.
Qed.
not_bet_distincts
Proof.
    intros A B C HNBet.
    repeat split; intro; subst B; apply HNBet.
      apply between_trivial2.
      apply between_trivial.
Qed.
between_inner_transitivity
Proof.
    intros.
    assert (exists x, Bet B x B /\ Bet C x A) by (apply inner_pasch with D;auto).
    ex_and H1 x.
    Between.
Qed.
outer_transitivity_between2
Proof.
    intros.
    prolong A C x C D.
    assert (x = D) by (apply (construction_uniqueness B C C D); try apply (between_exchange3 A B C x); Cong).
    subst x;assumption.
Qed.
between_exchange2
Proof.
    intros.
    induction (eq_dec_points B C);eBetween.
Qed.
outer_transitivity_between
Proof.
    intros.
    eBetween.
Qed.
between_exchange4
Proof.
    intros.
    eBetween.
Qed.
l_3_9_4
Proof.
    unfold Bet_4.
    intros;spliter; auto with between.
Qed.
l3_17
Proof.
    intros.
    assert (exists Q', Bet B' Q' A /\ Bet P Q' C) by (eapply inner_pasch;eBetween).
    ex_and H2 x.
    assert (exists y, Bet x y C /\ Bet B y B') by (eapply inner_pasch;eBetween).
    ex_and H4 y.
    exists y. eBetween.
Qed.
lower_dim_ex
Proof.
exists PA.
exists PB.
exists PC.
apply lower_dim.
Qed.
two_distinct_points
Proof.
    assert (ld:=lower_dim_ex).
    ex_elim ld A.
    ex_elim H B.
    ex_elim H0 C.
    induction (eq_dec_points A B).
      subst A; exists B; exists C; auto with between between_no_eauto.
    exists A; exists B; assumption.
Qed.
point_construction_different
Proof.
    intros.
    assert (tdp := two_distinct_points).
    ex_elim tdp x.
    ex_elim H y.
    prolong A B F x y.
    exists F.
    show_distinct B F.
      intuition.
    intuition.
Qed.
another_point
Proof.
    intros.
    assert (pcd := point_construction_different A A).
    ex_and pcd B.
    exists B;assumption.
Qed.
l2_11_b
Proof.
    intros.
    apply Cong_stability; intro.
    assert (A<>B).
      intro; subst.
      assert (A'=B') by (apply (cong_identity A' B' B); Cong).
      subst; tauto.
    assert (Cong C A C' A') by (apply (five_segment _ _ _ _ _ _ _ _ H1 );auto using cong_trivial_identity, cong_commutativity).
    apply H3; Cong.
Qed.
cong_dec_eq_dec_b
Proof.
    intros A B HAB.
    apply cong_identity with A.
    apply Cong_stability.
    intro HNCong.
    apply HAB.
    intro HEq.
    subst.
    apply HNCong.
    apply cong_pseudo_reflexivity.
Qed.
bet_dec_eq_dec_b
Proof.
    intros A B HAB.
    apply between_identity.
    apply Bet_stability.
    intro HNBet.
    apply HAB.
    intro HEq.
    subst.
    apply HNBet.
    apply between_trivial.
Qed.
BetSEq
Proof.
intros; unfold BetS; split; intro; spliter;
repeat split; auto; intro; treat_equalities; auto.
Qed.
l4_2
Proof.
unfold IFSC.
intros.
spliter.

induction (eq_dec_points A C).

treat_equalities;assumption.

assert (exists E, Bet A C E /\ C <> E)
 by apply point_construction_different.
ex_and H6 E.
prolong A' C' E' C E.

assert  (Cong E D E' D')
 by (
  apply (five_segment_with_def A C E D A' C' E' D');[
  unfold OFSC;  repeat split;Cong|
  assumption]).

apply (five_segment_with_def E C B D E' C' B' D').
unfold OFSC.
repeat split; try solve [eBetween| Cong ].
auto.
Qed.
l4_3
Proof.
intros.
apply cong_commutativity.
apply (l4_2 A B C A A' B' C' A').
unfold IFSC.
repeat split;Cong.
Qed.
l4_3_1
Proof.
    intros.
    apply cong_commutativity.
    eapply l4_3. eBetween;Cong.
Qed.
l4_5
Proof.
intros.
unfold Cong_3.

assert (exists D', Bet C' A' D' /\ A' <> D')
 by (apply point_construction_different).
ex_and H1 x'.
prolong x' A' B' A B.
prolong x' B' C'' B C.

assert (Bet A' B' C'') by eBetween.

assert (C'' = C').
eapply (construction_uniqueness x' A' ).

auto.
eBetween.

apply (l2_11 A' B' C'' A B C);Between.

eBetween.
Cong.

subst C''.
exists B'.
repeat split;Cong.
Qed.
l4_6
Proof.
unfold Cong_3.
intros.
assert (exists B'', Bet A' B'' C' /\ Cong_3 A B C A' B'' C')
  by (eapply l4_5;intuition).
ex_and H1 x.
unfold Cong_3 in *;spliter.

assert (Cong_3 A' x C' A' B' C').
  unfold Cong_3;repeat split; Cong.
  apply cong_transitivity with A B; Cong.
  apply cong_transitivity with B C; Cong.
unfold Cong_3 in H7;spliter.

assert (IFSC A' x C' x  A' x C' B')
 by (unfold IFSC;repeat split;Cong).
assert (Cong x x x B')
 by (eapply l4_2;apply H10).
Between.
Qed.
cong3_bet_eq
Proof.
unfold Cong_3.
intros.
spliter.
assert (IFSC A B C B A B C X)
 by (unfold IFSC;intuition).
assert (Cong B B B X)
 by (apply (l4_2 _ _ _ _ _ _ _ _ H3)).
Between.
Qed.
col_permutation_1
Proof.
    unfold Col.
    intros.
    intuition.
Qed.
col_permutation_2
Proof.
    unfold Col.
    intros.
    intuition.
Qed.
col_permutation_3
Proof.
    unfold Col.
    intros.
    intuition.
Qed.
col_permutation_4
Proof.
    unfold Col.
    intros.
    intuition.
Qed.
col_permutation_5
Proof.
    unfold Col.
    intros.
    intuition.
Qed.
not_col_permutation_1
Proof.
    intros.
    intro.
    apply H.
    Col.
Qed.
not_col_permutation_2
Proof.
    intros.
    intro.
    apply H.
    Col.
Qed.
not_col_permutation_3
Proof.
    intros.
    intro.
    apply H.
    Col.
Qed.
not_col_permutation_4
Proof.
    intros.
    intro.
    apply H.
    Col.
Qed.
not_col_permutation_5
Proof.
    intros.
    intro.
    apply H.
    Col.
Qed.
Col_cases
Proof.
    intros.
    decompose [or] H; Col.
Qed.
Col_perm
Proof.
    intros.
    repeat split; Col.
Qed.
col_trivial_1
Proof.
    unfold Col.
    intros.
    Between.
Qed.
col_trivial_2
Proof.
    unfold Col.
    intros.
    Between.
Qed.
col_trivial_3
Proof.
    unfold Col.
    intros.
    right;Between.
Qed.
l4_13
Proof.
    unfold Col.
    intros.
    decompose [or] H;
      eauto 6  using l4_6 with cong3.
Qed.
l4_14
Proof.
    unfold Col.
    intros.
    intuition.
      prolong A' B' C' B C.
      exists C'.
      assert (Cong A C A' C') by (eapply l2_11;eCong).
      unfold Cong_3;intuition.
      assert (exists C', Bet A' C' B' /\ Cong_3 A C B A' C' B') by (eapply l4_5;Between).
      ex_and H1 C'.
      exists C'.
      auto with cong3.
    prolong B' A' C' A C.
    exists C'.
    assert (Cong B C B' C') by (eapply l2_11;eBetween;Cong).
    unfold Cong_3;intuition.
Qed.
l4_16
Proof.
    unfold FSC.
    unfold Col.
    intros.
    decompose [or and] H; clear H.
      assert (Bet A' B' C') by (eapply l4_6;eauto).
      unfold Cong_3 in *; spliter.
      assert(OFSC A B C D A' B' C' D') by (unfold OFSC;repeat split; assumption).
      eapply five_segment_with_def; eauto.
      assert(Bet B' C' A') by (apply (l4_6 B C A B' C' A'); Cong;auto with cong3).
      apply (l4_2 B C A D B' C' A' D').
      unfold IFSC; unfold Cong_3 in *; spliter; repeat split;Between;Cong.
    assert (Bet C' A' B') by (eapply (l4_6 C A B C' A' B'); auto with cong3).
    eapply (five_segment_with_def B A C D B' A'); unfold OFSC; unfold Cong_3 in *; spliter; repeat split; Between; Cong.
Qed.
l4_17
Proof.
    intros.
    assert (FSC A B C P A B C Q) by (unfold FSC; unfold Cong_3;repeat split; Cong).
    eapply l4_16; eauto.
Qed.
l4_18
Proof.
    intros.
    apply cong_identity with C.
    apply (l4_17 A B); Cong.
Qed.
l4_19
Proof.
    intros.
    induction (eq_dec_points A B).
      treat_equalities; reflexivity.
    apply (l4_18 A B); Cong.
    auto using bet_col with col.
Qed.
not_col_distincts
Proof.
    intros.
    repeat split;(auto;intro); subst; apply H; Col.
Qed.
NCol_cases
Proof.
    intros.
    decompose [or] H; Col.
Qed.
NCol_perm
Proof.
    intros.
    repeat split; Col.
Qed.
col_cong_3_cong_3_eq
Proof.
intros A B C A' B' C1 C2 HAB HCol HCong1 HCong2.
apply l4_18 with A' B'; try apply l4_13 with A B C; Col;
unfold Cong_3 in *; spliter.
  intro; treat_equalities; intuition.
  apply cong_transitivity with A C; Cong.
  apply cong_transitivity with B C; Cong.
Qed.
l5_1
Proof.
apply eq_dec_implies_l5_1; apply eq_dec_points.
Qed.
l5_2
Proof.
apply eq_dec_implies_l5_2; apply eq_dec_points.
Qed.
segment_construction_2
Proof.
apply eq_dec_implies_segment_construction_2; apply eq_dec_points.
Qed.
l5_3
Proof.
    intros.
    assert (exists P, Bet D A P /\ A<>P) by  (apply point_construction_different).
    ex_and H1 P.
    assert (Bet P A B) by eBetween.
    assert (Bet P A C) by eBetween.
    apply (l5_2 P);auto.
Qed.
le_bet
Proof.
    intros.
    unfold Le in H.
    ex_and H Y.
    exists Y;split;Cong.
Qed.
l5_5_1
Proof.
    unfold Le.
    intros.
    ex_and H P.
    prolong A B x P D.
    exists x.
    split.
      assumption.
    eapply l2_11;eauto.
Qed.
l5_5_2
Proof.
    intros.
    ex_and H P.
    unfold Le.
    assert (exists B' : Tpoint, Bet C B' D /\ Cong_3 A B P C B' D) by (eapply l4_5;auto).
    ex_and H1 y.
    exists y.
    unfold Cong_3 in *;intuition.
Qed.
l5_6
Proof.
    unfold Le.
    intros.
    spliter.
    ex_and H y.
    assert (exists z : Tpoint, Bet C' z D' /\ Cong_3 C y D C' z D') by (eapply l4_5;auto).
    ex_and H3 z.
    exists z.
    split.
      assumption.
    unfold Cong_3 in *; spliter.
    apply cong_transitivity with A B; try Cong.
    apply cong_transitivity with C y; assumption.
Qed.
le_reflexivity
Proof.
    unfold Le.
    intros.
    exists B.
    split; Between; Cong.
Qed.
le_transitivity
Proof.
    unfold Le.
    intros.
    ex_and H y.
    ex_and H0 z.
    assert (exists P : Tpoint, Bet E P z /\ Cong_3 C y D E P z) by (eapply l4_5;assumption).
    ex_and H3 P.
    exists P.
    split.
      eBetween.
    unfold Cong_3 in H4; spliter; apply cong_transitivity with C y; Cong.
Qed.
between_cong
Proof.
apply eq_dec_implies_between_cong; apply eq_dec_points.
Qed.
cong3_symmetry
Proof.
    unfold Cong_3.
    intros.
    intuition.
Qed.
between_cong_2
Proof.
    intros.
    apply cong3_bet_eq with A B; unfold Cong_3; repeat split; Cong.
    eapply (l4_2 B E A B B D A B).
    unfold IFSC; repeat split; Cong; Between.
Qed.
between_cong_3
Proof.
apply eq_dec_implies_between_cong_3; apply eq_dec_points.
Qed.
le_anti_symmetry
Proof.
    intros.
    assert (exists T, Bet C D T /\ Cong C T A B) by (apply l5_5_1;assumption).
    unfold Le in H.
    ex_and H Y.
    ex_and H1 T.
    assert (Cong C Y C T) by eCong.
    assert (Bet C Y T) by eBetween.
    assert (Y=T) by (eapply between_cong;eauto).
    subst Y.
    assert (T=D) by (eapply between_equality;eBetween).
    subst T.
    Cong.
Qed.
Cong_dec
Proof.
apply eq_dec_cong_dec; apply eq_dec_points.
Qed.
bet_dec
Proof.
apply eq_dec_bet_dec; apply eq_dec_points.
Qed.
Col_dec
Proof.
    intros.
    unfold Col.
    elim (bet_dec A B C); intro; elim (bet_dec B C A); intro; elim (bet_dec C A B); intro; tauto.
Qed.
le_trivial
Proof.
    intros.
    unfold Le.
    exists C.
    split; Between; Cong.
Qed.
le_cases
Proof.
    intros.
    induction(eq_dec_points A B).
      subst B; left; apply le_trivial.
    assert (exists X : Tpoint, (Bet A B X \/ Bet A X B) /\ Cong A X C D) by (eapply (segment_construction_2 B A C D);auto).
    ex_and H0 X.
    induction H0.
      left; apply l5_5_2; exists X; split; assumption.
    right; unfold Le; exists X; split; Cong.
Qed.
le_zero
Proof.
    intros.
    assert (Le C C A B) by apply le_trivial.
    assert (Cong A B C C) by (apply le_anti_symmetry;assumption).
    treat_equalities;auto.
Qed.
le_diff
Proof.
  intros A B C D HAB HLe Heq.
  subst D; apply HAB, le_zero with C; assumption.
Qed.
lt_diff
Proof.
  intros A B C D HLt Heq.
  subst D.
  destruct HLt as [HLe HNCong].
  assert (A = B) by (apply le_zero with C; assumption).
  subst B; Cong.
Qed.
bet_cong_eq
Proof.
    intros.
    assert(C = D).
      assert(Le A C A D) by (eapply l5_5_2; exists D; split; Cong).
      assert(Le C B C A) by (eapply l5_5_2; exists A; split; Between; Cong).
      assert(Cong A C A D) by (eapply le_anti_symmetry; try assumption; apply l5_6 with C B C A; Cong).
      apply between_cong with A; assumption.
    split; try assumption.
    subst D; apply sym_equal.
    eapply (between_cong C); Between; Cong.
Qed.
cong__le
Proof.
  intros A B C D H.
  exists D.
  split.
  Between.
  Cong.
Qed.
cong__le3412
Proof.
  intros A B C D HCong.
  apply cong__le.
  Cong.
Qed.
le1221
Proof.
  intros A B.
  apply cong__le; Cong.
Qed.
le_left_comm
Proof.
  intros A B C D Hle.
  apply (le_transitivity _ _ A B); auto.
  apply le1221; auto.
Qed.
le_right_comm
Proof.
  intros A B C D Hle.
  apply (le_transitivity _ _ C D); auto.
  apply le1221; auto.
Qed.
le_comm
Proof.
  intros.
  apply le_left_comm.
  apply le_right_comm.
  assumption.
Qed.
ge_left_comm
Proof.
    intros.
    unfold Ge in *.
    apply le_right_comm.
    assumption.
Qed.
ge_right_comm
Proof.
    intros.
    unfold Ge in *.
    apply le_left_comm.
    assumption.
Qed.
ge_comm
Proof.
    intros.
    apply ge_left_comm.
    apply ge_right_comm.
    assumption.
Qed.
lt_right_comm
Proof.
    intros.
    unfold Lt in *.
    spliter.
    split.
      apply le_right_comm.
      assumption.
    intro.
    apply H0.
    apply cong_right_commutativity.
    assumption.
Qed.
lt_left_comm
Proof.
    intros.
    unfold Lt in *.
    spliter.
    split.
      unfold Le in *.
      ex_and H P.
      exists P.
      apply cong_left_commutativity in H1.
      split; assumption.
    intro.
    apply H0.
    apply cong_left_commutativity.
    assumption.
Qed.
lt_comm
Proof.
    intros.
    apply lt_left_comm.
    apply lt_right_comm.
    assumption.
Qed.
gt_left_comm
Proof.
    intros.
    unfold Gt in *.
    apply lt_right_comm.
    assumption.
Qed.
gt_right_comm
Proof.
    intros.
    unfold Gt in *.
    apply lt_left_comm.
    assumption.
Qed.
gt_comm
Proof.
    intros.
    apply gt_left_comm.
    apply gt_right_comm.
    assumption.
Qed.
cong2_lt__lt
Proof.
  intros A B C D A' B' C' D' Hlt HCong1 HCong2.
  destruct Hlt as [Hle HNCong].
  split.
  apply (l5_6 A B C D); auto.
  intro.
  apply HNCong.
  apply (cong_transitivity _ _ A' B'); auto.
  apply (cong_transitivity _ _ C' D'); Cong.
Qed.
fourth_point
Proof.
    intros.
    induction H1.
      assert(HH:= l5_2 A B C P H H2 H1).
      right; right.
      induction HH.
        right; auto.
      left; auto.
    induction H1.
      right; left.
      Between.
    left; auto.
Qed.
third_point
Proof.
    intros.
    induction H.
      right; right.
      auto.
    induction H.
      right; left.
      Between.
    left.
    auto.
Qed.
l5_12_a
Proof.
    intros.
    split.
      unfold Le.
      exists B; split.
        assumption.
      apply cong_reflexivity.
    apply le_comm.
    unfold Le.
    exists B.
    split.
      apply between_symmetry.
      assumption.
    apply cong_reflexivity.
Qed.
bet__le1213
Proof.
    intros A B C HBet.
    destruct (l5_12_a A B C HBet); trivial.
Qed.
bet__le2313
Proof.
    intros A B C HBet.
    destruct (l5_12_a A B C HBet); trivial.
Qed.
bet__lt1213
Proof.
    intros A B C HBC HBet.
    split.
      apply bet__le1213; trivial.
    intro.
    apply HBC, between_cong with A; trivial.
Qed.
bet__lt2313
Proof.
    intros; apply lt_comm, bet__lt1213; Between.
Qed.
l5_12_b
Proof.
    intros.
    unfold Col in H.
    induction H.
      assumption.
    induction H.
      assert(Le B C B A /\ Le C A B A).
        apply l5_12_a.
          assumption.
      spliter.
      assert(Cong A B A C).
        apply le_anti_symmetry.
          assumption.
        apply le_comm.
        assumption.
      assert(C = B).
        eapply between_cong.
          apply between_symmetry.
          apply H.
        apply cong_symmetry.
        assumption.
      subst B.
      apply between_trivial.
    assert(Le B A B C /\ Le A C B C).
      apply l5_12_a.
        apply between_symmetry.
        assumption.
    spliter.
    assert(Cong B C A C).
      apply le_anti_symmetry.
        assumption.
      assumption.
    assert(A = B).
      eapply between_cong.
        apply H.
      apply cong_symmetry.
      apply cong_commutativity.
      assumption.
    subst A.
    apply between_symmetry.
    apply between_trivial.
Qed.
bet_le_eq
Proof.
    intros.
    assert(Le C B C A).
      eapply l5_5_2.
      exists A.
      split.
        apply between_symmetry.
        assumption.
      apply cong_reflexivity.
    assert(Cong A C B C).
      apply le_anti_symmetry.
        assumption.
      apply le_comm.
      assumption.
    apply sym_equal.
    eapply between_cong.
      apply between_symmetry.
      apply H.
    apply cong_commutativity.
    apply cong_symmetry.
    assumption.
Qed.
or_lt_cong_gt
Proof.
    intros.
    assert(HH:= le_cases A B C D).
    induction HH.
      induction(Cong_dec A B C D).
        right; right.
        assumption.
      left.
      unfold Lt.
      split; assumption.
    induction(Cong_dec A B C D).
      right; right.
      assumption.
    right; left.
    unfold Gt.
    unfold Lt.
    split.
      assumption.
    intro.
    apply H0.
    apply cong_symmetry.
    assumption.
Qed.
lt__le
Proof.
    intros A B C D Hlt.
    destruct Hlt.
    assumption.
Qed.
le1234_lt__lt
Proof.
    intros A B C D E F Hle Hlt.
    destruct Hlt as [Hle' HNCong].
    split.
      apply (le_transitivity _ _ C D); auto.
    intro.
    apply HNCong.
    apply le_anti_symmetry; auto.
    apply (l5_6 A B C D); Cong.
Qed.
le3456_lt__lt
Proof.
    intros A B C D E F Hlt Hle.
    destruct Hlt as [Hle' HNCong].
    split.
      apply (le_transitivity _ _ C D); auto.
    intro.
    apply HNCong.
    apply le_anti_symmetry; auto.
    apply (l5_6 C D E F); Cong.
Qed.
lt_transitivity
Proof.
    intros A B C D E F HLt1 HLt2.
    apply le1234_lt__lt with C D; try (apply lt__le); assumption.
Qed.
not_and_lt
Proof.
    intros A B C D.
    intro HInter.
    destruct HInter as [[Hle HNCong] []].
    apply HNCong.
    apply le_anti_symmetry; assumption.
Qed.
nlt
Proof.
    intros A B Hlt.
    apply (not_and_lt A B A B).
    split; assumption.
Qed.
le__nlt
Proof.
    intros A B C D HLe HLt.
    apply (not_and_lt A B C D); split; auto.
    split; auto.
    unfold Lt in *; spliter; auto with cong.
Qed.
cong__nlt
Proof.
    intros P Q R S H.
    apply le__nlt.
    unfold Le.
    exists Q; split; Cong; Between.
Qed.
nlt__le
Proof.
    intros A B C D HNLt.
    destruct (le_cases A B C D); trivial.
    destruct (Cong_dec C D A B).
      apply cong__le; assumption.
    exfalso.
    apply HNLt.
    split; Cong.
Qed.
lt__nle
Proof.
  intros A B C D HLt HLe.
  generalize HLt.
  apply le__nlt; assumption.
Qed.
nle__lt
Proof.
    intros A B C D HNLe.
    destruct (le_cases A B C D).
      contradiction.
    split; trivial.
    intro.
    apply HNLe.
    apply cong__le; Cong.
Qed.
lt1123
Proof.
intros.
split.
apply le_trivial.
intro.
treat_equalities.
intuition.
Qed.
bet2_le2__le
Proof.
intros.
induction(eq_dec_points A O).
treat_equalities; auto.
assert (o=a). 
apply le_zero with A;auto.
subst;auto.
induction(eq_dec_points B O).
treat_equalities;auto.
assert (o=b). 
apply le_zero with B;auto.
subst;auto using le_left_comm, le_right_comm.


assert(HH:= segment_construction A O b o).
ex_and HH b'.
assert(HH:= segment_construction B O a o).
ex_and HH a'.

unfold Le in H1.
ex_and H1 a''.

assert(a' = a'').
{
  apply(construction_uniqueness B O a o a' a'' H4);
  eBetween.
  Cong.
}
treat_equalities.

assert(Le B a' B A).
{
  unfold Le.
  exists a'.
  split; eBetween; Cong.
}

unfold Le in H2.
ex_and H2 b''.

assert(b' = b'').
{
  apply(construction_uniqueness A O b o b' b'' H3);
  eBetween.
  Cong.
}

treat_equalities.

assert(Le a' b' a' B).
{
  unfold Le.
  exists b'.
  split; eBetween; Cong.
}

assert(Le a' b' A B).
{
  apply(le_transitivity a' b' a' B A B); auto using le_left_comm, le_right_comm.
}

apply(l5_6 a' b' A B a b A B); Cong.
apply (l2_11 a' O b' a o b);
eBetween; Cong.
Qed.
bet_out
Proof.
    intros.
    unfold Out.
    repeat split; auto.
    intro; treat_equalities; auto.
Qed.
out_dec
Proof.
    intros.
    unfold Out.
    elim (bet_dec P A B);intro; elim (bet_dec P B A);intro; elim (eq_dec_points A P);intro; elim (eq_dec_points B P);intro; tauto.
Qed.
out_diff1
Proof.
    intros.
    unfold Out in H.
    spliter.
    assumption.
Qed.
out_diff2
Proof.
    intros.
    unfold Out in H.
    spliter.
    assumption.
Qed.
out_distinct
Proof.
    intros.
    split.
      eapply out_diff1;eauto.
    eapply out_diff2;eauto.
Qed.
out_col
Proof.
    intros.
    unfold Col.
    unfold Out in H.
    spliter.
    induction H1;Between.
Qed.
l6_2
Proof.
    intros.
    unfold Out.
    split.
      intros.
      repeat split; try assumption; eapply l5_2;eBetween.
    intro; spliter; induction H5; eBetween.
Qed.
bet_out__bet
Proof.
    intros A B C P HBet HOut.
    destruct (eq_dec_points C P).
      subst; Between.
    apply (l6_2 A); trivial; destruct HOut as [HPA [HPB]]; auto.
Qed.
l6_3_1
Proof.
    unfold Out.
    intros.
    spliter.
    repeat split; try assumption.
    induction H1.
      assert(exists C, Bet A P C /\ P <> C) by (apply point_construction_different).
      ex_and H2 C.
      exists C.
      repeat split; eBetween.
    assert(exists C, Bet B P C /\ P <> C) by (apply point_construction_different).
    ex_and H2 C.
    exists C.
    repeat split;eBetween.
Qed.
l6_3_2
Proof.
    intros.
    spliter.
    ex_and H1 C.
    unfold Out.
    repeat split; try assumption; eapply l5_2; eBetween.
Qed.
l6_4_1
Proof.
    unfold Out.
    intros.
    spliter.
    unfold Col.
    induction H1; split.
      Between.
      intro; apply H; eapply between_equality;eauto.
      right; left; assumption.
    intro; apply H0; eapply between_equality; eBetween.
Qed.
l6_4_2
Proof.
    unfold Col.
    intros.
    spliter.
    unfold Out.
    induction H.
      contradiction.
    induction (eq_dec_points A P).
      subst P; intuition.
    induction (eq_dec_points B P).
      subst P; intuition.
    induction H; repeat split; Between.
Qed.
out_trivial
Proof.
    intros.
    unfold Out.
    repeat split; Between.
Qed.
l6_6
Proof.
    unfold Out.
    intuition.
Qed.
l6_7
Proof.
    unfold Out.
    intros.
    spliter.
    repeat split; try assumption.
    induction H4; induction H2.
      left; eapply between_exchange4; eauto.
      eapply l5_3; eauto.
      eapply (l5_1 P B); auto.
    right; eBetween.
Qed.
bet_out_out_bet
Proof.
    intros.
    unfold Out in *.
    spliter.
    induction H5; induction H3.
      assert(Bet A' B C) by (apply outer_transitivity_between2 with A; Between).
      apply outer_transitivity_between with C; auto.
      assert(Bet A' B C) by (apply outer_transitivity_between2 with A; Between).
      apply between_inner_transitivity with C; assumption.
      assert(Bet A' B C) by (apply between_exchange3 with A; Between).
      apply outer_transitivity_between with C; auto.
    assert(Bet A' B C) by (apply between_exchange3 with A; Between).
    eapply between_inner_transitivity with C; assumption.
Qed.
out2_bet_out
Proof.
    intros.
    unfold Out in *.
    spliter.
    induction H5; induction H3.
      repeat split; try assumption.
        left; eapply between_exchange4 with X; try assumption.
        apply between_inner_transitivity with C; assumption.
      apply l5_1 with X; try auto.
      apply between_exchange2 with A; assumption.
      repeat split; try assumption.
        apply l5_3 with X; try assumption.
        apply between_inner_transitivity with C; assumption.
      right; apply between_exchange4 with X; try assumption.
      apply between_exchange2 with A; assumption.
      repeat split; try assumption.
        apply l5_1 with X; try auto.
        apply between_exchange2 with C; Between.
      left; apply between_exchange4 with X; try assumption.
      apply between_inner_transitivity with A; Between.
    repeat split; try assumption.
      right; apply between_exchange4 with X; try assumption.
      apply between_exchange2 with C; Between.
    apply l5_3 with X; try assumption.
    apply between_inner_transitivity with A; Between.
Qed.
l6_11_uniqueness
Proof.
    unfold Out.
    intros.
    spliter.
    assert (Cong A X A Y) by eCong.
    induction H8; induction H6.
      apply l4_19 with A R; try assumption.
      apply l4_3 with A A; Between; Cong.
      assert (Bet A X Y) by eBetween.
      eapply between_cong; eauto.
      assert (Bet A Y X) by eBetween.
      apply sym_equal; apply between_cong with A; Cong.
    assert (Bet A X Y \/ Bet A Y X) by (eapply l5_1; eauto).
    induction H10.
      apply between_cong with A; assumption.
    apply sym_equal; apply between_cong with A; Cong.
Qed.
l6_11_existence
Proof.
    intros.
    assert (exists X : Tpoint, (Bet A R X \/ Bet A X R) /\ Cong A X B C) by (apply (segment_construction_2);assumption).
    ex_and H1 X.
    exists X.
    unfold Out;repeat split; try intro;treat_equalities;intuition.
Qed.
segment_construction_3
Proof.
    intros.
    destruct (l6_11_existence A X Y B) as [C [HC1 HC2]]; auto.
    apply l6_6 in HC1.
    exists C; auto.
Qed.
l6_13_1
Proof.
    unfold Out.
    intros.
    spliter.
    induction H2; try assumption.
    unfold Le
 in H0.
    ex_and H0 Y.
    assert(Y = A).
      apply (l6_11_uniqueness P P A B); Between; Cong.
        unfold Out; repeat split; auto.
        intro; treat_equalities; auto.
      unfold Out; repeat split; auto.
    subst Y; assumption.
Qed.
l6_13_2
Proof.
    intros.
    unfold Le.
    exists A.
    split; Cong.
Qed.
l6_16_1
Proof.
    intros.
    assert((Bet P S X \/ Bet P X S) -> (Bet P S X \/ Bet S X P)) by (intro; induction H3; Between).
    unfold Col.
    induction H1;induction H2.
      right; apply H3; eapply (l5_2 Q P); Between.
      induction H2; left; eBetween.
      induction H1; left; eBetween.
    induction H1; induction H2.
      right; apply H3; eapply l5_1; eauto.
      right; right; eBetween.
      right; left; eBetween.
    right; apply H3; eapply l5_3; eBetween.
Qed.
col_transitivity_1
Proof.
    intros.
    induction (eq_dec_points A P).
      subst; unfold Col; Between.
    assert (T:=l6_16_1 P Q A B).
    apply col_permutation_1; apply T; Col.
Qed.
col_transitivity_2
Proof.
    intros.
    apply (col_transitivity_1 Q P A B);Col.
Qed.
l6_21
Proof.
    intros.
    elim (eq_dec_points P Q); intro; try assumption.
    cut False.
      intro; intuition.
    apply not_col_distincts in H.
    spliter.
    assert (Col C P Q) by (apply col_transitivity_1 with D; Col).
    assert (Col Q B C).
      induction (eq_dec_points Q A).
        subst; apply col_transitivity_1 with P; Col.
      apply col_transitivity_1 with P; try Col; apply col_permutation_1; apply col_transitivity_1 with A; Col.
    assert (Col A B C).
      induction (eq_dec_points Q A).
        subst Q; assumption.
      induction (eq_dec_points Q B).
        subst; apply col_permutation_2; apply col_transitivity_1 with P; try Col.
      apply col_permutation_2; apply col_transitivity_1 with Q; try Col.
    contradiction.
Qed.
not_col_exists
Proof.
    intros.
    assert (T:=lower_dim_ex).
    induction T.
    induction H0.
    induction H0.
    induction (Col_dec A B x).
      induction(Col_dec A B x0).
        induction(Col_dec A B x1).
          induction (eq_dec_points A x).
            assert (~(Col x x0 x1)) by (unfold Col; auto).
            treat_equalities; eCol.
          assert (Col A x x0)  by eCol.
          assert (Col A x x1)  by eCol.
          assert (Col A x0 x1) by eCol.
          assert (Col x x0 x1) by eCol.
          contradiction.
        exists x1; assumption.
      exists x0; assumption.
    exists x; assumption.
Qed.
t2_8
Proof.
    intros.
    induction (eq_dec_points A B); try (treat_equalities; Cong).
    assert (Cong A B D B -> Cong B C B E -> Cong A D D A -> Cong B D B A -> Bet A B C -> Bet D B E -> A <> B -> Cong C D E A).
      apply five_segment.
    apply cong_symmetry.
    apply cong_right_commutativity.
    apply H4; Cong; Between.
Qed.
col3
Proof.
    intros.
    assert (Col X A B) by (apply col_transitivity_1 with Y; assumption).
    induction(eq_dec_points C X).
      subst X; apply col_permutation_1; assumption.
    apply col_permutation_1.
    apply col_transitivity_1 with X; try assumption.
      apply col_permutation_2.
      apply col_transitivity_1 with Y; assumption.
    apply col_permutation_2.
    apply col_transitivity_1 with Y; assumption.
Qed.
out2__bet
Proof.
    intros A B C Hout1 Hout2.
    apply l6_4_1 in Hout2.
    destruct Hout2 as [_ Hout2].
    destruct Hout1 as [_ [_ [|]]].
    assumption.
    exfalso.
    apply Hout2.
    assumption.
Qed.
bet2_le2__le1346
Proof.
  intros A B C A' B' C' HBet HBet' HleAB HleBC.

  elim(eq_dec_points A B).
  { intro.
    subst B.
    apply (le_transitivity _ _ B' C'); auto.
    apply le_comm.
    exists B'.
    split; Between; Cong.
  }
  intro.
  elim(eq_dec_points B C).
  { intro.
    subst C.
    apply (le_transitivity _ _ A' B'); auto.
    exists B'; Cong.
  }
  intro.

  assert(A' <> B') by (intro; subst B'; assert(A = B); auto; apply (le_zero _ _ A'); auto).
  assert(B' <> C') by (intro; subst C'; assert(B = C); auto; apply (le_zero _ _ B'); auto).
  destruct HleAB as [B0 []].
  assert(A' <> B0) by (intro; subst B0; assert(A = B); auto; apply (cong_reverse_identity A'); Cong).
  assert(HC0 := segment_construction A' B0 B C).
  destruct HC0 as [C0 []].
  assert(B0 <> C0) by (intro; subst C0; assert(B = C); auto; apply (cong_reverse_identity B0); auto).
  exists C0.
  split.
  2: apply (l2_11 _ B _ _ B0); Cong.
  apply (outer_transitivity_between2 _ B0); auto.
  assert(Bet B0 B' C') by (apply between_symmetry; apply (between_inner_transitivity _ _ _ A'); Between).
  apply l6_13_1.
  - elim(eq_dec_points B0 B').
    { intro.
      subst.
      apply (l6_2 _ _ A'); Between.
    }
    intro.
    apply (l6_7 _ _ B').
    apply (l6_2 _ _ A'); Between.
    apply bet_out; auto.
  - apply (le_transitivity _ _ B' C').
      apply (l5_6 B C B' C'); Cong.
      apply le_comm.
      exists B'.
      split; Between; Cong.
Qed.
bet2_le2__le2356
Proof.
  intros A B C A' B' C' HBet HBet' HLe1 HLe2.
  elim(eq_dec_points A B).
  { intro; treat_equalities.
    apply (le_transitivity _ _ A' C'); auto.
    destruct (l5_12_a A' B' C'); auto.
  }
  intro.
  assert (A<>C) by (intro; treat_equalities; auto).
  destruct (l5_5_1 A B A' B' HLe1) as [B0 [HBet1 HCong1]].
  assert (A<>B0) by (intro; treat_equalities; auto).
  destruct HLe2 as [C0 [HBet2 HCong2]].
    assert (A<>C0) by (intro; treat_equalities; auto).
  assert (Bet A B0 C0).
  { apply l6_13_1.
      apply (l6_7 _ _ B); [|apply (l6_7 _ _ C)]; [apply l6_6| |apply l6_6]; apply bet_out; auto.
    apply (l5_6 A' B' A' C'); Cong.
    destruct (l5_12_a A' B' C'); auto.
  }
  apply (l5_6 B0 C0 B C); Cong; [apply (le_transitivity _ _ B C0)|].
    destruct (l5_12_a B B0 C0); eBetween.
    destruct (l5_12_a B C0 C); eBetween.
    apply cong_commutativity; apply (l4_3 _ _ A _ _ A'); Between; Cong.
Qed.
bet2_le2__le1245
Proof.
  intros A B C A' B' C'; intros.
  apply le_comm.
  apply (bet2_le2__le2356 C _ _ C'); Le; Between.
Qed.
cong_preserves_bet
Proof.
    intros.
    unfold Out in H2.
    spliter.
    induction H4.
      assumption.
    assert (Le
 E D0 E D').
      eapply l5_5_2.
      exists D'.
      split.
        assumption.
      Cong.
    assert(Le
 E D' E D0).
      eapply l5_6.
      repeat split.
        2:apply H0.
        2:apply H1.
      eapply l5_5_2.
      exists A0.
      split.
        assumption.
      Cong.
    assert(Cong E D' E D0).
      apply le_anti_symmetry.
        assumption.
      assumption.
    assert(D0 = D').
      eapply between_cong.
        apply H4.
      Cong.
    subst D'.
    Between.
Qed.
out_cong_cong
Proof.
    intros.
    unfold Out in H.
    spliter.
    induction H4.
      assert (Bet E D D0).
        eapply cong_preserves_bet.
          2:apply H1.
          2:apply H2.
          assumption.
        assumption.
      apply cong_commutativity.
      eapply l4_3.
        apply between_symmetry.
        apply H4.
        apply between_symmetry.
        apply H5.
        Cong.
      Cong.
    assert (Bet E D0 D).
      eapply cong_preserves_bet.
        2:apply H2.
        2:apply H1.
        assumption.
      apply l6_6.
      assumption.
    eapply l4_3;eBetween;Cong.
Qed.
not_out_bet
Proof.
    intros.
    unfold Out in H0.
    induction (eq_dec_points A B).
      subst.
      Between.
    induction (eq_dec_points B C).
      subst.
      Between.
    unfold Col in *.
    decompose [or] H;clear H.
      assumption.
      exfalso.
      apply H0.
      intuition.
    exfalso.
    apply H0.
    intuition.
Qed.
or_bet_out
Proof.
    intros.
    destruct (Col_dec A B C); auto.
    destruct (out_dec B A C); auto.
    left; apply not_out_bet; trivial.
Qed.
not_bet_out
Proof.
    intros.
    destruct (or_bet_out A B C) as [HBet|[HOut|HNCol]]; trivial; contradiction.
Qed.
not_bet_and_out
Proof.
    intros.
    intro.
    spliter.
    unfold Out in H0.
    spliter.
    induction H2.
      assert ( A = B).
        eapply between_equality.
          apply H.
        assumption.
      contradiction.
    assert(C = B).
      eapply between_equality.
        apply between_symmetry.
        apply H.
      assumption.
    contradiction.
Qed.
out_to_bet
Proof.
    intros.
    induction(out_dec B A C).
      unfold Out in H2.
      spliter.
      induction H4.
        assert( A = B).
          eapply between_equality.
            apply H1.
          assumption.
        contradiction.
      assert(C = B).
        apply(between_symmetry) in H4.
        eapply between_equality.
          apply between_symmetry.
          apply H1.
        apply between_symmetry.
        assumption.
      contradiction.
    destruct H0.
    assert (~Out B' A' C').
      intro.
      apply H2.
      apply H3.
      assumption.
    apply not_out_bet.
      assumption.
    assumption.
Qed.
col_out2_col
Proof.
    intros.
    induction H.
      assert (Bet AA B CC).
        eapply bet_out_out_bet.
          apply H.
          assumption.
        assumption.
      unfold Col.
      left.
      assumption.
    induction H.
      assert(Out B AA CC).
        eapply l6_7.
          eapply l6_6.
          apply H0.
        apply l6_6.
        eapply l6_7.
          apply l6_6.
          apply H1.
        apply bet_out.
          unfold Out in *.
          spliter.
          assumption.
          unfold Out in *.
          spliter.
          assumption.
      apply col_permutation_4.
      apply out_col.
      assumption.
    assert(Out B AA CC).
      eapply l6_6.
      eapply l6_7.
        eapply l6_6.
        apply H1.
      eapply l6_6.
      eapply l6_7.
        eapply l6_6.
        apply H0.
      apply bet_out.
        unfold Out in *.
        spliter.
        assumption.
        unfold Out in *.
        spliter.
      apply between_symmetry.
      assumption.
    apply col_permutation_4.
    apply out_col.
    assumption.
Qed.
bet2_out_out
Proof.
    intros.
    induction(eq_dec_points B' C').
      subst C'.
      unfold Out in *.
      spliter.
      repeat split; try assumption.
      induction H5.
        left.
        eapply between_exchange4.
          apply H2.
        assumption.
      eapply l5_3.
        apply H2.
      assumption.
    unfold Out in *.
    spliter.
    repeat split.
      assumption.
      assumption.
    induction H6.
      assert(Bet A B C').
        eapply between_exchange4.
          apply H2.
        assumption.
      eapply l5_3.
        apply H7.
      assumption.
    assert(Bet B' C' C).
      eapply between_exchange3.
        apply H3.
      assumption.
    assert(Bet A B' C).
      eapply outer_transitivity_between.
        apply H3.
        assumption.
      assumption.
    eapply l5_3.
      apply H2.
    assumption.
Qed.
out2_out_1
Proof.
    intros.
    unfold Out in *.
    spliter.
    repeat split.
      assumption.
      assumption.
    induction H2; induction H4.
      eapply l5_1.
        2: apply H4.
        auto.
      assumption.
      left.
      eapply between_exchange4.
        apply H4.
      assumption.
      right.
      eapply between_exchange4.
        apply H2.
      assumption.
    eapply l5_3.
      apply H4.
    apply H2.
Qed.
out2_out_2
Proof.
    intros.
    eapply out2_out_1.
      apply l6_6.
      apply H.
    apply l6_6.
    assumption.
Qed.
out_bet_out_1
Proof.
    intros.
    induction (eq_dec_points B P).
      subst P.
      apply False_ind.
      apply (not_bet_and_out A B C).
      split; assumption.
    unfold Out in *.
    spliter.
    repeat split.
      assumption.
      assumption.
    induction H3.
      left.
      eapply between_inner_transitivity.
        apply H3.
      assumption.
    right.
    eapply between_exchange2.
      apply H3.
    apply between_symmetry.
    assumption.
Qed.
out_bet_out_2
Proof.
    intros.
    apply l6_6.
    eapply out_bet_out_1.
      apply l6_6.
      apply H.
    apply between_symmetry.
    assumption.
Qed.
out_bet__out
Proof.
    intros A B P Q HBet Hout.
    destruct Hout as [HAQ [HBQ [HQAB|HQBA]]]; [|apply l6_6];
      apply bet_out; eBetween; intro; treat_equalities; auto.
    apply HBQ; apply (between_equality _ _ A); Between.
Qed.
is_midpoint_dec
Proof.
    intros.
    unfold Midpoint.
    elim (bet_dec A I B);intro; elim (Cong_dec A I I B);intro; tauto.
Qed.
is_midpoint_id
Proof.
    intros.
    unfold Midpoint in H.
    spliter.
    treat_equalities;reflexivity.
Qed.
is_midpoint_id_2
Proof.
    intros.
    unfold Midpoint in *.
    spliter.
    apply cong_identity in H0.
    auto.
Qed.
l7_2
Proof.
    unfold Midpoint.
    intuition.
Qed.
l7_3
Proof.
    unfold Midpoint.
    intros;spliter;repeat split;Between;Cong.
Qed.
l7_3_2
Proof.
    unfold Midpoint.
    intros;repeat split;Between;Cong.
Qed.
symmetric_point_construction
Proof.
    unfold Midpoint.
    intros.
    prolong P A E P A.
    exists E.
    split;Cong;Between.
Qed.
symmetric_point_uniqueness
Proof.
    unfold Midpoint.
    intros.
    spliter.
    elim (eq_dec_points A P); intros.
      treat_equalities;auto.
    apply (construction_uniqueness A P A P);Cong.
Qed.
l7_9
Proof.
    unfold Midpoint.
    intros.
    spliter.
    induction (eq_dec_points A X).
      treat_equalities;reflexivity.
    apply (construction_uniqueness X A X A);Cong;Between.
Qed.
l7_9_bis
Proof.
intros; apply l7_9 with A X; unfold Midpoint in *; split; spliter; Cong; Between.
Qed.
l7_13
Proof.
    unfold Midpoint.
    intros.
    spliter.
    induction (eq_dec_points P A).
      treat_equalities;Cong.
    prolong P' P X Q A.
    prolong X P' X' Q A.
    prolong Q' Q Y P A.
    prolong Y Q' Y' P A.
    assert (Bet Y A Q') by eBetween.
    assert (Bet P' A X) by eBetween.
    assert (Bet A P X) by eBetween.
    assert(Bet Y Q A) by eBetween.
    assert (Bet A Q' Y') by eBetween.
    assert (Bet X' P' A) by eBetween.
    assert(Bet X A X') by eBetween.
    assert(Bet Y A Y') by eBetween.
    assert (Cong A X Y A) by (eapply l2_11;eCong).
    assert (Cong A Y' X' A).
      apply l2_11 with Q' P'; Between.
        apply cong_transitivity with A Q; Cong.
      apply cong_transitivity with A P; Cong.
    assert (Cong A Y A Y').
      apply (l2_11 A Q Y _ Q' Y'); Between; Cong.
      apply cong_transitivity with A P; Cong.
    assert (Cong X A Y' A) by (apply cong_transitivity with A Y; Cong).
    assert (Cong A X' A Y) by (apply cong_transitivity with A Y'; Cong).
    assert (FSC X A X' Y' Y' A Y X).
      unfold FSC;repeat split; Cong.
        apply bet_col;auto.
      eapply (l2_11 X A X' Y' A Y);Between.
    assert (A <> X).
      eapply bet_neq12__neq.
        apply H14.
      auto.
    assert (Cong X' Y' Y X) by eauto using l4_16.
    assert (Cong A X A X') by (apply cong_transitivity with A Y; Cong).
    assert (IFSC Y Q A X Y' Q' A X') by (unfold IFSC, FSC in *;spliter;repeat split;Between; Cong).
    assert (Cong Q X Q' X') by eauto using l4_2.
    assert (IFSC X P A Q X' P' A Q') by (unfold IFSC;repeat split;Between;Cong).
    eauto using l4_2.
Qed.
l7_15
Proof.
    intros.
    spliter.
    eapply l4_6.
      apply H2.
    unfold Cong_3.
    repeat split.
      eapply l7_13.
        apply l7_2.
        apply H.
      apply l7_2.
      assumption.
      eapply l7_13.
        apply l7_2.
        apply H.
      apply l7_2.
      assumption.
    eapply l7_13.
      apply l7_2.
      apply H0.
    apply l7_2.
    assumption.
Qed.
l7_16
Proof.
    intros.
    assert (Cong P Q P' Q').
      eapply l7_13.
        apply l7_2.
        apply H.
      apply l7_2.
      apply H0.
    assert (Cong R S R' S').
      eapply l7_13.
        apply l7_2.
        apply H1.
      apply l7_2.
      apply H2.
    apply cong_transitivity with P Q; Cong.
    apply cong_transitivity with R S; Cong.
Qed.
symmetry_preserves_midpoint
Proof.
    intros.
    unfold Midpoint.
    unfold Midpoint in H2.
    spliter.
    split.
      eapply l7_15;eauto.
    eapply l7_16;eauto.
Qed.
Mid_cases
Proof.
    intros.
    decompose [or] H; Midpoint.
Qed.
Mid_perm
Proof.
    unfold Midpoint.
    intros.
    spliter.
    repeat split; Between; Cong.
Qed.
l7_17
Proof.
    intros.
    assert (Cong P B P' B).
      unfold Midpoint in *.
      spliter.
      Cong.
    assert (exists B', Midpoint A B B') by (apply symmetric_point_construction).
    induction H2.
    assert (Cong P' B P x) by eauto with midpoint cong.
    assert (Cong P B P x) by (apply cong_transitivity with P' B; Cong).
    assert (Cong P B P' x) by eauto with midpoint cong.
    assert (Cong P' B P' x) by (apply cong_transitivity with P x; Cong; apply cong_transitivity with P B; Cong).
    assert (Bet P B P') by (unfold Midpoint in *;spliter;assumption).
    assert (B=x) by (apply (l4_19 P P' B x);Between).
    subst x.
    apply l7_3.
    assumption.
Qed.
l7_17_bis
Proof.
    intros.
    apply l7_17 with P P'; Midpoint.
Qed.
l7_20
Proof.
    unfold Col.
    intros.
    induction H.
      right.
      unfold Midpoint.
      split.
        assumption.
      Cong.
    induction H.
      assert (Cong A B B B) by (apply (l4_3 A B M B B M);Between;Cong).
      treat_equalities;auto.
    assert (Cong B A A A) by (apply (l4_3 B A M A A M);Cong;Between).
    treat_equalities;auto.
Qed.
l7_20_bis
Proof.
   intros.
   induction (l7_20 M A B H0 H1);intuition.
Qed.
cong_col_mid
Proof.
    intros.
    apply l7_20 in H0.
      intuition subst.
    Cong.
Qed.
l7_21
Proof.
    intros.
    assert_diffs.
    assert (exists P', Cong_3 B D P D B P').
      eapply l4_14.
        Col.
      Cong.
    induction H9.
    assert (Col D B x) by
      (apply l4_13 with B D P;Col).
    assert (FSC B D P A D B x C).
      unfold FSC.
      unfold Cong_3 in *.
      spliter.
      repeat split; Cong; Col.
    assert (FSC B D P C D B x A).
      unfold FSC.
      unfold Cong_3 in *.
      spliter.
      repeat split; Col; Cong.
    assert (Cong P A x C) by (eauto using l4_16).
    assert (Cong P C x A) by (eauto using l4_16).
    assert (Cong_3 A P C C x A) by (unfold Cong_3;repeat split; Cong).
    assert (Col C x A) by (eauto using l4_13).
    assert (P=x).
      unfold FSC in *.
      spliter.
      apply (l6_21 A C B D); Col.
    subst x.
    unfold Cong_3 in *;spliter.
    split;apply l7_20_bis;Col;Cong.
Qed.
l7_22_aux
Proof.
    intros.
    induction (eq_dec_points A2 C).
      subst C.
      apply le_zero in H5.
      subst A2.
      apply cong_reverse_identity in H1.
      subst B1.
      apply cong_reverse_identity in H2.
      subst B2.
      apply l7_3 in H4.
      subst A1.
      apply between_trivial.
    assert (exists A, Midpoint C A2 A).
      apply symmetric_point_construction.
    induction H7.
    assert (exists B, Midpoint C B2 B).
      apply symmetric_point_construction.
    induction H8.
    assert (exists M, Midpoint C M2 M).
      apply symmetric_point_construction.
    induction H9.
    assert(Midpoint x1 x x0).
      unfold Midpoint.
      split.
        eapply l7_15.
          apply H7.
          apply H9.
          apply H8.
        unfold Midpoint in H4.
        spliter.
        assumption.
      eapply l7_16.
        apply H7.
        apply H9.
        apply H9.
        apply H8.
      unfold Midpoint in H4.
      spliter.
      assumption.
    assert (Le C A1 C x).
      eapply l5_6.
      repeat split.
        apply H5.
        apply cong_reflexivity.
      unfold Midpoint in H7.
      spliter.
      apply cong_left_commutativity.
      assumption.
    assert (Bet C A1 x).
      induction (eq_dec_points A1 C).
        subst A1.
        apply between_trivial2.
      eapply l6_13_1.
        unfold Out.
        2:assumption.
      repeat split.
        assumption.
        intro.
        subst x.
        apply le_zero in H11.
        apply H12.
        subst A1.
        reflexivity.
      eapply l5_2.
        apply H6.
        apply between_symmetry.
        assumption; intro.
      unfold Midpoint in H7.
      spliter.
      assumption.
    (* assert (M1=x).
    eauto with Midpoint.
    *)
    assert (Le C B1 C x0).
      eapply l5_6.
        apply H11.
        assumption.
      unfold Midpoint in *.
      spliter.
      eapply cong_transitivity.
        apply cong_symmetry.
        apply H16.
      eapply cong_transitivity.
        2:apply H15.
      apply cong_commutativity.
      assumption.
    assert (Bet C B1 x0).
      induction (eq_dec_points B1 C).
        subst B1.
        apply cong_symmetry in H1.
        apply cong_reverse_identity in H1.
        subst A1.
        apply between_trivial2.
      induction (eq_dec_points x0 C).
        subst x0.
        apply le_zero in H13.
        subst B1.
        apply between_trivial.
      induction (eq_dec_points B2 C).
        subst B2.
        apply cong_symmetry in H2.
        eapply cong_reverse_identity in H2.
        subst A2.
        apply le_zero in H5.
        subst A1.
        apply cong_reverse_identity in H1.
        subst B1.
        apply False_ind.
        apply H14.
        reflexivity.
      eapply l6_13_1.
        unfold Out.
        repeat split.
          assumption.
          assumption.
        eapply l5_2.
          2:apply between_symmetry.
          2:apply H0.
          assumption.
        2:assumption.
      unfold Midpoint in H8.
      spliter.
      assumption.
    assert (exists Q, Bet x1 Q C /\ Bet A1 Q B1).
      eapply l3_17.
        apply between_symmetry.
        apply H12.
        apply between_symmetry.
        apply H14.
      unfold Midpoint in H10.
      spliter.
      assumption.
    ex_and H15 Q.
    assert (IFSC x A1 C x1 x0 B1 C x1).
      unfold IFSC.
      unfold Midpoint in *.
      spliter.
      repeat split.
        apply between_symmetry.
        assumption.
        apply between_symmetry.
        assumption.
        eapply cong_transitivity.
          apply cong_commutativity.
          apply cong_symmetry.
          apply H20.
        eapply cong_transitivity.
          apply H2.
        apply cong_commutativity.
        assumption.
        apply cong_commutativity.
        assumption.
        apply cong_right_commutativity.
        assumption.
      apply cong_reflexivity.
    assert (Cong A1 x1 B1 x1).
      eapply l4_2.
      apply H17.
    assert (Cong Q A1 Q B1).
      induction(eq_dec_points C x1).
        subst x1.
        apply between_identity in H15.
        subst Q.
        apply cong_commutativity.
        assumption.
      eapply l4_17.
        apply H19.
        unfold Col.
        right; left.
        assumption.
        assumption.
      apply cong_commutativity.
      assumption.
    assert (Midpoint Q A1 B1).
      unfold Midpoint.
      split.
        assumption.
      apply cong_left_commutativity.
      assumption.
    assert (Q=M1).
      eapply l7_17.
        apply H20.
      assumption.
    subst Q.
    eapply between_exchange3.
      apply H15.
    unfold Midpoint in H9.
    spliter.
    apply between_symmetry.
    assumption.
Qed.
l7_22
Proof.
    intros.
    assert (Le C A1 C A2 \/ Le C A2 C A1).
      eapply le_cases.
    induction H5.
      eapply l7_22_aux.
        apply H.
        apply H0.
        apply H1.
        apply H2.
        assumption.
        assumption.
      assumption.
    apply between_symmetry.
    eapply l7_22_aux.
      7:apply H5.
      apply between_symmetry.
      apply H.
      5:apply H3.
      4:apply H4.
      apply between_symmetry.
      apply H0.
      assumption.
    assumption.
Qed.
bet_col1
Proof.
    intros.
    assert(Bet A B C \/ Bet A C B).
      eapply l5_3.
        apply H.
      assumption.
    unfold Col.
    induction H1.
      left.
      assumption.
    right; left.
    apply between_symmetry.
    assumption.
Qed.
l7_25
Proof.
    intros.
    induction(Col_dec A B C).
      assert(A = B \/ Midpoint C A B).
        apply l7_20.
          unfold Col in *.
          intuition.
        assumption.
      induction H1.
        subst B.
        exists A.
        apply l7_3_2.
      exists C.
      assumption.
    assert (exists P, Bet C A P /\ A<>P).
      apply point_construction_different.
    ex_and H1 P.
    prolong C B Q A P.
    assert (exists R, Bet A R Q /\ Bet B R P).
      eapply inner_pasch.
        apply between_symmetry.
        apply H1.
      apply between_symmetry.
      assumption.
    ex_and H5 R.
    assert (exists X, Bet A X B /\ Bet R X C).
      eapply inner_pasch.
        apply H1.
      assumption.
    ex_and H7 X.
    exists X.
    unfold Midpoint.
    split.
      assumption.
    apply cong_left_commutativity.
    cut(Cong R A R B).
      intros.
      induction(eq_dec_points R C).
        subst R.
        assert (C = X).
          apply between_identity.
          assumption.
        subst X.
        assumption.
      eapply l4_17.
        apply H10.
        unfold Col.
        right; left.
        apply between_symmetry.
        assumption.
        assumption.
      assumption.
    assert (OFSC C A P B C B Q A).
      unfold OFSC.
      repeat split.
        assumption.
        assumption.
        assumption.
        apply cong_symmetry.
        assumption.
        apply cong_symmetry.
        assumption.
      apply cong_pseudo_reflexivity.
    assert (Cong P B Q A).
      eapply five_segment_with_def.
        eapply H9.
      unfold Col in H0.
      intuition.
      apply H0.
      subst A.
      apply between_trivial.
    assert (exists R', Bet A R' Q /\ Cong_3 B R P A R' Q).
      eapply l4_5.
        assumption.
      apply cong_commutativity.
      assumption.
    ex_and H11 R'.
    assert (IFSC B R P A A R' Q B).
      unfold IFSC.
      repeat split.
        assumption.
        assumption.
        apply cong_commutativity.
        assumption.
        unfold Cong_3 in H12.
        spliter.
        assumption.
        apply cong_pseudo_reflexivity.
      apply cong_commutativity.
      apply cong_symmetry.
      assumption.
    assert (IFSC B R P Q A R' Q P).
      unfold IFSC.
      repeat split;try assumption.
        apply cong_commutativity.
        assumption.
        unfold Cong_3 in H12.
        spliter.
        assumption.
      apply cong_pseudo_reflexivity.
    assert (Cong R A R' B).
      eapply l4_2.
      apply H13.
    assert (Cong R Q R' P).
      eapply l4_2.
      apply H14.
    assert (Cong_3 A R Q B R' P).
      unfold Cong_3.
      repeat split.
        apply cong_commutativity.
        assumption.
        apply cong_commutativity.
        apply cong_symmetry.
        assumption.
      assumption.
    assert (Col B R' P).
      eapply l4_13.
        2:apply H17.
      unfold Col.
      left.
      assumption.
    cut(R=R').
      intro.
      subst R'.
      assumption.
    assert (B <> P).
      unfold IFSC, OFSC, Cong_3 in *.
      spliter.
      intro.
      subst P.
      apply between_identity in H14.
      subst R.
      apply cong_reverse_identity in H12.
      subst R'.
      apply cong_reverse_identity in H32.
      subst Q.
      apply between_identity in H5.
      apply H2.
      assumption.
    assert (A <> Q).
      unfold IFSC, OFSC, Cong_3 in *.
      spliter.
      intro.
      subst Q.
      apply cong_reverse_identity in H20.
      subst P.
      apply H19.
      reflexivity.
    assert(B <> Q).
      intro.
      subst Q.
      apply cong_symmetry in H4.
      apply cong_identity in H4.
      subst P.
      apply H2.
      reflexivity.
    assert (B <> R).
      intro.
      unfold Cong_3, IFSC, OFSC in *.
      spliter.
      subst R.
      clean_duplicated_hyps.
      assert (Col B A C).
        apply col_transitivity_1 with X; Col.
        intro.
        apply cong_symmetry in H12.
        apply cong_identity in H12.
        subst R'.
        subst X.
        clean_duplicated_hyps.
        assert (Bet B A C \/ Bet B C A).
          eapply l5_2.
            2:apply between_symmetry.
            2:apply H5.
            intro.
            apply H21.
            rewrite H9.
            reflexivity.
          apply between_symmetry.
          assumption.
        apply H0.
        unfold Col.
        induction H9.
          right;right.
          apply between_symmetry.
          assumption.
        right; left.
        assumption.
      apply H0.
      apply col_permutation_4.
      assumption.
    eapply (l6_21 A Q B P R R' ).
      intro.
      unfold Col in H23.
      induction H23.
        assert(Bet A B C).
          eapply outer_transitivity_between2.
            apply H23.
            apply between_symmetry.
            assumption.
          intro.
          apply H21.
          rewrite H24.
          reflexivity.
        apply H0.
        unfold Col.
        left.
        assumption.
      induction H23.
        assert(Bet B A C \/ Bet B C A).
          eapply l5_2.
            2:apply H23.
            intro.
            apply H21.
            rewrite H24.
            reflexivity.
          apply between_symmetry.
          assumption.
        apply H0.
        unfold Col.
        induction H24.
          right;right.
          apply between_symmetry.
          assumption.
        right; left.
        assumption.
      assert(Bet A B C).
        eapply between_exchange3.
          apply between_symmetry.
          apply H23.
        apply between_symmetry.
        assumption.
      apply H0.
      unfold Col.
      left.
      assumption.
      assumption.
      unfold Col.
      right; left.
      apply between_symmetry.
      assumption.
      unfold Col.
      right; left.
      apply between_symmetry.
      assumption.
      unfold Col.
      right; left.
      apply between_symmetry.
      assumption.
    unfold Col.
    unfold Col in H18.
    induction H18.
      right; left.
      apply between_symmetry.
      assumption.
    induction H18.
      left.
      apply between_symmetry.
      assumption.
    right;right.
    apply between_symmetry.
    assumption.
Qed.
midpoint_distinct_1
Proof.
    intros.
    split.
      intro.
      subst.
      unfold Midpoint in *.
      decompose [and] H0.
      treat_equalities.
      intuition.
    intro;subst.
    unfold Midpoint in *.
    decompose [and] H0.
    treat_equalities.
    intuition.
Qed.
midpoint_distinct_2
Proof.
    intros.
    assert (A<>B).
      intro.
      unfold Midpoint in *;spliter.
      treat_equalities.
      intuition.
    split.
      assumption.
    apply midpoint_distinct_1 in H0.
      intuition.
    intuition.
Qed.
midpoint_distinct_3
Proof.
    intros.
    assert (A<>B).
      intro.
      unfold Midpoint in *;spliter.
      treat_equalities.
      intuition.
    split.
      assumption.
    apply midpoint_distinct_1 in H0.
      intuition.
    intuition.
Qed.
midpoint_def
Proof.
    intros.
    unfold Midpoint.
    split;assumption.
Qed.
midpoint_bet
Proof.
    unfold Midpoint.
    intros.
    elim H.
    intros.
    assumption.
Qed.
midpoint_col
Proof.
    intros.
    unfold Col.
    right;right.
    apply midpoint_bet.
    apply l7_2.
    assumption.
Qed.
midpoint_cong
Proof.
    unfold Midpoint.
    intros.
    elim H.
    intros.
    assumption.
Qed.
midpoint_not_midpoint
Proof.
    intros.
    assert (I<>B).
      apply midpoint_distinct_1 in H0.
        tauto.
      assumption.
    apply midpoint_bet in H0.
    intro.
    apply midpoint_bet in H2.
    assert (I=B).
      apply between_symmetry in H0.
      apply between_symmetry in H2.
      eapply between_equality.
        apply H2.
      apply H0.
    intuition.
Qed.
swap_diff
Proof.
    intuition.
Qed.
cong_cong_half_1
Proof.
    intros.
    unfold Midpoint in *.
    spliter.
    assert(exists M'', Bet A' M'' B' /\ Cong_3 A M B A' M'' B').
      eapply l4_5.
        assumption.
      assumption.
    ex_and H4 M''.
    assert (Midpoint M'' A' B').
      unfold Midpoint.
      split.
        assumption.
      unfold Cong_3 in H5.
      spliter.
      eapply cong_transitivity.
        apply cong_symmetry.
        apply H5.
      eapply cong_transitivity.
        apply H3.
      assumption.
    assert(M'=M'').
      eapply l7_17; unfold Midpoint; split.
        apply H0.
        apply H2.
        apply H4.
      unfold Midpoint in H6.
      spliter.
      assumption.
    subst M''.
    unfold Cong_3 in H5.
    spliter.
    assumption.
Qed.
cong_cong_half_2
Proof.
    intros.
    apply cong_cong_half_1 with A A'.
      Midpoint.
      Midpoint.
    Cong.
Qed.
cong_mid2__cong
Proof.
    intros A M B A' M' B' HM HM' HCong.
    destruct HM.
    destruct HM'.
    apply (l2_11 _ M _ _ M'); auto.
    apply (cong_transitivity _ _ A' M'); auto.
    apply (cong_transitivity _ _ A M); Cong.
Qed.
mid__lt
Proof.
    intros A M B HAB HM.
    destruct (midpoint_distinct_1 M A B HAB HM) as [HMA HMB].
    destruct HM.
    split.
      exists M; Cong.
    intro.
    apply HMB, between_cong with A; auto.
Qed.
le_mid2__le13
Proof.
    intros A M B A' M' B' HM HM' Hle.
    destruct HM.
    destruct HM'.
    apply (bet2_le2__le1346 _ M _ _ M'); auto.
    apply (l5_6 A M A' M'); auto.
Qed.
le_mid2__le12
Proof.
    intros A M B A' M' B' HM HM' Hle.
    elim(le_cases A M A' M'); auto.
    intro.
    assert(Le A' B' A B) by (apply (le_mid2__le13 _ M' _ _ M); auto).
    apply cong__le.
    apply (cong_cong_half_1 _ _ B _ _ B'); auto.
    apply le_anti_symmetry; auto.
Qed.
lt_mid2__lt13
Proof.
    intros A M B A' M' B' HM HM' [HLe HNcong].
    split.
      apply le_mid2__le13 with M M'; trivial.
    intro.
    apply HNcong, cong_cong_half_1 with B B'; trivial.
Qed.
lt_mid2__lt12
Proof.
    intros A M B A' M' B' HM HM' [HLe HNcong].
    split.
      apply le_mid2__le12 with B B'; trivial.
    intro.
    apply HNcong, cong_mid2__cong with M M'; trivial.
Qed.
midpoint_preserves_out
Proof.
    intros.
    unfold Out in H.
    spliter.
    unfold Out.
    repeat split.
      intro.
      subst B'.
      assert (A = B).
        eapply symmetric_point_uniqueness.
          apply l7_2.
          apply H0.
        apply l7_2.
        assumption.
      auto.
      intro.
      subst C'.
      assert (A = C).
        eapply symmetric_point_uniqueness.
          apply l7_2.
          apply H0.
        apply l7_2.
        assumption.
      auto.
    induction H4.
      left.
      apply (l7_15 A B C A' B' C' M); assumption.
    right.
    eapply (l7_15 A C B A' C' B' M); assumption.
Qed.
col_cong_bet
Proof.
intros.

prolong B A D1 B C.
prolong A B D2 A C.

assert(Cong A B C D1).
eapply (l2_11 A C B C A D1).
assumption.
eapply between_exchange3.
apply between_symmetry.
apply H1.
assumption.
apply cong_pseudo_reflexivity.
Cong.
assert(D = D1 \/ Midpoint C D D1).
eapply l7_20.
apply bet_col in H1.
apply bet_col in H2.

induction (eq_dec_points A B).
subst B.
apply cong_symmetry in H0.
apply cong_identity in H0.
subst D.
Col.
eapply (col3 A B); Col.

eCong.

induction H7.
subst D1.
left.
eapply between_exchange3.
apply between_symmetry.
apply H1.
assumption.

assert(Cong B A C D2).
eapply (l2_11 B C A C B D2).
Between.
eapply between_exchange3.
apply H1.
assumption.
apply cong_pseudo_reflexivity.
Cong.

assert(Midpoint C D2 D1).
unfold Midpoint.
split.

induction(eq_dec_points A B).
subst B.
apply cong_symmetry in H0.
apply cong_identity in H0.
subst D.
apply is_midpoint_id in H7.
subst D1.
Between.
apply between_symmetry.

induction(eq_dec_points B C).
subst C.
apply between_symmetry.
apply cong_identity in H3.
subst D1.
Between.

assert(Bet D1 C B).
eBetween.
assert(Bet C B D2).
eBetween.
eapply (outer_transitivity_between).
apply H11.
assumption.
auto.
unfold Midpoint in H7.
spliter.
eapply cong_transitivity.
apply cong_symmetry.
apply cong_commutativity.
apply H8.
eapply cong_transitivity.
apply H0.
Cong.
assert(D = D2).
eapply symmetric_point_uniqueness.
apply l7_2.
apply H7.
apply l7_2.
assumption.
subst D2.
right.
eapply between_exchange3.
apply H1.
assumption.
Qed.
col_cong2_bet1
Proof.
intros.
induction(eq_dec_points A C).
subst C.
apply cong_symmetry in H2.
apply cong_identity in H2.
subst D.
Between.

assert(HH:=col_cong_bet A B C D H H1 H0).
induction HH.
assert(A = D /\ B = C).
eapply bet_cong_eq.
Between.
eBetween.
Cong.
spliter.
subst D.
subst C.
Between.
assumption.
Qed.
col_cong2_bet2
Proof.
intros.

induction(eq_dec_points B C).
subst C.
apply cong_identity in H2.
subst D.
Between.

assert(HH:=col_cong_bet A B C D H H1 H0).
induction HH.
assumption.

assert(C = A /\ D = B).
eapply bet_cong_eq.
Between.
eBetween.
Cong.
spliter.
subst D.
subst C.
Between.
Qed.
col_cong2_bet3
Proof.
intros.

induction(eq_dec_points A B).
subst B.
apply cong_symmetry in H1.
apply cong_identity in H1.
subst D.
Between.


eapply (col_cong2_bet2 _ A).
apply bet_col in H0. 
ColR.
Between.
Cong.
Cong.
Qed.
col_cong2_bet4
Proof.
intros.
induction(eq_dec_points A B).
subst B.
apply cong_symmetry in H1.
apply cong_identity in H1.
subst D.
Between.
apply (col_cong2_bet1 A D B C).
apply bet_col in H0.
ColR.
assumption.
Cong.
Cong.
Qed.
col_bet2_cong1
Proof.
intros.
apply (l4_3 A C B D B C); Between;  Cong.
Qed.
col_bet2_cong2
Proof.
intros.
apply (l4_3 D A C B C A); Between; Cong.
Qed.
bet2_lt2__lt
Proof.
intros.
unfold Lt.
split.
unfold Lt in *.
spliter.
apply(bet2_le2__le O o A B a b); auto.
intro.

induction(eq_dec_points O A).
treat_equalities.
unfold Lt in H1.
spliter.
apply le_zero in H0.
treat_equalities.
apply H1.
apply cong_trivial_identity.

induction(eq_dec_points O B).
treat_equalities.
unfold Lt in H2.
spliter.
apply le_zero in H0.
treat_equalities.
apply H2.
apply cong_trivial_identity.

unfold Lt in *.
spliter.

unfold Le in H1.
ex_and H1 a'.
unfold Le in H2.
ex_and H2 b'.

assert(Bet a' O b').
eBetween.
assert(Cong a b a' b').
{
  apply (l2_11 a o b a' O b'); Cong.
}
assert(Cong a' b' A B) by (apply cong_transitivity with a b; Cong).
assert(Bet A b' B) by eBetween.

induction(eq_dec_points A a').
treat_equalities.
assert(b'=B \/ Midpoint A b' B).
{
  apply l7_20.
  Col.
  Cong.
}
induction H1.
treat_equalities.
contradiction.
unfold Midpoint in *.
spliter.
assert(b' = B).
{
  apply (between_cong A).
  Between.
  Cong.
}
treat_equalities; tauto.

assert(Bet B a' A) by eBetween.
induction(eq_dec_points B b').
treat_equalities.
assert(a'=A \/ Midpoint B a' A).
{
  apply l7_20.
  Col.
  Cong.
}
induction H2.
treat_equalities.
contradiction.
unfold Midpoint in *.
spliter.
assert(a' = A).
{
  apply (between_cong B).
  Between.
  Cong.
}
treat_equalities; tauto.

assert(Bet a' A b' \/ Bet a' B b').
{
  apply(col_cong_bet A B a' b').
  Col.
  Cong.
  eBetween.
}
induction H17.
assert(A = a').
{
  apply(between_equality _ _ b').
  eBetween.
  Between.
}
treat_equalities; tauto.
assert(b' = B).
{
  apply(between_equality _ _ a').
  Between.
  eBetween.
}
treat_equalities; tauto.
Qed.
bet2_lt_le__lt
Proof.
intros.
unfold Lt.
split.
unfold Lt in *.
spliter.
assert(Le o a O A).
{
  unfold Le.
  exists A.
  split; Between.
}
apply(bet2_le2__le O o A B a b); auto.
intro.

assert(HH:=segment_construction A O o b).
ex_and HH b'.

unfold Lt in H2.
spliter.
apply H6.

apply(l4_3_1 a o b A O B H H0 ); Cong.
Qed.
Per_dec
Proof.
    intros.
    unfold Per.
    elim (symmetric_point_construction C B);intros C' HC'.
    elim (Cong_dec A C A C');intro.
      left.
      exists C'.
      intuition.
    right.
    intro.
    decompose [ex and] H0;clear H0.
    assert (C'=x) by (apply symmetric_point_uniqueness with C B;assumption).
    subst.
    intuition.
Qed.
l8_2
Proof.
    unfold Per.
    intros.
    ex_and H C'.
    assert (exists A', Midpoint B A A').
      apply symmetric_point_construction.
    ex_and H1 A'.
    exists A'.
    split.
      assumption.
    eapply cong_transitivity.
      apply cong_commutativity.
      apply H0.
    eapply l7_13.
      apply H.
    apply l7_2.
    assumption.
Qed.
Per_cases
Proof.
    intros.
    decompose [or]  H;Perp.
Qed.
Per_perm
Proof.
    intros.
    split; Perp.
Qed.
l8_3
Proof.
    unfold Per.
    intros.
    ex_and H C'.
    exists C'.
    split.
      assumption.
    unfold Midpoint in *;spliter.
    eapply l4_17 with A B;finish.
Qed.
l8_4
Proof.
    unfold Per.
    intros.
    ex_and H B'.
    exists C.
    split.
      apply l7_2.
      assumption.
    assert (B' = C') by (eapply symmetric_point_uniqueness;eauto).
    subst B'.
    Cong.
Qed.
l8_5
Proof.
    unfold Per.
    intros.
    exists B.
    split.
      apply l7_3_2.
    Cong.
Qed.
l8_6
Proof.
    unfold Per.
    intros.
    ex_and H C'.
    ex_and H0 C''.
    assert (C'=C'') by (eapply symmetric_point_uniqueness;eauto).
    subst C''.
    assert (C = C') by (eapply l4_19;eauto).
    subst C'.
    apply l7_3.
    assumption.
Qed.
l8_7
Proof.
    intros.
    unfold Per in H.
    ex_and H C'.
    symmetric A' C A.
    induction (eq_dec_points B C).
      assumption.
    assert (Per C' C A).
      eapply l8_3.
        eapply l8_2.
        apply H0.
        assumption.
      unfold Midpoint in H.
      spliter.
      unfold Col.
      left.
      assumption.
    assert (Cong A C' A' C').
      unfold Per in H4.
      ex_and H4 Z.
      assert (A' = Z) by (eapply (symmetric_point_uniqueness A C A');auto).
      subst Z.
      Cong.
    unfold Midpoint in *.
    spliter.
    assert (Cong A' C A' C').
      eapply cong_transitivity.
        apply cong_symmetry.
        apply cong_commutativity.
        apply H6.
      eapply cong_transitivity.
        apply cong_commutativity.
        apply H1.
      apply cong_left_commutativity.
      assumption.
    assert (Per A' B C).
      unfold Per.
      exists C'.
      unfold Midpoint.
      repeat split;auto.
    eapply l8_6.
      apply H9.
      unfold Per.
      exists C'.
      split.
        unfold Midpoint;auto.
      apply H1.
    Between.
Qed.
l8_8
Proof.
    intros.
    apply l8_7 with A.
      apply l8_2.
      apply l8_5.
    assumption.
Qed.
l8_9
Proof.
    intros.
    elim (eq_dec_points A B);intro.
      tauto.
    right.
    eapply l8_7.
      eapply l8_2.
      eapply l8_5.
    apply l8_3 with A; Col.
Qed.
l8_10
Proof.
    unfold Per.
    intros.
    ex_and H D.
    prolong C' B' D' B' C'.
    exists D'.
    split.
      unfold Midpoint.
      split.
        assumption.
      Cong.
    unfold Cong_3, Midpoint in *.
    spliter.
    induction (eq_dec_points C B).
      treat_equalities;Cong.
    assert(OFSC C B D A C' B' D' A').
      unfold OFSC.
      repeat split.
        assumption.
        assumption.
        Cong.
        eapply cong_transitivity.
          apply cong_symmetry.
          apply H4.
        eapply cong_transitivity.
          apply cong_commutativity.
          apply H6.
        Cong.
        Cong.
      Cong.
    assert (Cong D A D' A').
      eapply five_segment_with_def.
        apply H8.
      assumption.
    eapply cong_transitivity.
      apply cong_symmetry.
      apply H5.
    eapply cong_transitivity.
      apply H1.
    Cong.
Qed.
col_col_per_per
Proof.
    intros.
    assert (Per U X C) by (apply (l8_3 A X C U);Col).
    apply l8_2 in H4.
    apply l8_2 .
    apply (l8_3 C X U V);Col.
Qed.
Perp_in_dec
Proof.
    intros.
    unfold Perp_at.
    elim (eq_dec_points A B);intro; elim (eq_dec_points C D);intro; elim (Col_dec X A B);intro; elim (Col_dec X C D);intro; try tauto.
    elim (eq_dec_points B X);intro; elim (eq_dec_points D X);intro;subst;treat_equalities.
      elim (Per_dec A X C);intro.
        left;repeat split;Col;intros; apply col_col_per_per with A C;Col.
      right;intro;spliter;apply H3;apply H8;Col.
      elim (Per_dec A X D);intro.
        left;repeat split;Col;intros; apply col_col_per_per with A D;Col;ColR.
      right;intro;spliter;apply H3;apply H9;Col.
      elim (Per_dec B X C);intro.
        left;repeat split;Col;intros; apply col_col_per_per with B C;Col;ColR.
      right;intro;spliter;apply H4;apply H9;Col.
    elim (Per_dec B X D);intro.
      left;repeat split;Col;intros; apply col_col_per_per with B D;Col;ColR.
    right;intro;spliter;apply H5;apply H10;Col.
Qed.
perp_distinct
Proof.
    intros.
    unfold Perp in H.
    ex_elim H X.
    unfold Perp_at in H0.
    tauto.
Qed.
l8_12
Proof.
    unfold Perp_at.
    intros.
    spliter.
    repeat split;try assumption.
    intros;eapply l8_2;eauto.
Qed.
per_col
Proof.
    unfold Per.
    intros.
    ex_and H0 C'.
    prolong D B D' D B.
    exists D'.
    assert (Midpoint B C C').
      apply H0.
    induction H5.
    assert (Midpoint B D D') by (unfold Midpoint;split;Cong).
    assert (Midpoint B D D').
      apply H7.
    induction H8.
    repeat split.
      assumption.
      Cong.
    unfold Col in H1.
    induction H1.
      assert (Bet B C' D').
        eapply l7_15.
          eapply l7_3_2.
          apply H0.
          apply H7.
        assumption.
      assert (Cong C D C' D').
        eapply l4_3_1.
          apply H1.
          apply H10.
          Cong.
        Cong.
      assert(OFSC B C D A B C' D' A) by (unfold OFSC;repeat split;Cong).
      apply cong_commutativity.
      eauto using five_segment_with_def.
    induction H1.
      assert (Bet C' D' B).
        eapply l7_15.
          apply H0.
          apply H7.
          apply l7_3_2.
        assumption.
      assert (Cong C D C' D') by (eapply l4_3 with B B;Between;Cong).
      assert(IFSC B D C A B D' C' A) by (unfold IFSC;repeat split;Between;Cong).
      apply cong_commutativity.
      eauto using l4_2.
    assert (Bet D' B C').
      eapply l7_15.
        apply H7.
        eapply l7_3_2.
        apply H0.
      assumption.
    assert (Cong C D C' D') by (eapply l2_11 with B B;Between;Cong).
    assert(OFSC C B D A C' B D' A) by (unfold OFSC;repeat split;Between;Cong).
    apply cong_commutativity.
    eauto using five_segment_with_def.
Qed.
l8_13_2
Proof.
    intros.
    ex_and H3 U.
    ex_and H4 V.
    unfold Perp_at.
    repeat split;try assumption.
    intros.
    assert (Per V X U0).
      eapply l8_2.
      eapply l8_3.
        apply H7.
        assumption.
      eapply col3.
        apply H.
        Col.
        Col.
      Col.
    eapply per_col.
      2:eapply l8_2.
      2:apply H10.
      auto.
    eapply col3.
      apply H0.
      Col.
      Col.
    Col.
Qed.
l8_14_1
Proof.
    intros.
    unfold Perp.
    intro.
    ex_and H X.
    unfold Perp_at in H0.
    spliter.
    assert (Per A X A).
      apply H3.
        Col.
      Col.
    assert (A = X).
      eapply l8_7.
        2: apply H4.
      apply l8_2.
      apply l8_5.
    assert (Per B X B) by (apply H3;Col).
    assert (B = X).
      eapply l8_7 with B.
        2: apply H6.
      apply l8_2.
      apply l8_5.
    apply H0.
    congruence.
Qed.
l8_14_2_1a
Proof.
    intros.
    unfold Perp.
    exists X.
    assumption.
Qed.
perp_in_distinct
Proof.
    intros.
    apply l8_14_2_1a in H.
    apply perp_distinct.
    assumption.
Qed.
l8_14_2_1b
Proof.
    intros.
    unfold Perp_at in H.
    spliter.
    apply (H5 Y Y) in H1.
      apply eq_sym, l8_8; assumption.
    assumption.
Qed.
l8_14_2_1b_bis
Proof.
    intros.
    unfold Perp in H.
    ex_and H Y.
    assert (Y = X) by (eapply (l8_14_2_1b Y _ _ _ _ X) in H2;assumption).
    subst Y.
    assumption.
Qed.
l8_14_2_2
Proof.
    intros.
    eapply l8_14_2_1b_bis.
      assumption.
      unfold Perp in H.
      ex_and H Y.
      unfold Perp_at in H1.
      spliter.
      assert (Col Y C D) by assumption.
      apply (H0 Y H2) in H3.
      subst Y.
      assumption.
    unfold Perp in H.
    ex_and H Y.
    unfold Perp_at in H1.
    spliter.
    assert (Col Y C D).
      assumption.
    apply (H0 Y H2) in H3.
    subst Y.
    assumption.
Qed.
l8_14_3
Proof.
    intros.
    eapply l8_14_2_1b.
      apply H.
      unfold Perp_at in H0.
      intuition.
    eapply l8_12 in H0.
    unfold Perp_at in H0.
    intuition.
Qed.
l8_15_1
Proof.
    intros.
    eapply l8_14_2_1b_bis;Col.
Qed.
l8_15_2
Proof.
    intros.
    eapply l8_14_2_1a.
    apply H1.
Qed.
perp_in_per
Proof.
    intros.
    unfold Perp_at in H.
    spliter.
    apply H3;Col.
Qed.
perp_sym
Proof.
    unfold Perp.
    intros.
    ex_and H X.
    exists X.
    apply l8_12.
    assumption.
Qed.
perp_col0
Proof.
    unfold Perp.
    intros.
    ex_and H X0.
    exists X0.
    unfold Perp_at in *.
    spliter.
    repeat split.
      assumption.
      assumption.
      assumption.
      eapply col3.
        apply H.
        Col.
        assumption.
      assumption.
    intros.
    eapply l8_2.
    apply H6.
      2:assumption.
    assert(Col A X Y).
      eapply col3 with A B;Col.
    assert (Col B X Y).
      eapply col3 with A B;Col.
    eapply col3 with X Y;Col.
Qed.
l8_16_1
Proof.
    intros.
    split.
      intro.
      assert (Perp_at X A B C X).
        eapply l8_15_1.
          assumption.
          assumption.
        assumption.
      assert (X = U).
        eapply l8_14_2_1b.
          apply H5.
          Col.
        eapply col3 with A B;Col.
      intuition.
    apply l8_14_2_1b_bis with C X U X;try Col.
    assert (Col A X U).
      eapply (col3 A B);Col.
    eapply perp_col0 with A B;Col.
Qed.
per_perp_in
Proof.
    intros.
    unfold Perp.
    repeat split.
      assumption.
      assumption.
      Col.
      Col.
    intros.
    eapply per_col.
      apply H0.
      eapply l8_2.
      eapply per_col.
        intro.
        apply H.
        apply sym_equal.
        apply H4.
        apply l8_2.
        assumption.
      Col.
    Col.
Qed.
per_perp
Proof.
    intros.
    apply per_perp_in in H1.
      eapply l8_14_2_1a with B;assumption.
      assumption.
    assumption.
Qed.
perp_left_comm
Proof.
    unfold Perp.
    intros.
    ex_and H X.
    exists X.
    unfold Perp_at in *.
    intuition.
Qed.
perp_right_comm
Proof.
    unfold Perp.
    intros.
    ex_and H X.
    exists X.
    unfold Perp_at in *.
    intuition.
Qed.
perp_comm
Proof.
    intros.
    apply perp_left_comm.
    apply perp_right_comm.
    assumption.
Qed.
perp_in_sym
Proof.
    unfold Perp_at.
    intros.
    spliter.
    repeat split.
      assumption.
      assumption.
      assumption.
      assumption.
    intros.
    apply l8_2.
    apply H3;assumption.
Qed.
perp_in_left_comm
Proof.
    unfold Perp_at.
    intuition.
Qed.
perp_in_right_comm
Proof.
    intros.
    apply perp_in_sym.
    apply perp_in_left_comm.
    apply perp_in_sym.
    assumption.
Qed.
perp_in_comm
Proof.
    intros.
    apply perp_in_left_comm.
    apply perp_in_right_comm.
    assumption.
Qed.
Perp_cases
Proof.
    intros.
    decompose [or] H; Perp.
Qed.
Perp_perm
Proof.
    intros.
    repeat split; Perp.
Qed.
Perp_in_cases
Proof.
    intros.
    decompose [or]  H; Perp.
Qed.
Perp_in_perm
Proof.
    intros.
    do 7 (split; Perp).
Qed.
l8_16_2
Proof.
    intros.
    assert (C <> X).
      intro.
      subst X.
      apply H3.
      assumption.
    unfold Perp.
    exists X.
    eapply l8_13_2.
      assumption.
      assumption.
      Col.
      Col.
    exists U.
    exists C.
    repeat split; Col.
    apply l8_2.
    assumption.
Qed.
l8_18_uniqueness
Proof.
    intros.
    show_distinct A B.
      solve [intuition].
    assert (Perp_at X A B C X) by (eapply l8_15_1;assumption).
    assert (Perp_at Y A B C Y) by (eapply l8_15_1;assumption).
    unfold Perp_at in *.
    spliter.
    apply l8_7 with C;apply l8_2;[apply H14 |apply H10];Col.
Qed.
midpoint_distinct
Proof.
    intros.
    intro.
    subst C'.
    apply H.
    unfold Midpoint in H1.
    spliter.
    treat_equalities.
    assumption.
Qed.
l8_20_1
Proof.
    intros.
    double B A B'.
    double D A D'.
    double P A P'.
    induction (eq_dec_points A B).
      subst B.
      unfold Midpoint in H5.
      spliter.
      eapply l8_2.
      eapply l8_5.
    assert (Per B' B C).
      eapply l8_3.
        apply H.
        assumption.
      unfold Col.
      left.
      apply midpoint_bet.
      assumption.
    assert (Per B B' C').
      eapply l8_10.
        apply H7.
      unfold Cong_3.
      repeat split.
        apply cong_pseudo_reflexivity.
        eapply l7_13.
          unfold Midpoint.
          split.
            apply H3.
          apply midpoint_cong.
          assumption.
        assumption.
      eapply l7_13.
        apply l7_2.
        apply H3.
      assumption.
    assert(Midpoint B' D' C').
      eapply symmetry_preserves_midpoint.
        apply H4.
        apply H3.
        apply l7_2.
        apply H1.
      assumption.
    assert(Midpoint P' C D').
      eapply symmetry_preserves_midpoint.
        apply H1.
        apply H5.
        apply H4.
      assumption.
    unfold Per.
    exists P'.
    split.
      assumption.
    unfold Per in H7.
    ex_and H7 D''.
    assert (D''= D).
      eapply symmetric_point_uniqueness.
        apply H7.
      apply l7_2.
      assumption.
    subst D''.
    unfold Per in H8.
    ex_and H8 D''.
    assert (D' = D'').
      eapply symmetric_point_uniqueness.
        apply l7_2.
        apply H9.
      assumption.
    subst D''.
    assert (Midpoint P C' D).
      eapply symmetry_preserves_midpoint.
        apply l7_2.
        apply H1.
        apply l7_2.
        apply H5.
        apply l7_2.
        apply H4.
      assumption.
    assert (Cong C D C' D').
      eapply l7_13.
        apply H1.
      apply l7_2.
      assumption.
    assert (Cong C' D C D').
      eapply l7_13.
        apply l7_2.
        apply H1.
      apply l7_2.
      assumption.
    assert(Cong P D P' D').
      eapply l7_13.
        apply l7_2.
        apply H5.
      apply l7_2.
      assumption.
    assert (Cong P D P' C).
      eapply cong_transitivity.
        apply H16.
      unfold Midpoint in H10.
      spliter.
      apply cong_right_commutativity.
      apply cong_symmetry.
      assumption.
    assert (IFSC C' P D B D' P' C B).
      unfold IFSC.
      repeat split.
        apply midpoint_bet.
        assumption.
        apply midpoint_bet.
        apply l7_2.
        assumption.
        apply cong_right_commutativity.
        assumption.
        assumption.
        apply cong_commutativity.
        assumption.
      apply cong_right_commutativity.
      apply midpoint_cong.
      assumption.
    assert (Cong P B P' B).
      eapply l4_2.
      apply H18.
    apply cong_commutativity.
    assumption.
Qed.
l8_20_2
Proof.
    intros.
    intro.
    subst P.
    assert (C = D).
      eapply symmetric_point_uniqueness.
        apply H1.
      assumption.
    subst D.
    assert (B = C).
      apply l7_3.
      assumption.
    subst C.
    absurde.
Qed.
perp_col1
Proof.
    intros.
    assert (T:=perp_distinct A B C D H0).
    spliter.
    unfold Perp in *.
    ex_and H0 P.
    exists P.
    unfold Perp_at in *.
    spliter.
    repeat split.
      assumption.
      assumption.
      assumption.
      apply col_permutation_2.
      eapply col_transitivity_2.
        intro.
        apply H3.
        apply sym_equal.
        apply H8.
        apply col_permutation_4.
        assumption.
      apply col_permutation_3.
      assumption.
    intros.
    apply H7.
      assumption.
    apply col_permutation_2.
    eapply col_transitivity_1.
      apply H.
      apply col_permutation_5.
      assumption.
    apply col_permutation_1.
    assumption.
Qed.
l8_18_existence
Proof.
    intros.
    prolong B A Y A C.
    assert (exists P, Midpoint P C Y) by (apply l7_25 with A;Cong).
    ex_and H2 P.
    assert (Per A P Y) by (unfold Per;exists C;auto using l7_2).
    prolong A Y Z Y P.
    prolong P Y Q Y A.
    prolong Q Z Q' Q Z.
    assert (Midpoint Z Q Q') by (unfold Midpoint;split;Cong).
    prolong Q' Y C' Y C.
    assert (exists X, Midpoint X C C') by (apply l7_25 with Y;Cong).
    ex_and H13 X.
    assert (OFSC A Y Z Q Q Y P A) by (unfold OFSC;repeat split;Between;Cong).
    show_distinct A Y.
      intuition.
    assert (Cong Z Q P A) by (eauto using five_segment_with_def).
    assert (Cong_3 A P Y Q Z Y) by (unfold Cong_3;repeat split;Cong).
    assert (Per Q Z Y) by (eauto using l8_10).
    assert (Per Y Z Q) by eauto using l8_2.
    (* diversion *)
    show_distinct P Y.
      unfold Midpoint in *.
      spliter.
      treat_equalities.
      assert_cols.
      Col5.
    unfold Per in H19.
    ex_and H19 Q''.
    assert (Q' = Q'').
      eapply symmetric_point_uniqueness.
        apply H10.
      assumption.
    subst Q''.
    assert (hy:Bet Z Y X).
      apply (l7_22 Q C Q' C' Y Z X);Cong.
      assert (T:=outer_transitivity_between2 C P Y Q).
      assert_bets.
      apply between_symmetry.
      apply T;Between.
    show_distinct Q Y.
      intuition.
    assert (Per Y X C) by (unfold Per;exists C';split;Cong).
    assert_diffs.
    assert (Col P Y Q).
      unfold Col.
      left.
      assumption.
    assert(Col P Y C).
      unfold Midpoint in H3.
      spliter.
      unfold Col.
      right; right.
      assumption.
    assert (Col P Q C) by ColR.
    assert (Col Y Q C) by ColR.
    assert (Col A Y B) by (assert_cols;Col).
    assert (Col A Y Z) by (assert_cols;Col).
    assert (Col A B Z) by ColR.
    assert (Col Y B Z) by ColR.
    assert (Col Q Y P) by Col.
    assert(Q <> C).
      intro.
      subst Q.
      unfold Midpoint in *.
      spliter.
      apply H.
      assert (Bet B Y Z) by (apply outer_transitivity_between2 with A;auto).
      apply between_symmetry in H3.
      assert (Y = P).
        eapply between_equality.
          apply H3.
        assumption.
      treat_equalities.
      intuition.
    assert (Col Y B Z) by ColR. 
    show_distinct Y Q'. intuition.
    assert (Col Y Q' C') by (assert_cols;Col).
    assert (Q <> Q').
      intro.
      unfold OFSC, Cong_3 in *.
      spliter.
      treat_equalities.
      apply H.
      ColR.
    assert (C <> C').
      intro.
      subst C'.
      apply l7_3 in H14.
      subst X.
      assert (Col Z Q Q') by (assert_cols;ColR).
      assert (Y <> Z).
        intro.
        subst Z.
        unfold OFSC, Cong_3, Midpoint in *.
        spliter.
        treat_equalities.
        intuition.
      apply H.
      ColR.
    (* end of C<>C' *)
    assert(OFSC Q Y C Z Q' Y C' Z).
      unfold OFSC.
      repeat split;Between;Cong.
      unfold OFSC, Midpoint in *.
      spliter.
      eapply outer_transitivity_between with P;Between;Cong.
    assert (Cong C Z C' Z) by (eauto using five_segment_with_def).
    assert (Col Z Y X) by (assert_cols;Col).
    show_distinct Y Z. intuition.
    assert(C <> X).
      intro.
      subst X.
      unfold OFSC,Cong_3,Midpoint in *.
      spliter.
      treat_equalities.
      intuition.
    assert(X <> Y).
      intro.
      subst X.
      unfold OFSC,Cong_3,Midpoint in *.
      spliter.
      clean_duplicated_hyps.
      clean_trivial_hyps.
      show_distinct C' Y.
        intuition.
      assert (Col Y C' P ).
        eapply col_transitivity_1 with C.
          intuition.
          unfold Col.
          right;right.
          apply between_symmetry.
          assumption.
        apply col_permutation_1.
        assumption.
      show_distinct P Q.
        intuition.
      assert (Col Y P Q') by ColR.
      assert (Col Y Q Q') by ColR.
      assert (Col Q Y Z) by (assert_cols;ColR).
      assert (Col Y Z C) by (assert_bets;assert_cols;ColR).
      apply H.
      ColR.
    assert (Perp_at X Y Z C X).
      eapply l8_13_2;Col.
      exists Y.
      exists C.
      repeat split;Col.
    assert (Col A B X) by ColR.
    exists X.
    split.
      assumption.
    unfold Perp.
    exists X.
    unfold Perp_at.
    repeat split;Col.
    intros.
    unfold Perp_at in H52.
    spliter.
    apply H57;ColR.
Qed.
l8_21_aux
Proof.
    intros.
    assert (exists X : Tpoint, Col A B X /\ Perp A B C X).
      eapply l8_18_existence.
      assumption.
    ex_and H0 X.
    assert (Perp_at X A B C X).
      eapply l8_15_1; assert_diffs; auto.
    assert (Per A X C).
      unfold Perp_at in H2.
      spliter.
      apply H6.
        apply col_trivial_1.
      apply col_trivial_1.
    assert(HH:= H3).
    unfold Per in H3.
    ex_and H3 C'.
    double C A C''.
    assert (exists P, Midpoint P C' C'').
      eapply l7_25.
      unfold Midpoint in *.
      spliter.
      eapply cong_transitivity.
        apply cong_symmetry.
        apply H4.
      apply cong_left_commutativity.
      assumption; spliter.
    ex_elim H6 P.
    assert (Per X A P).
      eapply l8_20_1.
        apply HH.
        apply l7_2.
        apply H7.
        apply l7_2.
        apply H5.
      apply l7_2.
      assumption.
    assert (X <> C).
      intro.
      subst C.
      apply H.
      assumption.
    assert (A <> P).
      eapply l8_20_2.
        apply HH.
        apply l7_2.
        apply H7.
        apply l7_2.
        assumption.
        apply l7_2.
        assumption.
      assumption.
    assert (exists T, Bet P T C /\ Bet A T X).
      eapply l3_17.
        apply midpoint_bet.
        apply l7_2.
        apply H5.
        apply midpoint_bet.
        apply l7_2.
        apply H3.
      apply midpoint_bet.
      apply l7_2.
      apply H7.
    ex_and H10 T.
    induction (eq_dec_points A X).
      subst X.
      exists P.
      exists T.
      apply between_identity in H11.
      subst T.
      assert (C'= C'').
        eapply symmetric_point_uniqueness.
          apply H3.
        assumption.
      subst C''.
      apply l7_3 in H7.
      subst P.
      assert (Col A C C') by (assert_cols;ColR).
      repeat split;Col;Between.
      apply perp_col0 with C A;auto using perp_sym;assert_cols;Col.
    exists P.
    exists T.
    repeat split.
      unfold Perp.
      exists A.
      unfold Perp_at.
      repeat split.
        assert_diffs; auto.
        auto.
        apply col_trivial_1.
        apply col_trivial_3.
      unfold Perp_at in H2.
      spliter.
      intros.
      eapply per_col in H6.
        apply l8_2 in H6.
        eapply per_col in H6.
          eapply l8_2 in H6.
          apply H6.
          assumption.
        ColR.
        assumption.
      ColR.
      assert_cols;ColR.
    Between.
Qed.
l8_21
Proof.
    intros.
    induction(Col_dec A B C).
      assert (exists C', ~ Col A B C').
        eapply not_col_exists.
        assumption.
      ex_elim H1 C'.
      assert ( exists P : Tpoint, (exists T : Tpoint, Perp A B P A /\ Col A B T /\ Bet C' T P)).
        eapply l8_21_aux.
        assumption.
      ex_elim H1 P.
      ex_and H3 T.
      exists P.
      exists C.
      repeat split.
        assumption.
        assumption.
      apply between_trivial2.
    eapply l8_21_aux.
    assumption.
Qed.
perp_in_col
Proof.
    unfold Perp_at.
    intuition.
Qed.
perp_perp_in
Proof.
    intros.
    apply l8_15_1.
      unfold Perp in H.
      ex_and H X.
      unfold Perp_at in H0.
      intuition.
      apply col_trivial_3.
    assumption.
Qed.
perp_per_1
Proof.
    intros.
    assert (Perp_at A A B C A).
      apply perp_perp_in.
      assumption.
    unfold Perp_at in H0.
    spliter.
    apply H4.
    Col.
    Col.
Qed.
perp_per_2
Proof.
    intros.
    apply perp_right_comm in H.
    apply perp_per_1; assumption.
Qed.
perp_col
Proof.
    intros.
    apply perp_sym.
    apply perp_col0 with A B;finish.
Qed.
perp_col2
Proof.
    intros.
    assert(HH:=H).
    apply perp_distinct in HH.
    spliter.
    induction (eq_dec_points A C).
      subst A.
      apply perp_col with B;finish.
    assert(Perp A C X Y) by (eapply perp_col;eauto).
    eapply perp_col with A;finish.
      Perp.
    ColR.
Qed.
perp_not_eq_1
Proof.
    intros.
    unfold Perp in H.
    ex_elim H X.
    unfold Perp_at in H0.
    tauto.
Qed.
perp_not_eq_2
Proof.
    intros.
    apply perp_sym in H.
    eapply perp_not_eq_1.
    apply H.
Qed.
diff_per_diff
Proof.
    intros.
    intro.
    subst.
    assert (A = B).
      eapply l8_7.
        apply l8_2.
        apply H1.
      apply l8_2.
      assumption.
    intuition.
Qed.
per_not_colp
Proof.
    intros.
    intro.
    assert (Perp A B P A).
      apply perp_comm.
      apply per_perp;finish.
    assert (Perp A B B R).
      apply per_perp;finish.
    assert (Per B A R).
      eapply per_col.
        apply H0.
        assumption.
      ColR.
    apply l8_2 in H3.
    apply l8_2 in H7.
    assert (A = B).
      eapply l8_7.
        apply H7.
      assumption.
    contradiction.
Qed.
per_not_col
Proof.
    intros.
    intro.
    unfold Per in H1.
    ex_and H1 C'.
    assert (C = C' \/ Midpoint A C C').
      eapply l7_20.
        assert_cols;ColR.
        assumption.
    induction H4;treat_equalities; intuition.
Qed.
per_cong
Proof.
    intros.
    assert (Per P A B).
      apply l8_2.
      assumption.
    double B R Q.
    assert (B <> R).
      intro.
      subst R.
      apply cong_identity in H3.
      subst P.
      absurde.
    assert (Per A B Q).
      eapply per_col.
        apply H8.
        assumption.
      unfold Col.
      left.
      apply midpoint_bet.
      assumption.
    assert (Per P A X).
      eapply per_col.
        apply H.
        assumption.
      assumption.
    assert (B <> Q).
      intro.
      subst Q.
      apply l7_3 in H7.
      subst R.
      absurde.
    assert (Per R B X).
      eapply per_col.
        intro.
        apply H.
        apply sym_equal.
        apply H12.
        apply l8_2.
        assumption.
      apply col_permutation_4.
      assumption.
    assert (X <> A).
      intro.
      subst X.
      assert (~Col P A R).
        eapply per_not_colp.
          apply H.
          assumption.
          assumption.
          assumption.
        assumption.
      apply H13.
      unfold Col.
      left.
      assumption.
    double P A P'.
    prolong P' X R' X R.
    assert (exists M, Midpoint M R R').
      eapply l7_25.
      apply cong_symmetry.
      apply H16.
    ex_elim H17 M.
    assert (Per X M R).
      unfold Per.
      exists R'.
      split.
        assumption.
      apply cong_symmetry.
      assumption.
    assert (Cong X P X P').
      apply l8_2 in H10.
      unfold Per in H10.
      ex_and H10 P''.
      assert (P'=P'').
        eapply symmetric_point_uniqueness.
          apply H14.
        apply H10.
      subst P''.
      assumption.
    assert (X <> P').
      intro.
      subst P'.
      apply cong_identity in H19.
      subst X.
      apply l7_3 in H14.
      subst P.
      absurde.
    assert (P <> P').
      intro.
      subst P'.
      eapply l7_3 in H14.
      subst P.
      absurde.
    assert(~Col X P P').
      intro.
      assert(Col X P A).
        eapply col3.
          apply H21.
          apply col_permutation_1.
          assumption.
          apply col_trivial_3.
        unfold Col.
        right;left.
        apply between_symmetry.
        apply midpoint_bet.
        assumption.
      apply col_permutation_1 in H23.
      assert (P = A \/ X = A).
        eapply l8_9.
          assumption.
        assumption.
      induction H24.
        subst P.
        absurde.
      apply H13.
      assumption.
    assert (Bet A X M).
      eapply l7_22.
        5:apply H14.
        5:apply H18.
        assumption.
        assumption.
        assumption.
      apply cong_symmetry.
      assumption.
    assert (X <> R).
      intro.
      treat_equalities.
      apply l8_8 in H12.
      treat_equalities.
      unfold Midpoint in *.
      spliter.
      treat_equalities.
      intuition.
    assert (X <> R').
      intro.
      subst R'.
      apply cong_symmetry in H16.
      apply cong_identity in H16.
      apply H24.
      assumption.
    assert (M <> X).
      intro.
      subst M.
      apply H22.
      eapply col_transitivity_1.
        apply H24.
        unfold Col.
        right; right.
        assumption.
      eapply col_transitivity_1.
        apply H25.
        unfold Col.
        right;right.
        apply midpoint_bet.
        assumption.
      unfold Col.
      right; right.
      assumption.
    assert (M = B).
      eapply (l8_18_uniqueness A X R).
        intro.
        assert (Col A B R).
          eapply col_transitivity_1.
            intro.
            apply H13.
            apply sym_equal.
            apply H28.
            apply col_permutation_5.
            assumption.
          assumption.
        eapply per_not_col.
          apply H; apply H12.
          apply H8.
          assumption.
        assumption.
        unfold Col.
        left.
        assumption; eapply col_transitivity_1.
        apply per_perp in H17.
          apply perp_comm.
          eapply perp_col.
            assumption.
            apply H17.
          unfold Col.
          right;right.
          assumption.
          auto.
        intro.
        subst M.
        apply (symmetric_point_uniqueness R R R R')  in H18.
          subst R'.
          apply H22.
          eapply col_transitivity_1.
            apply H25.
            unfold Col.
            right;right.
            assumption.
          unfold Col.
          right; right.
          assumption.
        eapply l7_3_2.
        apply col_permutation_5.
        assumption.
      apply per_perp in H10.
        apply perp_comm.
        eapply perp_col.
          apply H13.
          apply perp_comm.
          eapply perp_col.
            intro.
            apply H13.
            apply sym_equal.
            apply H27.
            apply perp_right_comm.
            apply per_perp in H2.
              apply H2.
              assumption.
            assumption.
          assumption.
        apply col_trivial_2.
        auto.
      intro.
      apply H13.
      subst X.
      reflexivity.
    subst M.
    assert(OFSC P X R P' P' X R' P).
      unfold OFSC.
      repeat split.
        assumption.
        assumption.
        apply cong_commutativity.
        assumption.
        apply cong_symmetry.
        assumption.
        apply cong_pseudo_reflexivity.
      apply cong_symmetry.
      assumption.
    assert (Cong R P' R' P).
      eapply five_segment_with_def.
        apply H27.
      intro.
      subst X.
      apply H22.
      apply col_trivial_1.
    assert (IFSC P' A P R R' B R P).
      unfold IFSC.
      repeat split.
        apply between_symmetry.
        apply midpoint_bet.
        assumption.
        apply between_symmetry.
        apply midpoint_bet.
        assumption.
        eapply l2_11.
          apply between_symmetry.
          apply midpoint_bet.
          apply H14.
          apply between_symmetry.
          apply midpoint_bet.
          apply H18.
          eapply cong_transitivity.
            apply midpoint_cong.
            apply l7_2.
            apply H14.
          eapply cong_transitivity.
            apply H3.
          apply cong_commutativity.
          apply midpoint_cong.
          assumption.
        assumption.
        assumption.
        Cong.
      apply cong_pseudo_reflexivity.
    eapply cong_right_commutativity.
    eapply l4_2.
    eapply H29.
Qed.
perp_cong
Proof.
    intros.
    apply (per_cong A B P R X).
      assumption.
      assumption.
      apply perp_per_1.
      assumption.
      eapply perp_per_1.
        auto.
      apply perp_left_comm;auto.
      assumption.
      assumption.
    assumption.
Qed.
midpoint_existence_aux
Proof.
    intros.
    unfold Le in H4.
    ex_and H4 R.
    assert (exists X, Bet T X B /\ Bet R X P).
      eapply inner_pasch.
        apply between_symmetry.
        apply H3.
      auto.
    ex_and H6 X.
    assert (Col A B X).
      induction (eq_dec_points T B).
        subst T.
        apply between_identity in H6.
        subst X.
        Col.
     assert_cols;ColR.
     induction(Col_dec A B P).
      assert (B=A \/ P=A).
        eapply l8_9.
          apply perp_per_1.
          assumption.
        apply col_permutation_4.
        assumption.
      induction H10.
        exists A.
        subst B.
        eapply l7_3_2.
      treat_equalities.
      apply perp_distinct in H1.
      spliter.
      absurde.
    assert (B <> R).
      intro.
      subst R.
      treat_equalities.
      apply H9.
      apply col_trivial_3.
    assert (~Col A B Q).
      intro.
      assert (A=B \/ Q=B).
        eapply l8_9.
          apply perp_per_2.
            auto.
          apply perp_comm.
          assumption.
        assumption.
      induction H12.
        apply H.
        assumption.
      subst Q.
      treat_equalities.
      absurde.
    assert (~Col A B R).
      intro.
      assert (Col B A Q).
        assert_cols;ColR.
      Col.
    show_distinct P R.
      intuition.
    induction (eq_dec_points A P).
      subst P.
      apply perp_distinct in H1.
      spliter.
      absurde.
    assert (Perp A B R B).
      eapply perp_col.
        assumption.
        apply perp_sym.
        apply perp_left_comm.
        eapply perp_col.
          assumption.
          apply perp_left_comm.
          apply perp_sym.
          apply H0.
        assert_cols;Col.
      Col.
    apply between_symmetry in H7.
    assert (Cong A R P B).
      apply (perp_cong A B P R X); assumption.
    assert (Midpoint X A B /\ Midpoint X P R).
      apply (l7_21 A P B R X);finish.
    spliter. exists X.
    assumption.
Qed.
midpoint_existence
Proof.
    intros.
    induction (eq_dec_points A B).
      subst B.
      exists A.
      apply l7_3_2.
    cut(exists Q, Perp A B B Q).
      intro.
      ex_elim H0 Q.
      cut(exists P, exists T, Perp A B P A /\ Col A B T /\ Bet Q T P).
        intros.
        ex_elim H0 P.
        ex_and H2 T.
        assert (Le A P B Q \/ Le B Q A P) by (apply le_cases).
        induction H4.
          apply midpoint_existence_aux with P Q T;finish;Perp.
        assert (exists X : Tpoint, Midpoint X B A)
          by (apply (midpoint_existence_aux B A Q P T);finish;Perp;Between).
        ex_elim H5 X.
        exists X.
        finish.
       apply l8_21;assumption.
    assert (exists P : Tpoint, (exists T : Tpoint, Perp B A P B /\ Col B A T /\ Bet A T P)) by (apply (l8_21 B A);auto).
    ex_elim H0 P.
    ex_elim H1 T.
    spliter.
    exists P.
    Perp.
Qed.
perp_in_id
Proof.
    intros.
    assert (Perp A B C A).
      unfold Perp.
      exists X.
      assumption.
    assert (A <> B /\ C <> A).
      apply perp_distinct.
      assumption.
    spliter.
    assert (HH:=H0).
    apply perp_perp_in in HH.
    assert (l8_16_1:=l8_16_1 A B C B A).
    assert (~Col A B C /\ Per C A B).
      apply l8_16_1;Col.
    spliter.
    unfold Perp_at in H.
    spliter.
    eapply l8_18_uniqueness with A B C;finish.
      apply perp_sym.
      eapply perp_col with A;finish.
        intro.
        subst X.
        Col.
Qed.
l8_22
Proof.
    intros.
    assert (Cong A R P B).
      apply (per_cong A B P R X); assumption.
    split.
      assumption.
    assert (~ Col B A P).
      eapply per_not_col.
        auto.
        assumption.
      assumption.
    assert_all_diffs_by_contradiction.
    apply l7_21;finish.
Qed.
l8_22_bis
Proof.
    intros.
    apply l8_22;finish.
       apply perp_per_1;finish.
       apply perp_per_1;finish;Perp.
Qed.
perp_in_perp
Proof.
    intros.
    unfold Perp.
    exists X.
    assumption.
Qed.
perp_proj
Proof.
    intros.
    unfold Perp in H.
    ex_and H X.
    exists X.
    split.
      unfold Perp_at in H1.
      spliter.
      apply col_permutation_1.
      assumption.
    eapply perp_col.
      intro.
      subst X.
      unfold Perp_at in H1.
      spliter.
      apply H0.
      assumption.
      apply perp_in_perp in H1.
      apply H1.
    unfold Perp_at in H1.
    spliter.
    apply col_permutation_1.
    assumption.
Qed.
l8_24
Proof.
    intros.
    unfold Le in H4.
    assert (exists X, Bet T X B /\ Bet R X P).
      eapply inner_pasch.
        apply H2.
      assumption.
    ex_and H5 X.
    assert (Col A B X).
      induction (eq_dec_points T B).
        subst T.
        apply between_identity in H5.
        subst X.
        apply col_trivial_2.
      assert (Col T X B).
        unfold Col.
        left.
        assumption.
      apply col_permutation_4.
      eapply col_transitivity_1.
        intro.
        apply H7.
        apply sym_equal.
        apply H9.
        apply col_permutation_1.
        assumption.
      apply col_permutation_2.
      assumption.
    assert (A <> B).
      apply perp_distinct in H.
      spliter.
      assumption.
    assert (A <> P).
      apply perp_distinct in H.
      spliter.
      auto.
    induction(Col_dec A B P).
      assert (B=A \/ P=A).
        eapply l8_9.
          apply perp_per_1.
          apply perp_sym.
          assumption.
        apply col_permutation_4.
        assumption.
      induction H11.
        exists A.
        subst B.
        absurde.
      subst P.
      absurde.
    assert (B <> R).
      intro.
      subst R.
      apply cong_identity in H4.
      subst P.
      absurde.
    assert (Q <> B).
      apply perp_distinct in H0.
      spliter.
      assumption.
    assert (~Col A B Q).
      intro.
      assert (A=B \/ Q=B).
        eapply l8_9.
          apply perp_per_2.
            auto.
          apply perp_comm.
          apply perp_sym.
          assumption.
        assumption.
      induction H14.
        contradiction.
      subst Q.
      absurde.
    assert (~Col A B R).
      intro.
      assert (Col B A Q).
        eapply col_transitivity_1.
          apply H11.
          apply col_permutation_1.
          assumption.
        unfold Col.
        left.
        assumption.
      apply H13.
      apply col_permutation_4.
      assumption.
    assert (P <> R).
      intro.
      subst R.
      apply between_identity in H6.
      subst X.
      contradiction.
    induction (eq_dec_points A P).
      subst P.
      apply perp_distinct in H.
      spliter.
      absurde.
    assert (Perp A B R B).
      eapply perp_col.
        assumption.
        apply perp_sym.
        apply perp_left_comm.
        eapply perp_col.
          assumption.
          apply perp_left_comm.
          apply H0.
        unfold Col.
        right; left.
        apply between_symmetry.
        assumption.
      apply col_trivial_2.
    assert (Cong A R P B).
      apply (perp_cong A B P R X).
        assumption.
        assumption.
        apply perp_sym.
        assumption.
        assumption.
        assumption.
        assumption.
      apply between_symmetry.
      assumption.
    intros.
    assert (Midpoint X A B /\ Midpoint X P R).
      apply (l7_21 A P B R X).
        intro.
        apply H10.
        apply col_permutation_5.
        assumption.
        assumption.
        assumption.
        apply cong_right_commutativity.
        apply cong_symmetry.
        assumption.
        apply col_permutation_5.
        assumption.
      unfold Col.
      left.
      apply between_symmetry.
      assumption.
    exists X.
    assumption.
Qed.
perp_not_col2
Proof.
    intros.
    induction (Col_dec A B C).
      right.
      assert(Perp_at C A B C D).
        apply l8_14_2_1b_bis; Col.
      intro.
      assert(Perp_at D A B C D).
        apply l8_14_2_1b_bis; Col.
      assert(C = D).
        eapply l8_14_3.
          apply H1.
        assumption.
      apply perp_not_eq_2 in H.
      contradiction.
    left.
    assumption.
Qed.
perp_not_col
Proof.
    intros.
    assert (Perp_at A A B P A).
      apply perp_perp_in.
      assumption.
    assert (Per P A B).
      apply perp_in_per.
      apply perp_in_sym.
      assumption.
    apply perp_in_left_comm in H0.
    assert (~ Col B A P  -> ~ Col A B P).
      intro.
      intro.
      apply H2.
      apply col_permutation_4.
      assumption.
    apply H2.
    apply perp_distinct in H.
    spliter.
    apply per_not_col.
      auto.
      auto.
    apply perp_in_per.
    apply perp_in_right_comm.
    assumption.
Qed.
perp_in_col_perp_in
Proof.
    intros.
    unfold Perp_at in *.
    spliter.
    repeat split; auto.
      ColR.
    intros.
    apply H5.
      assumption.
    ColR.
Qed.
perp_col2_bis
Proof.
intros A B C D P Q HPerp HCol1 HCol2 HCD.
apply perp_sym.
apply perp_col2 with P Q; Perp; ColR.
Qed.
perp_in_perp_bis
Proof.
    intros.
    induction (eq_dec_points X A).
      subst X.
      left.
      unfold Perp.
      exists A.
      assumption.
    right.
    unfold Perp.
    exists X.
    unfold Perp_at in *.
    spliter.
    repeat split.
      intro.
      apply H0.
      subst X.
      reflexivity.
      assumption.
      apply col_trivial_3.
      assumption.
    intros.
    apply H4.
      apply col_permutation_2.
      eapply col_transitivity_1.
        intro.
        apply H0.
        apply sym_equal.
        apply H7.
        Col.
      Col.
    assumption.
Qed.
col_per_perp
Proof.
    intros.
    apply per_perp_in in H4.
      apply perp_in_perp_bis in H4.
      induction H4.
        apply perp_distinct in H4.
        spliter.
        absurde.
      eapply (perp_col _ B).
        auto.
        apply perp_sym.
        apply perp_right_comm.
        assumption.
      apply col_permutation_4.
      assumption.
      assumption.
    assumption.
Qed.
per_cong_mid
Proof.
    intros.
    induction (eq_dec_points H B).
      subst H.
      unfold Midpoint.
      split.
        assumption.
      apply cong_right_commutativity.
      assumption.
    assert(Per C B H).
      apply l8_2.
      assumption.
    assert (Per H B A).
      eapply per_col.
        apply H0.
        assumption.
      unfold Col.
      right; right.
      assumption.
    assert (Per A B H).
      apply l8_2.
      assumption.
    unfold Per in *.
    ex_and H3 C'.
    ex_and H5 H'.
    ex_and H6 A'.
    ex_and H7 H''.
    assert (H' = H'').
      eapply construction_uniqueness.
        2: apply  midpoint_bet.
        2:apply H5.
        assumption.
        apply cong_commutativity.
        apply midpoint_cong.
        apply l7_2.
        apply H5.
        apply midpoint_bet.
        assumption.
      apply cong_commutativity.
      apply midpoint_cong.
      apply l7_2.
      assumption.
    subst H''.
    assert(IFSC H B H' A H B H' C).
      repeat split.
        apply midpoint_bet.
        assumption.
        apply midpoint_bet.
        assumption.
        apply cong_reflexivity.
        apply cong_reflexivity.
        apply cong_commutativity.
        assumption.
      apply cong_commutativity.
      eapply cong_transitivity.
        apply cong_symmetry.
        apply H11.
      eapply cong_transitivity.
        apply H2.
      assumption.
    eapply l4_2 in H12.
    unfold Midpoint.
    split.
      assumption.
    apply cong_left_commutativity.
    assumption.
Qed.
per_double_cong
Proof.
    intros.
    unfold Per in H.
    ex_and H C''.
    assert (C' = C'').
      eapply l7_9.
        apply l7_2.
        apply H0.
      apply l7_2.
      assumption.
    subst C''.
    assumption.
Qed.
cong_perp_or_mid
Proof.
intros.
induction(Col_dec A B X).
left.
assert(A = B \/ Midpoint X A B).
apply l7_20; Col.
Cong.
induction H3.
contradiction.
apply (l7_17 A B); auto.
right.
split; auto.
assert(Col M A B).
unfold Midpoint in *.
spliter; Col.

assert_diffs.
assert(Per X M A)
 by (unfold Per;exists B;split; Cong).
apply per_perp_in in H4.
apply perp_in_right_comm in H4.
apply(perp_in_col_perp_in X M A M B M); Col.

intro;treat_equalities.
apply H2; Col.
auto.
Qed.
col_per2_cases
Proof.
intros.
induction(eq_dec_points B B').
left; auto.
right.
intro.
assert(Col C B B').
ColR.
assert(Per A B' B).
apply(per_col A B' C B H0 H4); Col.
assert(Per A B B').
apply(per_col A B C B' H H3); Col.
apply H5.
apply (l8_7 A); auto.
Qed.
ts_distincts
Proof.
  intros A B P Q HTS.
  destruct HTS as [HNCol1 [HNCol2 [T [HCol HBet]]]].
  assert_diffs.
  repeat split; auto.
  intro; treat_equalities; auto.
Qed.
l9_2
Proof.
    unfold TS.
    intros.
    spliter.
    repeat split; try Col.
    destruct H1 as [T [HCol1 HCol2]].
    exists T; Col; Between.
Qed.
invert_two_sides
Proof.
    unfold TS.
    intros.
    spliter.
    repeat split...
    ex_and H1 T.
    exists T;split...
Qed.
l9_3
Proof.
    intros.
    unfold TS in *.
    assert (~ Col A P Q).
      spliter.
      assumption.
    spliter.
    clear H.
    assert (P <> Q).
      intro.
      subst Q.
      Col.
    ex_and H6 T.
    show_distinct A C.
      intuition.
    assert (T = M).
      assert_bets.
      assert_cols.
      eapply l6_21 with P Q A C...
    subst T.
    repeat split...
      induction(eq_dec_points C M).
        subst M.
        intuition.
      intro.
      clear H0.
      assert (B <> R).
        intro.
        subst B.
        unfold Out in H3.
        spliter.
        absurde.
      assert (Col P R B) by ColR.
      assert (Col P R A).
        induction (eq_dec_points P B).
          subst B.
          assert_cols...
        apply col_permutation_2.
        eapply col_transitivity_2.
          apply H0.
          assert_cols...
        Col.
      induction (eq_dec_points P R).
        subst R.
        apply H4.
        apply col_permutation_2.
        eapply (col_transitivity_1 _ B).
          assert_diffs;intuition.
          apply col_permutation_4.
          assumption.
        assert_cols...
      assert (Col P B A ).
        eapply col_transitivity_1.
          apply H13.
          assumption.
        assumption.
      induction (eq_dec_points P B).
        subst B.
        apply H4.
        apply col_permutation_2.
        eapply (col_transitivity_1 _ R).
          apply H0.
          apply col_permutation_4.
          assumption.
        unfold Out in H3.
        spliter.
        unfold Col.
        induction H16.
          right; left.
          assumption.
        right;right.
        Between.
      apply H4.
      apply col_permutation_2.
      eapply col_transitivity_1.
        apply H15.
        Col.
      assumption.
    induction H3.
    spliter.
    induction H10.
      double B M B'.
      double R M R'.
      assert (Bet B' C R').
        eapply l7_15.
          apply H11.
          apply H1.
          apply H12.
        Between.
      assert (exists X, Bet M X R' /\ Bet C X B).
        eapply inner_pasch.
          (* assert_bets.
          Between.
          *)
          apply midpoint_bet.
          apply H11.
        apply between_symmetry.
        assumption.
      ex_and H14 X.
      exists X.
      split.
        assert (Col P M R ).
          eapply col_transitivity_1.
            apply H.
            Col.
          Col.
        assert (Col Q M R).
          eapply (col_transitivity_1 _ P).
            auto.
            Col.
          Col.
        induction (eq_dec_points M X).
          subst X.
          assumption.
        show_distinct M R'.
          intuition.
        assert (M <> R).
          intro.
          subst R.
          eapply (symmetric_point_uniqueness) in H12.
            apply H19.
            apply H12.
          apply l7_3_2.
        apply col_permutation_2.
        ColR.
      Between.
    assert (exists X, Bet B X C /\ Bet M X R).
      eapply inner_pasch.
        apply H10.
      Between.
    ex_and H11 X.
    exists X.
    induction (eq_dec_points M R).
      subst R.
      apply between_identity in H12.
      subst X.
      split; assumption.
    induction (eq_dec_points R X).
      subst X.
      split; assumption.
    split.
      induction (eq_dec_points X M).
        subst X.
        assumption.
      assert (Col P M R ).
        eapply col_transitivity_1.
          apply H.
          Col.
        Col.
      assert (Col X P Q).
        apply col_permutation_2.
        ColR.
      assumption.
    assumption.
Qed.
sym_sym
Proof.
    unfold ReflectP.
    intros.
    apply l7_2.
    assumption.
Qed.
distinct
Proof.
    intros.
    assert (~ (R = P /\ R = Q) -> (R <> P \/ R <> Q)).
      intro.
      induction (eq_dec_points P R).
        subst R.
        right.
        intro.
        apply H0.
        split.
          reflexivity.
        assumption.
      left.
      intro.
      apply H1.
      subst R.
      reflexivity.
    apply H0.
    intro.
    spliter.
    subst P.
    subst Q.
    apply H.
    reflexivity.
Qed.
diff_col_ex
Proof.
    intros.
    assert (exists C, Bet A B C /\ B <> C).
      apply point_construction_different.
    ex_and H C.
    exists C.
    split.
      intro.
      induction (eq_dec_points A B).
        subst B.
        subst C.
        intuition.
      subst C.
      Between.
    assert_cols.
    auto.
Qed.
diff_bet_ex3
Proof.
    intros.
    induction (eq_dec_points A B).
      induction (eq_dec_points B C).
        assert (exists D, Bet B C D /\ C <> D).
          apply point_construction_different.
        ex_and H2 D.
        exists D.
        repeat split.
          subst C.
          subst A.
          assumption.
          subst A.
          subst C.
          assumption.
          assumption.
        unfold Col.
        left.
        subst A.
        subst C.
        assumption.
      assert (exists D, Bet B C D /\ C <> D).
        apply point_construction_different.
      ex_and H2 D.
      exists D.
      repeat split.
        intro.
        subst D.
        apply between_symmetry in H.
        apply H1.
        eapply between_equality.
          apply H2.
        apply H.
        intro.
        subst D.
        subst A.
        apply between_identity in H2.
        apply H3.
        subst B.
        reflexivity.
        assumption.
      unfold Col.
      left.
      eapply outer_transitivity_between.
        apply H.
        apply H2.
      assumption.
    induction (eq_dec_points B C).
      subst C.
      cut(exists D : Tpoint, A <> D /\ B <> D /\ Col A B D).
        intro.
        ex_and H1 D.
        exists D.
        repeat split.
          assumption.
          assumption.
          assumption.
        assumption.
      apply diff_col_ex.
    assert (exists D, Bet B C D /\ C <> D).
      apply point_construction_different.
    ex_and H2 D.
    exists D.
    repeat split.
      intro.
      subst D.
      assert (B = C).
        eapply between_equality.
          apply H2.
        apply between_symmetry.
        assumption.
      apply H1.
      assumption.
      intro.
      subst D.
      apply between_identity in H2.
      subst C.
      apply H1.
      reflexivity.
      assumption.
    unfold Col.
    left.
    eapply outer_transitivity_between.
      apply H.
      assumption.
    assumption.
Qed.
diff_col_ex3
Proof.
    intros.
    assert(cas1 := diff_bet_ex3 A B C).
    assert(cas2 := diff_bet_ex3 B C A).
    assert(cas3 := diff_bet_ex3 C A B).
    unfold Col in H.
    induction H.
      apply (diff_bet_ex3 A B C).
      assumption.
    induction H.
      assert (HH:=H).
      induction (eq_dec_points B C).
        subst C.
        assert (exists C, A <> C /\ B <> C /\ Col A B C).
          apply (diff_col_ex).
        ex_and H0 D.
        exists D.
        repeat split; assumption.
      apply cas2 in HH.
      ex_and HH D.
      exists D.
      repeat split; try assumption.
      apply col_permutation_2.
      eapply col_transitivity_1.
        apply H0.
        assumption.
      unfold Col.
      left.
      assumption.
    induction (eq_dec_points A C).
      subst C.
      assert (exists C, A <> C /\ B <> C /\ Col A B C).
        apply (diff_col_ex).
      ex_and H0 D.
      exists D.
      repeat split; assumption.
    assert (HH:=H).
    apply cas3 in HH.
    ex_and HH D.
    exists D.
    repeat split; try assumption.
    apply col_permutation_5.
    eapply col_transitivity_1.
      apply H0.
      apply col_permutation_4.
      assumption.
    unfold Col.
    right;right.
    apply between_symmetry.
    assumption.
Qed.
mid_preserves_col
Proof.
    intros.
    induction H.
      assert (Bet A' B' C').
        eapply l7_15 with A B C M;auto.
      assert_cols;Col.
    induction H.
      assert (Bet B' C' A').
        eapply l7_15 with B C A M;auto.
      assert_cols;Col.
    assert (Bet C' A' B').
      eapply l7_15 with C A B M;auto.
    assert_cols;Col.
Qed.
per_mid_per
Proof.
    intros.
    assert (Cong A X B Y).
      eapply l7_13.
        apply l7_2.
        apply H1.
      apply l7_2.
      assumption.
    split.
      assumption.
    unfold Per in H0.
    ex_and H0 B'.
    double A B A'.
    assert (Cong B X A Y).
      eapply l7_13.
        apply H1.
      apply l7_2.
      assumption.
    assert (OFSC B A B' X A B A' Y).
      unfold OFSC.
      repeat split.
        apply midpoint_bet.
        assumption.
        apply midpoint_bet.
        assumption.
        apply cong_pseudo_reflexivity.
        unfold Midpoint in *.
        spliter.
        eapply cong_transitivity.
          apply cong_symmetry.
          apply H8.
        apply cong_left_commutativity.
        assumption.
        assumption.
      assumption.
    unfold Per.
    exists A'.
    split.
      assumption.
    assert (Cong B' X A' Y).
      eapply five_segment_with_def.
        apply H7.
      intro.
      apply H.
      subst B.
      reflexivity.
    eapply cong_transitivity.
      apply cong_commutativity.
      apply cong_symmetry.
      apply H6.
    eapply cong_transitivity.
      apply H4.
    apply cong_commutativity.
    assumption.
Qed.
sym_preserve_diff
Proof.
    intros.
    intro.
    subst B'.
    assert (A = B).
      eapply l7_9.
        apply H0.
      assumption.
    contradiction.
Qed.
l9_4_1_aux
Proof.
    intros.
    induction (eq_dec_points R S).
      subst S.
      apply l7_3 in H5.
      subst R.
      unfold TS in H0.
      assert (~ Col A P Q).
        spliter.
        assumption.
      spliter.
      clear H0.
      assert (P <> Q).
        intro.
        subst Q.
        Col.
      ex_and H8 T.
      induction (eq_dec_points M T).
        subst T.
        split.
          intro.
          unfold Out in *.
          spliter.
          repeat split.
            intro.
            subst C.
            apply perp_distinct in H4.
            spliter.
            absurde.
            intro.
            subst C'.
            apply l7_2 in H6.
            eapply (symmetric_point_uniqueness _ _ M) in H6.
              apply H10.
              apply sym_equal.
              apply H6.
            apply l7_3_2.
          induction H12.
            assert (Bet U M C).
              eapply between_exchange3.
                apply between_symmetry.
                apply H12.
              assumption.
            unfold Midpoint in H13.
            spliter.
            eapply l5_2.
              apply H10.
              assumption.
            apply midpoint_bet.
            assumption.
          assert (Bet U M C).
            eapply outer_transitivity_between2.
              apply between_symmetry.
              apply H12.
              assumption.
            assumption.
          eapply l5_2.
            apply H10.
            assumption.
          unfold Midpoint in H6.
          spliter.
          assumption.
        intro.
        unfold Out in *.
        spliter.
        repeat split.
          intro.
          subst U.
          eapply is_midpoint_id in H6.
          subst C'.
          apply H11.
          reflexivity.
          intro.
          subst A.
          apply perp_distinct in H2.
          spliter.
          apply H13.
          reflexivity.
        unfold Midpoint in H6.
        spliter.
        assert (Bet A M C').
          induction H12.
            eapply outer_transitivity_between.
              apply H9.
              assumption.
            intro.
            apply H10.
            subst C.
            reflexivity.
          eapply between_inner_transitivity.
            apply H9.
          assumption.
        eapply l5_2.
          apply H11.
          apply between_symmetry.
          assumption.
        apply between_symmetry.
        assumption.
      assert (Perp M T A M) by (eapply perp_col2  with P Q;Col).
      apply perp_perp_in in H11.
      apply perp_in_comm in H11.
      eapply perp_in_per in H11.
      assert (Perp M T C M) by (eapply perp_col2  with P Q;Col).
      apply perp_perp_in in H12.
      apply perp_in_comm in H12.
      eapply perp_in_per in H12.
      assert (M = T).
        apply (l8_6 C M T A).
          3:Between.
          apply l8_2;auto.
        apply l8_2;auto.
      subst T.
      split.
        intro.
        unfold Out in *.
        spliter.
        repeat split.
          intro.
          subst C.
          apply perp_distinct in H4.
          spliter.
          absurde.
          intro.
          subst C'.
          intuition.
        intuition.
      intuition.
    (*   R <> S  *)
    unfold Le in H.
    ex_and H D.
    assert (C <> S).
      intro.
      subst S.
      apply perp_distinct in H4.
      spliter.
      absurde.
    assert (R <> D).
      intro.
      subst D.
      apply cong_identity in H8.
      apply H9.
      subst S.
      reflexivity.
    assert (Perp R S A R).
      eapply perp_col2.
        apply H2.
        assumption.
        apply col_permutation_1.
        assumption.
        apply col_permutation_1.
        assumption.
    assert(exists M, Midpoint M S R /\ Midpoint M C D).
      unfold TS in H0.
      assert (~ Col A P Q).
        spliter.
        assumption.
      spliter.
      clear H0.
      assert (P <> Q).
        intro.
        subst Q.
        Col.
      ex_and H14 T.
      eapply (l8_24 S R C A D T).
        apply perp_sym.
        apply perp_left_comm.
        eapply perp_col2.
          apply H4.
          assumption.
          apply col_permutation_1.
          assumption.
          apply col_permutation_1.
          assumption.
        apply perp_right_comm.
        apply perp_sym.
        assumption.
        eapply col3.
          apply H0.
          apply col_permutation_1.
          assumption.
          apply col_permutation_1.
          assumption.
        apply col_permutation_1.
        assumption.
        apply between_symmetry.
        assumption.
        assumption.
      assumption.
    ex_and H12 M'.
    apply l7_2 in H12.
    assert (M = M').
      eapply l7_17.
        apply H5.
      apply H12.
    subst M'.
    split.
      intro.
      unfold Out in H14.
      spliter.
      unfold Out.
      repeat split.
        assumption.
        eapply sym_preserve_diff.
          2:apply H6.
          apply H14.
        assumption.
      induction H16.
        assert(Bet R U D \/ Bet R D U).
          eapply l5_3.
            apply H16.
          assumption.
        induction H17.
          right.
          eapply l7_15.
            apply H5.
            apply H6.
            apply l7_2.
            apply H13.
          assumption.
        left.
        eapply l7_15.
          apply H5.
          apply l7_2.
          apply H13.
          apply H6.
        assumption.
      left.
      eapply l7_15.
        apply H5.
        apply l7_2.
        apply H13.
        apply H6.
      eapply between_exchange4.
        apply H.
      apply H16.
    unfold Out.
    intros.
    spliter.
    repeat split.
      eapply sym_preserve_diff.
        apply H15.
        apply l7_2.
        apply H6.
      apply l7_2.
      assumption.
      intro.
      subst R.
      apply perp_distinct in H11.
      spliter.
      absurde.
    induction H16.
      eapply l5_1.
        apply H10.
        eapply l7_15.
          apply l7_2.
          apply H12.
          apply H13.
          apply l7_2.
          apply H6.
        assumption.
      assumption.
    left.
    eapply between_exchange4.
      eapply l7_15.
        apply l7_2.
        apply H12.
        apply l7_2.
        apply H6.
        apply H13.
      assumption.
    assumption.
Qed.
per_col_eq
Proof.
    intros.
    unfold Per in H.
    ex_and H C'.
    assert_bets.
    assert_cols.
    assert (Col A C C') by ColR.
    assert (C = C' \/ Midpoint A C C') by (eapply l7_20;Col).
    induction H7.
      treat_equalities.
      intuition.
    eapply l7_17;eauto.
Qed.
l9_4_1
Proof.
    intros.
    assert (Le S C R A \/ Le R A S C).
      apply le_cases.
    induction H6.
      apply (l9_4_1_aux P Q A C R S M); assumption.
    assert((Out R A U <-> Out S C' C) -> (Out R U A <-> Out S C C')).
      intro.
      induction H7.
      split.
        intro.
        eapply l6_6.
        apply H7.
        apply l6_6.
        assumption.
      intro.
      apply l6_6.
      apply H8.
      apply l6_6.
      assumption.
    apply H7.
    assert((Out S C' C <-> Out R A U) -> (Out R A U <-> Out S C' C)).
      intro.
      induction H8.
      split.
        intro.
        apply H9.
        assumption.
      intro.
      apply H8.
      assumption.
    apply H8.
    eapply (l9_4_1_aux).
      assumption.
      apply l9_2.
      apply H.
      assumption.
      assumption.
      assumption.
      assumption.
      apply l7_2.
      apply H4.
    apply l7_2.
    assumption.
Qed.
mid_two_sides
Proof.
    intros A B M X Y HM1 HNCol HM2.
    repeat split; Col.
      assert_diffs.
      assert (X<>Y) by (intro; treat_equalities; assert_cols; Col).
      intro Col; apply HNCol; ColR.
    exists M; split; Col; Between.
Qed.
col_preserves_two_sides
Proof.
    intros A B C D X Y.
    assert (H := A).
    intros.
    unfold TS in *.
    assert (~ Col X A B).
      spliter.
      assumption.
    clear H.
    assert (A <> B).
      intro.
      subst B.
      Col.
    spliter.
    repeat split.
      intro.
      apply H4.
      apply col_permutation_1.
      eapply col3.
        apply H0.
        apply col_permutation_1.
        eapply col_transitivity_1.
          intro.
          apply H.
          apply sym_equal.
          apply H8.
          apply col_permutation_4.
          assumption.
        apply col_permutation_4.
        assumption.
        apply col_permutation_1.
        assumption.
      apply col_permutation_1.
      eapply col_transitivity_1.
        apply H.
        assumption.
      assumption.
      intro.
      apply H5.
      apply col_permutation_1.
      eapply col3.
        apply H0.
        apply col_permutation_1.
        eapply col_transitivity_1.
          intro.
          apply H.
          apply sym_equal.
          apply H8.
          apply col_permutation_4.
          assumption.
        apply col_permutation_4.
        assumption.
        apply col_permutation_1.
        assumption.
      apply col_permutation_1.
      eapply col_transitivity_1.
        apply H.
        assumption.
      assumption.
    ex_and H6 T.
    exists T.
    split.
      eapply col3.
        apply H.
        apply col_permutation_1.
        assumption.
        assumption.
      assumption.
    assumption.
Qed.
out_out_two_sides
Proof.
    intros.
    unfold TS in *.
    assert (~ Col X A B).
      spliter.
      assumption.
    spliter.
    repeat split.
      intro.
      apply H5.
      unfold Out in H3.
      spliter.
      induction H10.
      ColR.
      ColR.
      intro.
      apply H6.
      unfold Out in H4.
      spliter.
      induction H10.
      ColR.
      ColR.
    ex_and H7 T.
    assert (I = T).
     {
      apply l6_21 with A B X Y; Col.
      intro; treat_equalities; Col.
      }
    subst I.
    exists T.
    split.
      assumption.
    unfold Out in *.
    spliter.
    induction H12; induction H10;
    eauto using outer_transitivity_between2, between_symmetry, between_inner_transitivity, between_exchange3, outer_transitivity_between.
Qed.
l9_4_2_aux
Proof.
    intros.
    induction (eq_dec_points R S).
      subst S.
      assert (TT:= H0).
      unfold TS in H0.
      assert (~ Col A P Q).
        spliter.
        assumption.
      spliter.
      clear H0.
      assert (P <> Q).
        intro.
        subst Q.
        Col.
      ex_and H9 T.
      induction (eq_dec_points R T).
        subst T.
        clear H9 H3.
        apply (out_out_two_sides P Q A C U V R); auto using l6_6, bet_col with col.
      assert (Perp R T A R) by (eapply perp_col2  with P Q;Col).
      apply perp_perp_in in H12.
      apply perp_in_comm in H12.
      eapply perp_in_per in H12.
      assert (Perp R T C R) by (eapply perp_col2  with P Q;Col).
      apply perp_perp_in in H13.
      apply perp_in_comm in H13.
      eapply perp_in_per in H13.
      assert (R = T).
        apply (l8_6 C R T A).
          3:Between.
          apply l8_2;auto.
        apply l8_2;auto.
      subst.
      intuition.
    (********* R <> S ***************)
    assert(P <> Q).
      apply perp_distinct in H4.
      spliter.
      assumption.
    assert (TS R S A C).
      eapply (col_preserves_two_sides P Q).
        apply H7.
        apply col_permutation_1.
        assumption.
        apply col_permutation_1.
        assumption.
      assumption.
    eapply (col_preserves_two_sides R S).
      assumption.
      eapply col_permutation_1.
      eapply col_transitivity_1.
        apply H8.
        apply col_permutation_1.
        assumption.
      apply col_permutation_1.
      assumption.
      apply col_permutation_1.
      eapply (col_transitivity_1 _ P).
        auto.
        apply col_permutation_3.
        assumption.
      apply col_permutation_3.
      assumption.
    assert (Perp R S A R).
      eapply perp_col2.
        apply H2.
        assumption.
        apply col_permutation_1.
        assumption.
        apply col_permutation_1.
        assumption.
    assert (Perp R S C S).
      eapply perp_col2.
        apply H4.
        assumption.
        apply col_permutation_1.
        assumption.
        apply col_permutation_1.
        assumption.
    assert (HH9:=H9).
    unfold TS in HH9.
    assert (~ Col A R S).
      spliter.
      assumption.
    spliter.
    ex_and H15 T.
    unfold Le in H.
    ex_and H C'.
    assert (exists M, Midpoint M S R /\ Midpoint M C C').
      eapply (l8_24 S R C A C' T).
        apply perp_sym.
        apply perp_left_comm.
        assumption.
        apply perp_sym.
        apply perp_left_comm.
        assumption.
        apply col_permutation_3.
        assumption.
        apply between_symmetry.
        assumption.
        assumption.
      assumption.
    ex_and H18 M.
    double U M U'.
    assert (R <> U).
      intro.
      subst U.
      unfold Out in H5.
      spliter.
      absurde.
    assert (TS R S U U').
      eapply mid_two_sides.
        apply l7_2.
        apply H18.
        intro.
        apply H13.
        eapply col_permutation_2.
        eapply col_transitivity_1.
          apply H21.
          apply col_permutation_5.
          assumption.
        induction H5.
        spliter.
        induction H24.
          unfold Col.
          left.
          assumption.
        unfold Col.
        right; left.
        apply between_symmetry.
        assumption.
      assumption.
    apply l9_2.
    eapply l9_3.
      apply l9_2.
      apply H22.
      unfold Col.
      right; right.
      apply midpoint_bet.
      apply H18.
      apply l7_2.
      assumption.
      apply col_trivial_3.
    assert (forall X Y, Midpoint M X Y -> (Out R X A <-> Out S C Y)).
      eapply l9_4_1.
        apply H9.
        apply col_trivial_1.
        assumption.
        apply col_trivial_3.
        assumption.
      apply l7_2.
      assumption.
    assert (Out R U A <-> Out S C U').
      eapply H23.
      assumption.
    destruct H24.
    eapply l6_7.
      apply l6_6.
      apply H24.
      assumption.
    apply l6_6.
    assumption.
Qed.
l9_4_2
Proof.
    intros.
    assert(Le S C R A \/ Le R A S C) by (apply le_cases).
    induction H6.
      eapply l9_4_2_aux with A C R S;assumption.
    apply l9_2.
    apply l9_2 in H.
    eapply l9_4_2_aux with C A S R;auto.
Qed.
l9_5
Proof.
    intros.
    assert (P <> Q).
      unfold TS in H.
      spliter.
      intro.
      subst Q.
      Col.
    assert(exists A0, Col P Q A0 /\ Perp P Q A A0).
      eapply l8_18_existence.
      intro.
      unfold TS in H.
      spliter.
      apply H.
      apply col_permutation_2.
      assumption.
    assert(exists C0, Col P Q C0 /\ Perp P Q C C0).
      eapply l8_18_existence.
      unfold TS in H.
      spliter.
      intro.
      apply H4.
      apply col_permutation_2.
      assumption.
    assert(exists B0, Col P Q B0 /\ Perp P Q B B0).
      eapply l8_18_existence.
      assert (HH1:=H1).
      unfold Out in HH1.
      unfold TS in H.
      spliter.
      intro.
      assert (Col P B R).
        eapply col_transitivity_1.
          apply H2.
          assumption.
        apply col_permutation_1.
        assumption.
      assert (R <> B).
        intro.
        subst B.
        absurde.
      assert(Col R P A ).
        eapply col_transitivity_1.
          apply H12.
          eapply col_permutation_3.
          assumption.
        apply col_permutation_5.
        apply out_col.
        assumption.
      apply H.
      ColR.
    ex_and H3 A'.
    ex_and H4 C'.
    ex_and H5 B'.
    assert (exists M, Midpoint M A' C').
      apply midpoint_existence.
    ex_and H9 M.
    double A M D.
    assert (Out C' D C <-> Out A' A A).
      eapply l9_4_1.
        apply l9_2.
        apply H.
        apply col_permutation_2.
        assumption.
        assumption.
        apply col_permutation_2.
        assumption.
        assumption.
        apply l7_2.
        apply H10.
      apply l7_2.
      assumption.
    destruct H11.
    assert (Out C' D C).
      apply H12.
      unfold Out.
      repeat split.
        intro.
        subst A'.
        apply perp_distinct in H6.
        spliter.
        absurde.
        intro.
        subst A'.
        apply perp_distinct in H6.
        spliter.
        absurde.
      left.
      apply between_trivial.
    assert (TS P Q A D).
      eapply l9_4_2.
        apply H.
        apply col_permutation_2.
        apply H3.
        assumption.
        apply col_permutation_2.
        apply H4.
        apply H7.
        unfold Out.
        repeat split.
          intro.
          subst A'.
          apply perp_distinct in H6.
          spliter.
          absurde.
          intro.
          subst A'.
          apply perp_distinct in H6.
          spliter.
          absurde.
        left.
        apply between_trivial.
      assumption.
    assert (TS P Q B D).
      eapply l9_3.
        apply H14.
        2:apply H9.
        2: apply H0.
        2:assumption.
      induction (eq_dec_points A' C').
        subst C'.
        apply l7_3 in H10.
        subst A'.
        apply col_permutation_2.
        assumption.
      ColR.
    try assumption.
    eapply l9_4_2.
      apply H15.
      2: apply H8.
      apply col_permutation_2.
      assumption.
      apply col_permutation_2.
      apply H4.
      apply perp_sym.
      apply perp_left_comm.
      eapply perp_col.
        intro.
        subst D.
        unfold Out in H13.
        spliter.
        absurde.
        apply perp_sym.
        apply perp_right_comm.
        apply H7.
      apply col_permutation_5.
      apply out_col.
      assumption.
      eapply out_trivial.
      intro.
      subst B.
      apply perp_distinct in H8.
      spliter.
      absurde.
    apply l6_6.
    assumption.
Qed.
outer_pasch
Proof.
    intros.
    induction(Col_dec P Q C).
      induction(bet_dec P Q C).
        exists A.
        split.
          Between.
        eapply between_exchange4 with C;Between.
      assert (Out Q P C) by (apply l6_4_2;auto).
      exists B.
      split.
        Between.
      unfold Out in H3.
      spliter.
      induction H5.
        apply between_exchange3 with C;Between.
      apply outer_transitivity_between2 with C;Between.
    induction (eq_dec_points B Q).
      subst Q;exists B;Between.
    show_distinct A P.
      intuition.
    show_distinct P Q.
      intuition.
    show_distinct P B.
      intuition.
    assert(TS P Q C B).
      unfold TS.
      repeat split.
        Col.
        assert_cols.
        intro;apply H1; ColR.
      exists Q; split;Col;Between.
    assert_diffs.
    assert (TS P Q A B) by (apply l9_5 with C P;unfold Out;intuition).
    unfold TS in H8.
    spliter.
    ex_and H11 X.
    exists X.
    split.
      assumption.
    assert (exists T, Bet X T P /\ Bet C T B) by (apply inner_pasch with A;Between).
    ex_and H14 T.
    show_distinct B C.
      intuition.
    assert (T = Q).
      apply l6_21 with X P B C; assert_cols;Col.
      intro.
      apply H10.
      eapply col_permutation_2.
      eapply col_transitivity_1 with X.
        2:Col.
        intro.
        treat_equalities.
        apply H10.
        ColR.
      Col.
    subst T;Between.
Qed.
os_distincts
Proof.
  intros A B P Q HOS.
  destruct HOS as [Z [HTS1 HTS2]].
  apply ts_distincts in HTS1.
  apply ts_distincts in HTS2.
  spliter.
  repeat split; auto.
Qed.
invert_one_side
Proof.
    unfold OS.
    intros.
    ex_and H T.
    exists T.
    split; apply invert_two_sides; assumption.
Qed.
l9_8_1
Proof.
    intros.
    unfold OS.
    exists C.
    split; assumption.
Qed.
not_two_sides_id
Proof.
    intros.
    intro.
    unfold TS in H.
    spliter.
    ex_and H1 T.
    apply between_identity in H2.
    subst T.
    apply H0.
    apply H1.
Qed.
l9_8_2
Proof.
    intros.
    unfold OS in H0.
    ex_and H0 D.
    assert (HH:= H).
    assert (HH0:=H0).
    assert (HH1:=H1).
    unfold TS in HH1.
    assert (P <> Q).
      intro.
      subst Q.
      spliter.
      Col.
    spliter.
    unfold TS in HH0.
    assert (P <> Q).
      intro.
      subst Q.
      spliter.
      Col.
    spliter.
    unfold TS in HH.
    assert (P <> Q).
      intro.
      subst Q.
      spliter.
      Col.
    spliter.
    ex_and H13 T.
    ex_and H9 X.
    ex_and H5 Y.
    assert (exists M , Bet Y M A /\ Bet X M B).
      eapply inner_pasch.
        apply H16.
      apply H15.
    ex_and H17 M.
    assert (A <> D).
      intro.
      subst D.
      apply not_two_sides_id in H0.
      assumption.
    assert (B <> D).
      intro.
      subst D.
      apply not_two_sides_id in H1.
      assumption.
    induction (Col_dec A B D).
      induction (eq_dec_points M Y).
        subst M.
        assert (X = Y).
          apply l6_21 with P Q A D; assert_cols; Col; ColR.
        subst Y.
        eapply l9_5.
          apply H.
          apply H9.
        unfold Out.
        repeat split.
          intro.
          subst X.
          apply H11.
          assumption.
          intro.
          subst X.
          apply H3.
          assumption.
        unfold Col in H21.
        induction H21.
          right.
          eapply between_exchange3.
            apply between_symmetry.
            apply H16.
          apply between_symmetry.
          assumption.
        induction H21.
          assert (Bet D B A \/ Bet D A B).
            eapply (l5_1 _ X).
              intro.
              subst X.
              apply H4.
              assumption.
              apply between_symmetry.
              assumption.
            apply between_symmetry.
            assumption.
          induction H22.
            assert (D = B).
              eapply between_equality.
                apply H22.
              apply H21.
            subst D.
            absurde.
          assert (D = A).
            eapply between_equality.
              apply H22.
            apply between_symmetry.
            assumption.
          subst D.
          absurde.
        eapply (l5_2 D).
          intro.
          subst X.
          apply H8.
          assumption.
          apply between_symmetry.
          assumption.
        apply between_symmetry.
        assumption.
      induction (eq_dec_points M X).
        subst M.
        assert (X = Y).
          apply l6_21 with P Q A D; assert_cols; Col; ColR.
        subst Y.
        absurde.
      eapply (l9_5 _ _ M _ X).
        eapply l9_5.
          apply H.
          apply H5.
        unfold Out.
        repeat split.
          intro.
          subst Y.
          apply between_identity in H17.
          subst M.
          absurde.
          assumption.
        right.
        assumption.
        assumption.
      unfold Out.
      assert (Out Y M  A).
        unfold Out.
        repeat split.
          assumption.
          intro.
          subst Y.
          apply H11.
          assumption.
        left.
        assumption.
      repeat split.
        assumption.
        intro.
        subst X.
        apply between_identity in H18.
        subst M.
        absurde.
      left.
      apply H18.
    eapply (l9_5 _ _ M).
      eapply l9_5.
        apply H.
        apply H5.
      unfold Out.
      repeat split.
        intro.
        subst Y.
        apply H7.
        assumption.
        intro.
        subst Y.
        assert(Col B D X).
          eapply (col_transitivity_1 _ M).
            intro.
            subst M.
            apply H3.
            assumption.
            unfold Col.
            left.
            assumption.
          unfold Col.
          left.
          apply between_symmetry.
          assumption.
        apply H21.
        apply col_permutation_1.
        eapply (col_transitivity_1 _ X).
          intro.
          subst X.
          apply H4.
          assumption.
          unfold Col.
          left.
          apply between_symmetry.
          assumption.
        apply col_permutation_1.
        assumption.
      right.
      assumption.
      apply H9.
    unfold Out.
    repeat split.
      intro.
      subst X.
      assert (Col A D Y).
        eapply (col_transitivity_1 _ M).
          intro.
          subst M.
          apply H7.
          assumption.
          unfold Col.
          left.
          assumption.
        unfold Col.
        left.
        apply between_symmetry.
        assumption.
      apply H21.
      apply col_permutation_1.
      eapply (col_transitivity_1 _ Y).
        intro.
        subst Y.
        apply H4.
        assumption.
        apply col_permutation_1.
        assumption.
      unfold Col.
      left.
      apply between_symmetry.
      assumption.
      intro.
      subst X.
      apply H3.
      assumption.
    left.
    assumption.
Qed.
l9_9
Proof.
    intros.
    intro.
    apply (l9_8_2 P Q A B B ) in H.
      apply not_two_sides_id in H.
      assumption.
    assumption.
Qed.
l9_9_bis
Proof.
    intros.
    intro.
    unfold OS in H.
    ex_and H C.
    assert (OS P Q A B).
      eapply l9_8_1.
        apply H.
      assumption.
    assert (~ OS P Q A B).
      apply l9_9.
      assumption.
    contradiction.
Qed.
one_side_chara
Proof.
    intros.
    intros.
    apply l9_9_bis in H2.
    intro.
    apply H2.
    unfold TS.
    repeat split.
      assumption.
      assumption.
    exists X.
    intuition.
Qed.
l9_10
Proof.
    intros.
    double A P A'.
    exists A'.
    unfold TS.
    repeat split.
      assumption.
      intro.
      apply H0.
      eapply col_permutation_2.
      eapply (col_transitivity_1 _ A').
        intro.
        subst A'.
        apply l7_2 in H1.
        eapply is_midpoint_id in H1.
        subst A.
        apply H0.
        assumption.
        apply col_permutation_4.
        assumption.
      unfold Col.
      right; right.
      apply midpoint_bet.
      assumption.
    exists P.
    split.
      apply col_trivial_1.
    apply midpoint_bet.
    assumption.
Qed.
one_side_reflexivity
Proof.
    intros.
    unfold OS.
    double A P C.
    exists C.
    assert (TS P Q A C).
      repeat split.
        assumption.
        intro.
        apply H.
        apply col_permutation_2.
        eapply (col_transitivity_1 _ C).
          intro.
          subst C.
          apply l7_2 in H0.
          apply is_midpoint_id in H0.
          subst A.
          apply H.
          assumption.
          apply col_permutation_4.
          assumption.
        unfold Col.
        right; right.
        apply midpoint_bet.
        assumption.
      exists P.
      split.
        apply col_trivial_1.
      apply midpoint_bet.
      assumption.
    split; assumption.
Qed.
one_side_symmetry
Proof.
    unfold OS.
    intros.
    ex_and H C.
    exists C.
    split; assumption.
Qed.
one_side_transitivity
Proof.
    intros.
    unfold OS in *.
    ex_and H X.
    ex_and H0 Y.
    exists X.
    split.
      assumption.
    apply l9_2.
    eapply l9_8_2.
      apply l9_2.
      apply H2.
    eapply l9_8_1.
      apply l9_2.
      apply H0.
    apply l9_2.
    assumption.
Qed.
col_eq
Proof.
    intros.
    apply eq_sym.
    apply l6_21 with A X B X; assert_diffs; Col.
Qed.
l9_17
Proof.
    intros.
    induction (eq_dec_points A C).
      subst C.
      apply between_identity in H0.
      subst B.
      assumption.
    assert( HH:= H).
    unfold OS in H.
    ex_and H D.
    assert(HH1:=H).
    unfold TS in H2.
    assert (P <> Q).
      intro.
      subst Q.
      spliter.
      Col.
    spliter.
    unfold TS in H.
    assert (P <> Q).
      intro.
      subst Q.
      spliter.
      Col.
    spliter.
    ex_and H8 X.
    ex_and H5 Y.
    assert (exists T,  Bet B T D /\ Bet X T Y).
      eapply l3_17.
        apply H9.
        apply H10.
      assumption.
    ex_and H11 T.
    unfold OS.
    exists D.
    split.
      assumption.
    unfold TS.
    repeat split.
      apply l9_9_bis in HH.
      intro.
      apply HH.
      unfold TS.
      repeat split.
        assumption.
        assumption.
      exists B.
      split.
        assumption.
      assumption.
      unfold TS in HH1.
      spliter.
      assumption.
    exists T.
    induction (Col_dec A C D).
      assert (X = Y).
        apply l6_21 with P Q A D; Col.
          intro.
          subst D.
          assert (OS P Q A A).
            apply one_side_reflexivity.
            assumption.
          apply l9_9_bis in H14.
          contradiction.
          apply col_permutation_2.
          eapply (col_transitivity_1 _ C).
            intro.
            subst D.
            apply between_identity in H10.
            subst Y.
            apply H4.
            assumption.
            assert_cols; Col.
            Col.
      subst Y.
      apply between_identity in H12.
      subst X.
      split.
        assumption.
      assumption.
    split.
      assert (X <> Y).
        intro.
        subst Y.
        apply between_identity in H12.
        subst X.
        apply H13.
        apply col_permutation_1.
        eapply (col_transitivity_1 _ T).
          intro.
          subst D.
          contradiction.
          unfold Col.
          left.
          apply between_symmetry.
          assumption.
        unfold Col.
        left.
        apply between_symmetry.
        assumption.
      eapply col3.
        apply H14.
        unfold Col.
        right; left.
        apply between_symmetry.
        assumption.
        eapply col3.
          apply H3.
          apply col_permutation_1.
          assumption.
          apply col_permutation_1.
          assumption.
        apply col_trivial_3.
      eapply col3.
        apply H3.
        apply col_permutation_1.
        assumption.
        apply col_permutation_1.
        assumption.
      apply col_trivial_2.
    assumption.
Qed.
l9_18
Proof.
    intros.
    split.
      intros.
      unfold TS in H2.
      assert (~ Col A X Y).
        spliter.
        assumption.
      spliter.
      clear H2.
      assert (X <> Y).
        intro.
        subst Y.
        spliter.
        Col.
      ex_and H5 T.
      assert (P=T).
        apply l6_21 with X Y A B; Col.
        intro.
        subst B.
        apply between_identity in H6.
        subst A.
        contradiction.
      subst T.
      repeat split.
        assumption.
        intro.
        apply H3.
        apply col_permutation_2.
        assumption.
      intro.
      apply H4.
      apply col_permutation_2.
      assumption.
    intro.
    unfold TS.
    spliter.
    repeat split.
      intro.
      apply H3.
      apply col_permutation_1.
      assumption.
      intro.
      apply H4.
      apply col_permutation_1.
      assumption.
    exists P.
    split.
      apply col_permutation_2.
      assumption.
    assumption.
Qed.
l9_19
Proof.
    intros.
    split.
      intro.
      assert (HH2:=H2).
      unfold OS in H2.
      ex_and H2 D.
      unfold TS in H3.
      assert (~ Col B X Y).
        spliter.
        assumption.
      spliter.
      clear H3.
      assert (X <> Y).
        intro.
        subst Y.
        spliter.
        Col.
      spliter.
      unfold TS in H2.
      assert (~ Col A X Y).
        spliter.
        assumption.
      spliter.
      clear H2.
      assert (X <> Y).
        intro.
        subst Y.
        spliter.
        Col.
      spliter.
      ex_and H6 M.
      ex_and H9 N.
      split.
        unfold Out.
        repeat split.
          intro.
          subst P.
          apply H7.
          apply col_permutation_2.
          assumption.
          intro.
          subst P.
          apply H4.
          apply col_permutation_2.
          assumption.
        unfold Col in H1.
        induction H1.
          right.
          apply between_symmetry.
          assumption.
        induction H1.
          apply False_ind.
          assert (TS X Y A B).
            unfold TS.
            repeat split.
              assumption.
              assumption.
            exists P.
            split.
              apply col_permutation_2.
              assumption.
            apply between_symmetry.
            assumption.
          apply l9_9_bis in HH2.
          contradiction.
        left.
        assumption.
      intro.
      apply H7.
      Col.
    intros.
    spliter.
    assert (exists D, TS X Y A D).
      apply l9_10.
        assumption.
      intro.
      apply H3.
      apply col_permutation_1.
      assumption.
    ex_elim H4 D.
    unfold OS.
    exists D.
    split.
      assumption.
    eapply l9_5.
      apply H5.
      apply col_permutation_2.
      apply H0.
    assumption.
Qed.
one_side_not_col123
Proof.
    intros.
    unfold OS in H.
    ex_and H C.
    unfold TS in *.
    spliter.
    intro.
    apply H.
    apply col_permutation_2.
    assumption.
Qed.
one_side_not_col124
Proof.
  intros A B X Y HOS.
  apply one_side_not_col123 with X.
  apply one_side_symmetry, HOS.
Qed.
col_two_sides
Proof.
    intros.
    unfold TS in *.
    spliter.
    ex_and H3 T.
    repeat split.
      intro.
      apply H1.
      apply col_permutation_2.
      eapply col_transitivity_1.
        apply H0.
        apply col_permutation_5.
        assumption.
      apply col_permutation_1.
      assumption.
      intro.
      apply H2.
      apply col_permutation_2.
      eapply col_transitivity_1.
        apply H0.
        apply col_permutation_5.
        assumption.
      apply col_permutation_1.
      assumption.
    exists T.
    split.
      apply col_permutation_2.
      apply col_transitivity_1 with B.
        intro.
        subst B.
        Col.
        assumption.
      apply col_permutation_1.
      assumption.
    assumption.
Qed.
col_one_side
Proof.
    unfold OS.
    intros.
    ex_and H1 T.
    exists T.
    split; eapply (col_two_sides _ B); assumption.
Qed.
out_out_one_side
Proof.
    intros.
    assert (A <> B).
      unfold OS in H.
      ex_and H C.
      unfold TS in H.
      spliter.
      intro.
      subst B.
      Col.
    prolong Y A Y' A Y.
    assert(OS A B Y Z).
      unfold OS.
      exists Y'.
      split.
        unfold TS.
        repeat split.
          apply one_side_symmetry in H.
          eapply one_side_not_col123 in H.
          intro.
          apply H.
          apply col_permutation_1.
          assumption.
          intro.
          apply one_side_symmetry in H.
          eapply one_side_not_col123 in H.
          apply H.
          assert(Col A B Y).
            eapply (col_transitivity_1 _ Y').
              intro.
              subst Y'.
              apply cong_symmetry in H3.
              apply cong_identity in H3.
              subst Y.
              unfold Out in H0.
              spliter.
              absurde.
              apply col_permutation_4.
              assumption.
            unfold Col.
            right; right.
            assumption.
          assumption.
        exists A.
        split.
          apply col_trivial_1.
        assumption.
      unfold TS.
      repeat split.
        intro.
        apply one_side_symmetry in H.
        eapply one_side_not_col123 in H.
        apply H.
        eapply (col_transitivity_1 _ Z).
          intro.
          subst Z.
          unfold Out in H0.
          spliter.
          absurde.
          apply col_permutation_4.
          assumption.
        apply out_col in H0.
        apply col_permutation_5.
        assumption.
        apply one_side_symmetry in H.
        eapply one_side_not_col123 in H.
        intro.
        apply H.
        eapply (col_transitivity_1 _ Y').
          intro.
          subst Y'.
          apply cong_symmetry in H3.
          apply cong_identity in H3.
          subst Y.
          apply H.
          apply col_trivial_3.
          apply col_permutation_4.
          assumption.
        unfold Col.
        right; right.
        assumption.
      exists A.
      split.
        apply col_trivial_1.
      unfold Out in H0.
      spliter.
      induction H5.
        apply between_symmetry.
        eapply outer_transitivity_between.
          apply between_symmetry.
          apply H2.
          assumption.
        auto.
      apply between_symmetry.
      eapply between_inner_transitivity.
        apply between_symmetry.
        apply H2; spliter.
      assumption.
    eapply one_side_transitivity.
      apply H.
    apply H4.
Qed.
out_one_side
Proof.
    intros.
    induction H.
      assert(~ Col X A B).
        intro.
        apply H.
        apply col_permutation_1.
        assumption.
      assert(HH:=one_side_reflexivity A B X H1).
      eapply (out_out_one_side _ _ _ _ _ HH H0).
    assert(~ Col Y A B).
      intro.
      apply H.
      apply col_permutation_1.
      assumption.
    assert(HH:=one_side_reflexivity A B Y H1).
    apply one_side_symmetry.
    eapply (out_out_one_side _ _ _ _ _ HH).
    apply l6_6.
    assumption.
Qed.
bet_ts__ts
Proof.
  intros A B X Y Z [HNCol1 [HNCol2 [T [HT1 HT2]]]] HBet.
  repeat split; trivial.
    intro; assert (Z = T); [apply (l6_21 A B X Y); Col; intro|]; treat_equalities; auto.
  exists T; split; eBetween.
Qed.
l9_31
Proof.
    intros.
    assert(A <> X /\ A <> Z /\ ~ Col Y A X  /\ ~ Col Z A X /\ ~Col Y A Z).
      unfold OS in *.
      ex_and H C.
      ex_and H0 D.
      unfold TS in *.
      spliter.
      split.
        intro.
        subst X.
        Col.
      split.
        intro.
        subst Z.
        Col.
      repeat split; assumption.
    spliter.
    prolong Z A Z' Z A.
    assert(Z' <> A).
      intro.
      subst Z'.
      apply cong_symmetry in H7.
      apply cong_identity in H7.
      subst Z.
      absurde.
    assert(TS A X Y Z').
      eapply (l9_8_2 _ _ Z).
        unfold TS.
        repeat split.
          assumption.
          intro.
          apply H4.
          apply col_permutation_2.
          eapply (col_transitivity_1 _ Z').
            auto.
            apply col_permutation_4.
            assumption.
          apply col_permutation_1.
          apply bet_col.
          assumption.
        exists A.
        split.
          apply col_trivial_1.
        assumption.
      apply one_side_symmetry.
      assumption.
    unfold TS in H9.
    assert (~ Col Y A X).
      spliter.
      assumption.
    spliter.
    ex_and H12 T.
    assert(T <> A).
      intro.
      subst T.
      apply H5.
      apply col_permutation_2.
      eapply (col_transitivity_1 _ Z').
        auto.
        apply col_permutation_1.
        apply bet_col.
        assumption.
      apply col_permutation_1.
      apply bet_col.
      assumption.
    assert(OS Y A Z' T).
      eapply out_one_side.
        left.
        intro.
        apply H5.
        apply col_permutation_2.
        eapply (col_transitivity_1 _ Z').
          auto.
          apply bet_col in H6.
          apply col_permutation_1.
          assumption.
        apply col_permutation_1.
        assumption.
      apply l6_6.
      apply bet_out.
        intro.
        subst T.
        contradiction.
      assumption.
    unfold Col in H12.
    induction H12.
      assert(OS Z' Z Y T).
        apply out_one_side.
          left.
          intro.
          apply H5.
          eapply col_permutation_1.
          eapply (col_transitivity_1 _ Z').
            intro.
            subst Z'.
            apply between_identity in H6.
            subst Z.
            apply H4.
            apply col_trivial_1.
            apply col_permutation_4.
            assumption.
          apply bet_col in H6.
          apply col_permutation_5.
          assumption.
        apply l6_6.
        apply bet_out.
          intro.
          subst T.
          apply H11.
          apply bet_col.
          assumption.
        apply between_symmetry.
        assumption.
      assert(OS A Z Y T).
        apply invert_one_side.
        eapply (col_one_side _ Z').
          apply bet_col in H6.
          apply col_permutation_5.
          assumption.
          auto.
        apply invert_one_side.
        assumption.
      assert(TS A Z X T).
        repeat split.
          intro.
          apply H11.
          apply col_permutation_2.
          eapply (col_transitivity_1 _ Z).
            assumption.
            apply col_permutation_1.
            assumption.
          apply bet_col in H6.
          apply col_permutation_4.
          assumption.
          unfold OS in H17.
          ex_and H17 C.
          unfold TS in H18.
          spliter.
          assumption.
        exists A.
        split.
          apply col_trivial_1.
        apply between_symmetry.
        assumption.
      assert(TS A Z Y X).
        eapply l9_8_2.
          eapply l9_2.
          apply H18.
        apply one_side_symmetry.
        assumption.
      apply l9_9 in H19.
      contradiction.
    assert(OS A Z T X).
      apply out_one_side.
        right.
        intro.
        apply H4.
        apply col_permutation_4.
        assumption.
      repeat split.
        assumption.
        auto.
      induction H12.
        right.
        assumption.
      left.
      apply between_symmetry.
      assumption.
    assert(TS A Y Z' Z).
      repeat split.
        unfold OS in H5.
        ex_and H15 C.
        unfold TS in H15.
        spliter.
        intro.
        apply H15.
        apply col_permutation_5.
        assumption.
        intro.
        apply H5.
        apply col_permutation_3.
        assumption.
      exists A.
      split.
        apply col_trivial_1.
      apply between_symmetry.
      assumption.
    assert(OS A Y T X).
      apply out_one_side.
        left.
        unfold OS in H15.
        ex_and H15 C.
        unfold TS in H18.
        spliter.
        intro.
        apply H18.
        apply col_permutation_3.
        assumption.
      repeat split.
        assumption.
        auto.
      induction H12.
        right.
        assumption.
      left.
      apply between_symmetry.
      assumption.
    apply invert_one_side in H15.
    assert (OS A Y Z' X).
      eapply one_side_transitivity.
        apply H15.
      assumption.
    eapply l9_8_2.
      apply H17.
    assumption.
Qed.
col123__nos
Proof.
  intros A B P Q HCol.
  intro HOne.
  assert (~ Col P Q A) by (apply (one_side_not_col123 P Q A B); auto).
  auto.
Qed.
col124__nos
Proof.
  intros A B P Q HCol.
  intro HOne.
  assert (HN : ~ OS P Q B A) by (apply col123__nos; auto).
  apply HN; apply one_side_symmetry; auto.
Qed.
col2_os__os
Proof.
  intros A B C D X Y HCD HColC HColD Hos.
  destruct Hos as [Z [Hts1 Hts2]].
  exists Z.
  split; apply (col_preserves_two_sides A B); auto.
Qed.
os_out_os
Proof.
    intros.
    assert(A <> B /\ ~ Col C A B).
      unfold OS in H0.
      ex_and H0 T.
      unfold TS in H0.
      spliter.
      split.
        intro.
        subst B.
        Col.
      assumption.
    spliter.
    prolong C P T C P.
    assert(P <> T).
      intro.
      subst T.
      treat_equalities.
      Col.
    assert(TS A B C T).
      unfold TS.
      repeat split; Col.
        intro.
        apply H3.
        assert_cols. ColR.
      exists P.
      split; Col.
    assert(TS A B T C').
      apply bet_col in H4.
      eapply (out_out_two_sides _ _ T C _ _ P); Col.
        apply l9_2.
        assumption.
      apply out_trivial.
      auto.
    assert(OS A B C C').
      eapply l9_8_1.
        apply H7.
      apply l9_2.
      assumption.
    eauto using one_side_transitivity, one_side_symmetry.
Qed.
ts_ts_os
Proof.
    intros.
    unfold TS in *.
    spliter.
    ex_and H4 T1.
    ex_and H2 T.
    assert(T1 = T).
      assert_cols.
      apply (l6_21 C D A B); Col.
      intro.
      subst B.
      Col.
    subst T1.

assert(OS A C T B).
apply(out_one_side A C T B).
right.
intro.
Col.
unfold Out.
repeat split.
intro.
subst T.
contradiction.
intro.
subst B.
Col.
left.
assumption.

assert(OS C A T D).
apply(out_one_side C A T D).
right.
intro.
apply H0.
Col.
unfold Out.
repeat split.
intro.
subst T.
contradiction.
intro.
subst D.
Col.
left.
assumption.
apply invert_one_side in H8.
apply (one_side_transitivity A C B T).
apply one_side_symmetry.
assumption.
assumption.
Qed.
two_sides_not_col
Proof.
    intros.
    unfold TS in H.
    spliter.
    intro.
    apply H.
    apply col_permutation_2.
    assumption.
Qed.
col_one_side_out
Proof.
    intros.
    assert(X <> A /\ Y <> A).
      unfold OS in H0.
      ex_and H0 Z.
      unfold TS in *.
      spliter.
      ex_and H5 T0.
      ex_and H3 T1.
      split.
        intro.
        subst X.
        Col.
      intro.
      subst Y.
      Col.
    spliter.
    unfold Col in H.
    induction H.
      unfold Out.
      repeat split; try assumption.
      left.
      assumption.
    induction H.
      unfold Out.
      repeat split; try assumption.
      right.
      apply between_symmetry.
      assumption.
    assert(TS A B X Y).
      unfold TS.
      assert(HH0 := H0).
      unfold OS in H0.
      ex_and H0 Z.
      unfold TS in *.
      spliter.
      repeat split.
        assumption.
        assumption.
      exists A.
      split.
        apply col_trivial_1.
      apply between_symmetry.
      assumption.
    eapply l9_9 in H3.
    contradiction.
Qed.
col_two_sides_bet
Proof.
    intros.
    unfold Col in H.
    induction H.
      unfold TS in H0.
      spliter.
      ex_and H2 T.
      apply False_ind.
      apply H1.
      apply col_permutation_2.
      eapply (col_transitivity_1 _ T).
        intro.
        subst T.
        assert(A = X).
          eapply between_equality.
            apply H.
          assumption.
        subst X.
        apply H0.
        apply col_trivial_1.
        apply col_permutation_4.
        assumption.
      apply col_permutation_1.
      eapply (col_transitivity_1 _ X).
        intro.
        subst Y.
        apply between_identity in H3.
        subst X.
        contradiction.
        apply bet_col in H.
        apply col_permutation_3.
        assumption.
      apply col_permutation_2.
      apply bet_col.
      assumption.
    induction H.
      unfold TS in H0.
      spliter.
      ex_and H2 T.
      assert(Col Y A T).
        eapply (col_transitivity_1 _ X).
          intro.
          subst Y.
          apply between_identity in H3.
          subst X.
          contradiction.
          apply col_permutation_4.
          apply bet_col.
          assumption.
        apply col_permutation_2.
        apply bet_col.
        assumption.
      apply False_ind.
      apply H1.
      apply col_permutation_2.
      eapply (col_transitivity_1 _ T).
        intro.
        subst T.
        assert(A = Y).
          eapply between_equality.
            apply between_symmetry.
            apply H.
          apply between_symmetry.
          assumption.
        subst Y.
        apply H1.
        apply col_trivial_1.
        apply col_permutation_4.
        assumption.
      apply col_permutation_1.
      assumption.
    apply between_symmetry.
    assumption.
Qed.
os_ts1324__os
Proof.
  intros A X Y Z Hos Hts.
  destruct Hts as [HNColXY [HNColYZ [P [HColP HPBet]]]].
  apply (one_side_transitivity _ _ _ P).
  - apply invert_one_side.
    apply one_side_symmetry.
    apply one_side_symmetry in Hos.
    apply one_side_not_col123 in Hos.
    apply out_one_side; Col.
    apply bet_out; Between; intro; subst Z; Col.

  - apply out_one_side.
    right; Col.
    apply (col_one_side_out _ X); Col.
    apply one_side_symmetry in Hos.
    apply (one_side_transitivity _ _ _ Z); auto.
    apply invert_one_side.
    apply one_side_not_col123 in Hos.
    apply out_one_side; Col.
    apply bet_out; auto; intro; subst X; Col.
Qed.
ts2__ex_bet2
Proof.
  intros A B C D HTS HTS'.
  destruct HTS as [HNCol [HNCol1 [X [HCol HBet]]]].
  exists X; split; trivial.
  apply col_two_sides_bet with B; trivial.
  assert_diffs.
  apply invert_two_sides, col_two_sides with D; Col.
  intro; subst X; auto.
Qed.
ts2__inangle
Proof.
  intros A B C P HTS1 HTS2.
  destruct (ts2__ex_bet2 A B C P) as [X [HBet1 HBet2]]; trivial.
  apply ts_distincts in HTS2; spliter.
  repeat split; auto.
  exists X; split; trivial.
  right; apply bet_out; auto.
  intro; subst X.
  apply (two_sides_not_col A C B P HTS1); Col.
Qed.
out_one_side_1
Proof.
    intros.
    induction (eq_dec_points C D).
      subst D.
      apply one_side_reflexivity.
      intro.
      apply H.
      Col.
    prolong C X C' C X.
    exists C'.
    assert(TS A B C C').
      unfold TS.
      repeat split.
        intro.
        apply H.
        Col.
        intro.
        assert(C'=X).
          eapply (l6_21 A B C D).
            assumption.
            assumption.
            Col.
            assumption.
            apply out_col in H1.
            eapply (col_transitivity_1 _ X).
              intro.
              treat_equalities.
              Col5.
              Col.
            Col.
            Col.
        treat_equalities.
        unfold Out in H1.
        tauto.
      exists X.
      split; Col.
    assert(TS A B D C').
      eapply (l9_5 _ _ _ _ X).
        apply H5.
        Col.
      assumption.
    split; assumption.
Qed.
TS__ncol
Proof.
intros.
unfold TS in H.
spliter.
ex_and H1 T.

assert(X <> Y).
intro.
treat_equalities.
contradiction.
induction(eq_dec_points A T).
treat_equalities.
right.
intro.
apply H.
ColR.
left.
intro.
apply H.
ColR.
Qed.
all_coplanar
Proof.
apply upper_dim_implies_all_coplanar;
unfold upper_dim_axiom; apply upper_dim.
Qed.
per_per_col
Proof.
intros. apply cop_per_per_col with C; auto; apply all_coplanar.
Qed.
perp_perp_col
Proof.
    intros.
    induction(Col_dec A B X).
      induction(eq_dec_points X A).
        subst A.
        assert(X <> B).
          apply perp_distinct in H.
          spliter.
          assumption.
        apply perp_right_comm in H.
        apply perp_perp_in in H.
        apply perp_in_comm in H.
        apply perp_in_per in H.
        apply perp_right_comm in H0.
        apply perp_perp_in in H0.
        apply perp_in_comm in H0.
        apply perp_in_per in H0.
        apply col_permutation_2.
        eapply (per_per_col).
          apply H.
          assumption.
        assumption.
      assert(Perp A X X Y ).
        eapply perp_col.
          auto.
          apply perp_sym.
          apply H.
        assumption.
      assert(Perp A X X Z).
        eapply perp_col.
          auto.
          apply perp_sym.
          apply H0.
        assumption.
      apply col_permutation_2.
      eapply (per_per_col _ _ A).
        apply perp_in_per.
        apply perp_in_comm.
        apply perp_perp_in.
        apply perp_sym.
        eapply perp_col.
          auto.
          apply perp_sym.
          apply H.
        assumption.
        assumption.
      apply perp_in_per.
      apply perp_in_comm.
      apply perp_perp_in.
      apply perp_sym.
      eapply perp_col.
        auto.
        apply perp_sym.
        apply H0.
      assumption.
    assert(HH0:=H).
    assert(HH1:=H0).
    unfold Perp in H.
    unfold Perp in H0.
    ex_and H Y0.
    ex_and H0 Z0.
    assert(HH2:=H).
    assert(HH3:=H2).
    apply perp_in_col in H.
    apply perp_in_col in H2.
    spliter.
    assert(Perp X Y0 A B).
      eapply perp_col.
        intro.
        subst Y0.
        contradiction.
        apply HH0.
      assumption.
    assert(Perp X Z0 A B).
      eapply perp_col.
        intro.
        subst Z0.
        contradiction.
        apply HH1.
      assumption.
    assert(Y0 = Z0).
      eapply l8_18_uniqueness.
        apply H1.
        assumption.
        apply perp_sym.
        assumption.
        assumption.
      apply perp_sym.
      assumption.
    subst Z0.
    eapply (col_transitivity_1 _ Y0).
      intro.
      subst Y0.
      contradiction.
      Col.
    Col.
Qed.
cong_on_bissect
Proof.
intros.
assert(X = M \/ ~ Col A B X /\ Perp_at M X M A B).
apply(cong_perp_or_mid A B M X H H0); Cong.
induction H3.
treat_equalities; Col.
spliter.
apply perp_in_perp in H1.
apply perp_in_perp in H4.
apply(perp_perp_col _ _ _ A B); Perp.
Qed.
cong_mid_perp__col
Proof.
intros.
assert_diffs.
induction(eq_dec_points X M).
- subst X; Col.
- assert(HP:Per X M A) by (unfold Per;exists B;split; Cong).
apply per_perp_in in HP; auto.
apply perp_in_comm in HP.
apply perp_in_perp in HP.
apply perp_sym in HP.
apply (perp_col A M M X B) in HP; Col.
apply (perp_perp_col _ _ _ A B); Perp.
Qed.
image_in_col
Proof.
    intros.
    assert(ReflectL P P' A B).
      eapply (image_in_is_image_spec M).
      assumption.
    assert(ReflectL Q Q' A B).
      eapply (image_in_is_image_spec M).
      assumption.
    unfold ReflectL_at in *.
    spliter.
    induction H3.
      induction H5.
        induction (eq_dec_points A M).
          subst M.
          assert (Per B A P).
            unfold Per.
            exists P'.
            split.
              apply l7_2.
              assumption.
            apply cong_commutativity.
            eapply is_image_spec_col_cong with A B;Col.
          assert (Per B A Q).
            unfold Per.
            exists Q'.
            split.
              apply l7_2.
              assumption.
            apply cong_commutativity.
            eapply is_image_spec_col_cong with A B;Col.
          apply col_permutation_2.

          eapply per_per_col.
            apply l8_2.
            apply H7.
            apply perp_distinct in H3.
            spliter.
            assumption.
          apply l8_2.
          assumption.
        assert (Per A M P).
          unfold Per.
          exists P'.
          split.
            apply l7_2.
            assumption.
          apply cong_commutativity.
          eapply is_image_spec_col_cong.
            apply H1.
          Col.
        assert (Per A M Q).
          unfold Per.
          exists Q'.
          split.
            apply l7_2.
            assumption.
          apply cong_commutativity.
          eapply is_image_spec_col_cong.
            apply H2.
          apply col_trivial_3.
        apply col_permutation_2.
        eapply per_per_col.
          apply l8_2.
          apply H8.
          auto.
        apply l8_2.
        assumption.
      subst P'.
      apply l7_3 in H.
      subst P.
      Col.
    subst Q'.
    apply l7_3 in H0.
    subst Q.
    Col.
Qed.
l10_10_spec
Proof.
    intros.
    assert(HH0 := H0).
    assert(HH1 := H1 ).
    unfold ReflectL in H0.
    unfold ReflectL in H1.
    spliter.
    ex_and H0 X.
    ex_and H1 Y.
    assert (exists M, Midpoint M X Y).
      apply midpoint_existence.
    ex_elim H6 M0.
    double P M0 P''.
    double Q M0 Q''.
    double P' M0 P'''.
    apply cong_commutativity.
    induction H3.
      induction H2.
        assert (ReflectL P'' P''' A B).
          apply is_image_is_image_spec .
            assumption.
          eapply (midpoint_preserves_image ) with P P' M0.
            assumption.
            induction (eq_dec_points X Y).
              subst Y.
              apply l7_3 in H7.
              subst X.
              assumption.
            assert_cols.
            ColR.
            apply l10_4.
            apply is_image_is_image_spec;auto.
            assumption.
          assumption.
        assert(P'' <> P''').
          intro.
          subst P'''.
          assert( P' = P).
            eapply l7_9.
              apply H9.
            assumption.
          subst P'.
          apply perp_distinct in H3.
          spliter.
          absurde.
        assert (Midpoint Y P'' P''') by (eauto using symmetry_preserves_midpoint).
        assert (Cong P'' Y P''' Y) by (unfold Midpoint in *; spliter; Cong).
        assert (Cong Q Y Q' Y) by (unfold Midpoint in *;spliter; Cong).
        assert (Col P'' Y Q).
          apply col_permutation_2.
          eapply image_in_col.
            eapply image_image_in.
              apply perp_distinct in H2.
              spliter.
              apply H15.
              apply l10_4_spec.
              apply HH1.
              assumption.
            unfold Col.
            left.
            apply midpoint_bet.
            assumption.
          eapply (image_image_in _ _ _ P''').
            assumption.
            assumption.
            assumption.
          unfold Col.
          left.
          apply midpoint_bet.
          assumption.
        eapply (l4_16 P'' Y Q P P''' Y Q' P').
          repeat split.
            assumption.
            assumption.
            unfold Col in H15.
            induction H15.
              assert(Bet P''' Y Q').
                eapply (l7_15).
                  apply H12.
                  apply l7_3_2.
                  apply H1.
                assumption.
              eapply l2_11.
                apply H15.
                apply H16.
                assumption.
              apply cong_commutativity.
              assumption.
            induction H15.
              assert (Bet Y Q' P''').
                eapply (l7_15).
                  apply l7_3_2.
                  apply H1.
                  apply H12.
                assumption.
              eapply l4_3.
                apply between_symmetry.
                apply H15.
                apply between_symmetry.
                apply H16.
                assumption.
              assumption.
            apply between_symmetry in H15.
            assert (Bet Y P''' Q').
              eapply (l7_15).
                apply l7_3_2.
                apply H12.
                apply H1.
              assumption.
            apply cong_commutativity.
            eapply l4_3.
              apply between_symmetry.
              apply H15.
              apply between_symmetry.
              apply H16.
              assumption.
            assumption.
            apply cong_commutativity.
            assumption.
            assert (Cong P Y P' Y).
              eapply is_image_spec_col_cong.
                eapply l10_4_spec.
                apply HH0.
              assumption.
            assert (Cong P P'' P' P''').
              induction(eq_dec_points X Y).
                subst Y.
                eapply l2_11.
                  apply midpoint_bet.
                  apply H6.
                  apply H9.
                  apply l7_3 in H7.
                  subst X.
                  assumption.
                apply l7_3 in H7.
                subst X.
                eapply cong_transitivity.
                  unfold Midpoint in H6.
                  spliter.
                  apply cong_symmetry.
                  apply H7.
                eapply cong_transitivity.
                  apply H16.
                unfold Midpoint in H9.
                spliter.
                assumption.
              eapply l2_11.
                apply H6.
                apply H9.
                (* pas besoin de deployer ???*)
                eapply is_image_spec_col_cong.
                  apply l10_4_spec.
                  apply HH0.
                unfold Midpoint in H7.
                spliter.
                ColR.
              apply cong_commutativity.
              eapply is_image_spec_col_cong.
                apply H10.
              ColR.
            apply cong_commutativity.
            assumption.
          apply cong_commutativity.
          eapply is_image_spec_col_cong.
            apply l10_4_spec.
            apply HH0.
          assumption.
        intro.
        subst P''.
        apply cong_symmetry in H13.
        apply cong_identity in H13.
        subst P'''.
        absurde.
      subst Q'.
      apply l7_3 in H1.
      subst Q.
      apply cong_commutativity.
      eapply is_image_spec_col_cong.
        (* apply H. *)
        apply l10_4_spec.
        apply HH0.
      assumption.
    subst P'.
    apply l7_3 in H0.
    subst P.
    eapply is_image_spec_col_cong.
      apply l10_4_spec.
      apply HH1.
    assumption.
Qed.
l10_10
Proof.
    intros.
    induction (eq_dec_points A B).
      subst.
      unfold Reflect in *.
      induction H.
        intuition.
      induction H0.
        intuition.
      spliter.
      apply l7_13 with B; apply l7_2;auto.
    apply l10_10_spec with A B;try apply -> is_image_is_image_spec;assumption.
Qed.
image_preserves_bet
Proof.
    intros.
    eapply l4_6.
      apply H3.
    unfold Cong_3.
    repeat split; eapply l10_10_spec.
      apply H.
      apply l10_4_spec.
      assumption.
      apply l10_4_spec; assumption.
      apply H.
      apply l10_4_spec.
      assumption.
      apply l10_4_spec.
      assumption.
      apply H.
      apply l10_4_spec.
      assumption.
    apply l10_4_spec.
    assumption.
Qed.
image_gen_preserves_bet
Proof.
    intros.
    eapply image_preserves_bet;try apply is_image_is_image_spec; eauto.
Qed.
image_preserves_col
Proof.
    intros.
    destruct H3 as [HBet|[HBet|HBet]]; [|apply col_permutation_2|apply col_permutation_1];
    apply bet_col; eapply image_preserves_bet; eauto.
Qed.
image_gen_preserves_col
Proof.
    intros.
    apply image_preserves_col with A B C X Y; try (apply is_image_is_image_spec); auto.
Qed.
image_gen_preserves_ncol
Proof.
    intros.
    intro.
    apply H3, image_gen_preserves_col with A' B' C' X Y; try (apply l10_4); assumption.
Qed.
image_gen_preserves_inter
Proof.
    intros.
    destruct (l10_6_existence X Y I) as [I0 HI0]; trivial.
    assert (I' = I0); [|subst; assumption].
    apply (l6_21 A' B' C' D'); trivial.
      apply image_gen_preserves_ncol with A B C X Y; assumption.
      intro; subst D'; apply H5, l10_2_uniqueness with X Y C'; assumption.
      apply image_gen_preserves_col with A B I X Y; assumption.
      apply image_gen_preserves_col with C D I X Y; assumption.
Qed.
intersection_with_image_gen
Proof.
    intros.
    apply l10_8.
    assert (Reflect A' A X Y) by (apply l10_4; assumption).
    assert (~ Col A' B' A) by (apply image_gen_preserves_ncol with A B A' X Y; trivial).
    assert_diffs.
    apply image_gen_preserves_inter with A B A' B' A' B' A B; trivial.
    apply l10_4; assumption.
Qed.
image_preserves_midpoint
Proof.
    intros.
    unfold Midpoint in *.
    spliter.
    repeat split.
      eapply image_preserves_bet.
        apply H.
        apply H1.
        apply H0.
        apply H2.
      assumption.
    eapply cong_transitivity.
      eapply l10_10_spec.
        apply H.
        apply H1.
      apply H0.
    eapply cong_transitivity.
      apply H4.
    eapply l10_10_spec.
      apply H.
      apply l10_4_spec.
      apply H0.
    apply l10_4_spec.
    apply H2.
Qed.
image_preserves_per
Proof.
    intros.
    double C B C1.
    assert (exists C1', ReflectL C1 C1' X Y).
      apply l10_6_existence_spec.
      assumption.
    ex_and H5 C1'.
    unfold Per.
    exists C1'.
    split.
      eapply image_preserves_midpoint.
        apply H.
        apply H1.
        apply H2.
        apply H6.
      assumption.
    eapply cong_transitivity.
      eapply l10_10_spec.
        apply H.
        apply H0.
      apply H2.
    eapply cong_transitivity.
      unfold Per in H3.
      ex_and H3 C2.
      assert (C2=C1).
        eapply symmetric_point_uniqueness.
          apply H3.
        assumption.
      subst C2.
      apply H5.
    eapply l10_10_spec.
      apply H.
      apply l10_4_spec.
      assumption.
    apply l10_4_spec.
    assumption.
Qed.
l10_12
Proof.
    intros.
    induction (eq_dec_points B C).
      treat_equalities;auto.
    induction (eq_dec_points A B).
      treat_equalities;auto.
    assert (exists X, Midpoint X B B').
      apply midpoint_existence.
    ex_and H5 X.
    double A' X A1.
    double C' X C1.
    assert(Cong_3 A' B' C' A1 B C1)
    by (repeat split;eauto using l7_13, l7_2).
    assert (Per A1 B C1)
      by (eauto using l8_10).
    unfold Cong_3 in H8.
    spliter.
    assert(Cong A B A1 B) by (apply cong_transitivity with A' B'; trivial).
    assert(Cong B C B C1) by (apply cong_transitivity with B' C'; trivial).

    assert(exists Y, Midpoint Y C C1)
      by (apply midpoint_existence).
    ex_and H14 Y.
    apply cong_symmetry.
    eapply cong_transitivity.
      apply H10.
    induction (eq_dec_points B Y).
    {
      subst Y.
      induction (eq_dec_points A A1).
        subst A1.
        unfold Per in H9.
        ex_and H9 C2.
        assert (C=C2).
          eapply l7_9.
            apply H15.
          apply l7_2.
          assumption.
        subst C2.
        assumption.
      assert_diffs.
      assert (Per  C B A1).
       {
        eapply (l8_3 C1 B A1 C).
          apply l8_2.
          apply H9.
          auto.
        apply midpoint_col.
        apply l7_2.
        assumption.
       }
      assert(Col A  A1 B).
       {
        assert_cols.
        assert_diffs.

        eapply per_per_col.
          apply H.
          assumption.
        apply l8_2.
        assumption.
       } 
      assert (A=A1 \/ Midpoint B A A1).
        {
         eapply l7_20.
          apply col_permutation_5.
          assumption.
        apply cong_commutativity.
        assumption.
        }
      induction H23.
        contradiction.
      eauto using l7_13.
    }
    assert(ReflectL C1 C B Y).
      unfold ReflectL.
      split.
        exists Y.
        split.
          assumption.
        apply col_trivial_2.
      induction(eq_dec_points C C1).
        right.
        assumption.
      left.
      apply perp_sym.
      assert(Y<>C /\ Y <> C1).
        eapply midpoint_distinct_1.
          assumption.
        assumption.
      spliter.
      eapply col_per_perp.
        assumption.
        auto.
        intuition.
        auto.
        apply midpoint_col.
        assumption.
      unfold Per.
      exists C1.
      split.
        assumption.
      assumption.
    induction (is_image_spec_dec A A1 B Y).
      eapply l10_10_spec.
        2:apply H17.
        assumption.
      apply l10_4_spec.
      assumption.
    (*************** cas 2 ***************)
    assert(exists A2, ReflectL A1 A2 B Y).
      apply l10_6_existence_spec.
      assumption.
    ex_elim H18 A2.
    assert (Cong  C A2 C1 A1).
      eapply l10_10_spec.
        2:apply H16.
        assumption.
      assumption.
    assert (Per A2 B C).
      eapply (image_preserves_per A1 B C1 A2 B C).
        2:apply H19.
        assumption.
        apply image_col.
        apply col_trivial_3.
        assumption.
      assumption.
    assert (Cong A1 B A2 B).
      eapply is_image_spec_col_cong.
        apply H19.
      apply col_trivial_3.
    assert (A = A2 \/ Midpoint B A A2).
      eapply l7_20.
        apply col_permutation_1.
        eapply per_per_col.
          apply H20.
          assumption.
        assumption.
      eapply cong_transitivity.
        apply cong_commutativity.
        apply H12.
      apply cong_commutativity.
      assumption.
    induction H22.
      subst A2.
      apply cong_symmetry.
      apply cong_commutativity.
      assumption.
    assert(Cong A C A2 C).
      apply l8_2 in H.
      unfold Per in H.
      ex_and H A3.
      assert(A2=A3).
        eapply symmetric_point_uniqueness.
          apply H22.
        apply H.
      subst A3.
      apply cong_commutativity.
      assumption.
    eapply cong_transitivity.
      apply cong_symmetry.
      apply cong_commutativity.
      apply H18.
    apply cong_symmetry.
    assumption.
Qed.
l10_16
Proof.
    intros.
    induction (eq_dec_points A B).
      subst B.
      apply cong_symmetry in H1.
      apply False_ind.
      apply H.
      apply col_trivial_1.
    assert(exists X, Col A B X /\ Perp A B C X).
      apply l8_18_existence.
      assumption.
    ex_and H3 X.
    assert (exists X', Cong_3 A B X A' B' X').
      eapply l4_14.
        assumption.
      assumption.
    ex_elim H5 X'.
    assert (exists Q, Perp A' B' Q X' /\ OS A' B' P Q).
      apply l10_15.
        eapply l4_13.
          apply H3.
        assumption.
      assumption.
    ex_and H5 Q.
    assert (exists C', Out X' C' Q /\ Cong  X' C' X C).
      eapply l6_11_existence.
        apply perp_distinct in H5.
        spliter.
        assumption.
      intro.
      subst C.
      apply perp_distinct in H4.
      spliter.
      absurde.
    ex_and H8 C'.
    exists C'.
    unfold Cong_3 in *.
    spliter.
    assert (Cong A C A' C').
      induction(eq_dec_points A X).
        subst X.
        apply cong_symmetry in H10.
        apply cong_identity in H10.
        subst X'.
        apply cong_symmetry.
        assumption.
      eapply l10_12.
        3: apply H10.
        apply perp_in_per.
        eapply l8_14_2_1b_bis.
          eapply perp_col.
            assumption.
            apply perp_right_comm.
            apply H4.
          assumption.
          apply col_trivial_3.
        apply col_trivial_1.
        apply perp_in_per.
        eapply l8_14_2_1b_bis.
          eapply perp_col.
            intro assumption.
            subst X'.
            apply cong_identity in H10.
            contradiction.
            apply perp_sym.
            eapply perp_col.
              intro.
              subst X'.
              apply cong_symmetry in H9.
              apply cong_identity in H9.
              subst X.
              apply perp_distinct in H4.
              spliter.
              absurde.
              apply perp_sym.
              apply perp_right_comm.
              apply H5.
            apply col_permutation_5.
            eapply out_col.
            assumption.
          eapply l4_13.
            apply H3.
          unfold Cong_3.
          repeat split;assumption.
          apply col_trivial_3.
        apply col_trivial_1.
      apply cong_symmetry.
      assumption.
    assert (Cong B C B' C').
      induction(eq_dec_points B X).
        subst X.
        apply cong_symmetry in H11.
        apply cong_identity in H11.
        subst X'.
        apply cong_symmetry.
        assumption.
      eapply l10_12.
        3: apply H11.
        apply perp_in_per.
        eapply l8_14_2_1b_bis.
          eapply perp_col.
            assumption.
            apply perp_comm.
            apply H4.
          apply col_permutation_4.
          assumption.
          apply col_trivial_3.
        apply col_trivial_1.
        apply perp_in_per.
        eapply l8_14_2_1b_bis.
          eapply perp_col.
            intro assumption.
            subst X'.
            apply cong_identity in H11.
            contradiction.
            apply perp_sym.
            eapply perp_col.
              intro.
              subst X'.
              apply cong_symmetry in H9.
              apply cong_identity in H9.
              subst X.
              apply perp_distinct in H4.
              spliter.
              absurde.
              apply perp_sym.
              apply perp_comm.
              apply H5.
            apply col_permutation_5.
            eapply out_col.
            assumption.
          apply col_permutation_4.
          eapply l4_13.
            apply H3.
          unfold Cong_3.
          repeat split; assumption.
          apply col_trivial_3.
        apply col_trivial_1.
      apply cong_symmetry.
      assumption.
    repeat split.
      assumption.
      assumption.
      assumption.
    assert (T19 := (l9_19 A' B' C' Q X')).
    assert (OS A' B' C' Q <-> Out X' C' Q /\ ~ Col A' B' C').
      apply T19.
        intro.
        subst B'.
        apply cong_identity in H1.
        contradiction.
        eapply l4_13.
          apply H3.
        unfold Cong_3.
        repeat split; assumption.
      apply col_permutation_1.
      apply out_col.
      assumption.
    apply cong_symmetry in H1.
    destruct H14.
    spliter.
    assert (OS A' B' C' Q).
      apply H15.
      split.
        assumption.
      intro.
      apply H.
      eapply l4_13.
        apply H16.
      unfold Cong_3.
      repeat split.
        assumption.
        apply cong_symmetry.
        assumption.
      apply cong_symmetry.
      assumption.
    eapply one_side_transitivity.
      apply H7.
    apply one_side_symmetry.
    assumption.
Qed.
image_cong_col
Proof.
    intros.
    unfold Reflect in *.
    induction H0.
      spliter.
      unfold ReflectL in H2.
      spliter.
      ex_and H2 M.
      induction H3.
        induction(eq_dec_points A M).
          subst M.
          assert (Perp P A A B).
            eapply perp_col.
              apply perp_distinct in H3.
              spliter.
              intro.
              subst P.
              apply l7_2 in H2.
              apply is_midpoint_id in H2.
              subst P'.
              absurde.
              apply perp_sym.
              apply perp_right_comm.
              apply H3.
            unfold Col.
            right; left.
            apply midpoint_bet.
            assumption.
          apply perp_comm in H5.
          apply perp_perp_in in H5.
          apply perp_in_comm in H5.
          apply perp_in_per in H5.
          assert (Per X A P).
            unfold Per.
            exists P'.
            split.
              apply l7_2.
              assumption.
            Cong.
          apply l8_2 in H5.
          apply col_permutation_2.
          eapply per_per_col.
            apply H5.
            intro.
            subst P.
            apply l7_2 in H2.
            apply is_midpoint_id in H2.
            subst P'.
            absurde.
          assumption.
        assert (Perp P M M A).
          eapply perp_col.
            intro.
            subst P.
            apply l7_2 in H2.
            apply is_midpoint_id in H2.
            subst P'.
            absurde.
            apply perp_sym.
            apply perp_comm.
            eapply perp_col.
              assumption.
              apply H3.
            assumption.
          unfold Col.
          right; left.
          apply midpoint_bet.
          assumption.
        apply perp_comm in H6.
        apply perp_perp_in in H6.
        apply perp_in_comm in H6.
        apply perp_in_per in H6.
        assert (Per X M P).
          unfold Per.
          exists P'.
          split.
            apply l7_2.
            assumption.
          apply cong_commutativity.
          assumption.
        apply l8_2 in H6.
        assert (Col A X M).
          eapply per_per_col.
            apply H6.
            intro.
            subst P.
            apply l7_2 in H2.
            apply is_midpoint_id in H2.
            subst P'.
            absurde.
          assumption.
        eapply col_transitivity_1.
          apply H5.
          apply col_permutation_5.
          assumption.
        apply col_permutation_5.
        assumption.
      subst P'.
      absurde.
    spliter;subst;Col.
Qed.
per_per_cong_1
Proof.
    intros.
    (* eauto 6 using l7_20, per_per_col, l8_2, col_permutation_5.
    *)
    eapply l7_20.
      apply col_permutation_5.
      eapply per_per_col with A.
        apply l8_2.
        apply H0.
        auto.
      apply l8_2.
      assumption.
    assumption.
Qed.
per_per_cong
Proof.
    intros.
    assert (Col X Y B).
      eapply per_per_col.
        apply l8_2.
        apply H0.
        auto.
      apply l8_2.
      assumption.
    induction (eq_dec_points X Y).
      left.
      assumption.
    right.
    unfold ReflectL.
    split.
      exists B.
      split.
        assert (X = Y \/ Midpoint B X Y).
          eapply l7_20.
            apply col_permutation_5.
            assumption.
          assumption.
        induction H5.
          contradiction.
        apply l7_2.
        assumption.
      apply col_trivial_2.
    left.
    assert(Perp A B B Y).
      eapply per_perp.
        assumption.
        intro.
        subst Y.
        apply cong_identity in H2.
        subst X.
        absurde.
      assumption.
    apply perp_sym.
    eapply perp_col.
      auto.
      apply perp_sym.
      apply perp_right_comm.
      apply H5.
    apply col_permutation_1.
    assumption.
Qed.
per_per_cong_gen
Proof.
    intros.
    assert (X = Y \/ ReflectL X Y A B) by (apply per_per_cong;auto).
    induction H3.
      tauto.
    right.
    unfold Reflect.
    tauto.
Qed.
two_sides_dec
Proof.
apply upper_dim_implies_two_sides_dec.
apply all_coplanar_implies_upper_dim; unfold all_coplanar_axiom;
apply all_coplanar.
Qed.
one_side_dec
Proof.
    intros.
    elim (Col_dec C A B); intro HCol1.
      right.
      intro H.
      destruct H as [C' [Hts1 Hts2]].
      unfold TS in *.
      intuition.
    elim (Col_dec D A B); intro HCol2.
      right.
      intro H.
      destruct H as [C' [Hts1 Hts2]].
      unfold TS in *.
      intuition.
induction(eq_dec_points C D).
subst D.
left.
apply one_side_reflexivity; auto.
assert(A <> B).
intro.
subst B.
apply HCol1.
Col.

assert( exists X : Tpoint, Col A B X /\ Perp A B D X).
apply(l8_18_existence A B D); Col.
ex_and H1 D'.

induction(eq_dec_points D' B).
subst D'.


assert(exists P T : Tpoint,
       Cong B P B D /\ Perp B A P B /\ Col B A T /\ TS B A C P).
apply(l8_21_bis B A C B D); auto.
intro.
subst D.
apply HCol2.
Col.
Col.
ex_and H3 P.
ex_and H4 T.

assert(Per A B D).
apply perp_in_per.
apply perp_left_comm in H2.
apply perp_perp_in in H2.
Perp.

assert(Per A B P).
apply perp_in_per.
apply perp_perp_in in H4.
Perp.
assert(Col D P B).
apply (per_per_col _ _ A); Perp.

assert(D = P \/ Midpoint B D P).
apply(l7_20 B D P); finish.
apply invert_two_sides in H6.

induction H10.
subst P.
right.
apply l9_9 in H6.
assumption.
left.

assert(TS A B D P).
unfold Midpoint in H10.
spliter.
repeat split; Col.
apply per_not_col in H8.
intro.
apply H8.
Col.
assumption.
intro.
subst P.
apply cong_identity in H11.
subst D.
apply HCol2.
Col.
exists B.
split; Col.
unfold OS.
exists P.
split; auto.

assert(exists P T : Tpoint,
       Cong D' P D' D /\ Perp D' B P D' /\ Col D' B T /\ TS D' B C P).
apply(l8_21_bis D' B C D' D); auto.
intro.
subst D.
apply HCol2.
Col.
intro.
apply HCol1.
ColR.
ex_and H4 P.
ex_and H5 T.

assert(Perp D' B D D').
apply perp_left_comm.
apply(perp_col _ A); Perp.
Col.

assert(Per B D' D).
apply perp_in_per.
apply perp_perp_in in H8.
Perp.


assert(Per B D' P).
apply perp_in_per.
apply perp_perp_in in H5.
Perp.
assert(Col D P D').
apply (per_per_col _ _ B); Perp.
assert(D = P \/ Midpoint D' D P).
apply(l7_20 D' D P); finish.
apply invert_two_sides in H7.

assert(TS A B C P).
apply(col_preserves_two_sides B D' A B C P); Col.

induction H12.
subst P.
right.
apply l9_9 in H13.
assumption.
left.

assert(TS A B D P).
unfold Midpoint in H12.
spliter.
repeat split; Col.
apply per_not_col in H10; auto.
intro.
apply H10.
ColR.
intro.
subst P.
apply cong_identity in H14.
subst D'.
apply perp_distinct in H8.
tauto.
exists D'.
split; Col.
apply(l9_8_1 A B C D P);auto.
Qed.
ex_sym
Proof.
    intros.
    induction (Col_dec A B X).
      exists X.
      split.
        right.
        reflexivity.
      exists X.
      split.
        assumption.
      apply l7_3_2.
    assert (exists M, Col A B M /\ Perp A B X M).
      apply l8_18_existence.
      assumption.
    ex_and H0 M0.
    double X M0 Z.
    exists Z.
    split.
      left.
      apply perp_sym.
      eapply perp_col.
        intro.
        subst Z.
        apply l7_3 in H2.
        subst X.
        apply perp_distinct in H1.
        spliter.
        absurde.
        apply perp_sym.
        apply H1.
      unfold Col.
      left.
      apply midpoint_bet.
      assumption.
    exists M0.
    split.
      assumption.
    assumption.
Qed.
is_image_is_image_spec
Proof.
    intros.
    unfold Reflect.
    tauto.
Qed.
ex_sym1
Proof.
    intros.
    induction (Col_dec A B X).
      exists X.
      split.
        right.
        reflexivity.
      exists X.
      rewrite -> (is_image_is_image_spec) by apply H.
      split.
        assumption.
      split.
        apply l7_3_2.
      unfold ReflectL.
      split.
        exists X.
        split.
          apply l7_3_2.
        assumption.
      right.
      reflexivity.
    assert (exists M, Col A B M /\ Perp A B X M).
      apply l8_18_existence.
      assumption.
    ex_and H1 M0.
    double X M0 Z.
    exists Z.
    split.
      left.
      apply perp_sym.
      eapply perp_col.
        intro.
        subst Z.
        apply l7_3 in H3.
        subst X.
        apply perp_distinct in H2.
        spliter.
        absurde.
        apply perp_sym.
        apply H2.
      unfold Col.
      left.
      apply midpoint_bet.
      assumption.
    exists M0.
    split.
      assumption.
    split.
      assumption.
    rewrite -> (is_image_is_image_spec) by apply H.
    unfold ReflectL.
    split.
      exists M0.
      split.
        apply l7_2.
        assumption.
      assumption.
    left.
    apply perp_sym.
    apply perp_left_comm.
    eapply perp_col.
      intro.
      subst X.
      apply l7_3 in H3.
      subst Z.
      apply perp_distinct in H2.
      spliter.
      absurde.
      apply perp_sym.
      apply H2.
    unfold Col.
    left.
    apply midpoint_bet.
    assumption.
Qed.
l10_2_uniqueness
Proof.
    intros.
    induction (eq_dec_points A B).
      subst.
      unfold Reflect in *.
      induction H.
        intuition.
      induction H0.
        intuition.
      spliter.
      eapply symmetric_point_uniqueness with P B;auto.
    rewrite -> (is_image_is_image_spec) in * by apply H1.
    unfold ReflectL in *.
    spliter.
    ex_and H X.
    ex_and H0 Y.
    induction H2; induction H3.
      assert (P <> X).
        intro.
        subst X.
        apply is_midpoint_id in H.
        subst P1.
        apply perp_distinct in H3.
        spliter.
        absurde.
      assert (P <> Y).
        intro.
        subst Y.
        apply is_midpoint_id in H0.
        subst P2.
        apply perp_distinct in H2.
        spliter.
        absurde.
      assert (Perp P X A B).
        eapply perp_col.
          assumption.
          apply perp_sym.
          apply H3.
        unfold Col.
        right; left.
        apply midpoint_bet.
        apply l7_2.
        assumption.
      assert (Perp P Y A B).
        eapply perp_col.
          assumption.
          apply perp_sym.
          apply H2.
        unfold Col.
        right; left.
        apply midpoint_bet.
        apply l7_2.
        assumption.
      induction (eq_dec_points X A).
        subst X.
        assert (~ Col A B P /\ Per P A B).
          eapply l8_16_1.
            assumption.
            apply col_trivial_3.
            apply col_trivial_2.
            auto.
          apply perp_sym.
          assumption.
        spliter.
        assert (Y = A).
          eapply l8_18_uniqueness.
            apply H10.
            assumption.
            apply perp_sym.
            assumption.
            apply col_trivial_3.
          apply perp_sym.
          assumption.
        subst Y.
        eapply symmetric_point_uniqueness.
          apply H.
        apply H0.
      assert (~ Col A B P /\ Per P X A).
        eapply l8_16_1.
          assumption.
          assumption.
          apply col_trivial_3.
          auto.
        apply perp_sym.
        assumption.
      spliter.
      assert (Y = X).
        eapply l8_18_uniqueness.
          apply H11.
          assumption.
          apply perp_sym.
          assumption.
          assumption.
        apply perp_sym.
        assumption.
      subst Y.
      eapply symmetric_point_uniqueness.
        apply H.
      apply H0.
      subst P1.
      assert (P <> Y).
        intro.
        subst Y.
        apply l7_3 in H.
        subst X.
        apply is_midpoint_id in H0.
        subst P2.
        eapply perp_distinct in H2.
        spliter.
        absurde.
      assert (Perp P Y A B).
        eapply perp_col.
          assumption.
          apply perp_sym.
          apply H2.
        unfold Col.
        right; left.
        apply midpoint_bet.
        apply l7_2.
        assumption.
      apply l7_3 in H.
      subst X.
      induction (eq_dec_points Y A).
        subst Y.
        assert (~ Col A B P /\ Per P A B).
          eapply l8_16_1.
            assumption.
            assumption.
            apply col_trivial_2.
            auto; auto.
          apply perp_sym.
          assumption.
        spliter.
        contradiction.
      assert (~ Col A B P /\ Per P Y A).
        eapply l8_16_1.
          assumption.
          assumption.
          apply col_trivial_3.
          auto.
        apply perp_sym.
        assumption.
      spliter.
      contradiction.
      subst P2.
      assert (P <> X).
        intro.
        subst X.
        apply l7_3 in H0.
        subst Y.
        apply is_midpoint_id in H.
        subst P1.
        eapply perp_distinct in H3.
        spliter.
        absurde.
      assert (Perp P X A B).
        eapply perp_col.
          assumption.
          apply perp_sym.
          apply H3.
        unfold Col.
        right; left.
        apply midpoint_bet.
        apply l7_2.
        assumption.
      apply l7_3 in H0.
      subst Y.
      induction (eq_dec_points X A).
        subst X.
        assert (~ Col A B P /\ Per P A B).
          eapply l8_16_1.
            assumption.
            assumption.
            apply col_trivial_2.
            auto.
          apply perp_sym.
          assumption.
        spliter.
        contradiction.
      assert (~ Col A B P /\ Per P X A).
        eapply l8_16_1.
          assumption.
          assumption.
          apply col_trivial_3.
          auto.
        apply perp_sym.
        assumption.
      spliter.
      contradiction.
    subst P1.
    subst P2.
    reflexivity.
Qed.
l10_2_uniqueness_spec
Proof.
    intros A B P P1 P2 HP1 HP2.
    assert (HR1 := HP1).
    assert (HR2 := HP2).
    destruct HR1 as [HX1 [HPerp|Heq1]].
      assert_diffs; apply (l10_2_uniqueness A B P); apply is_image_is_image_spec; assumption.
    destruct HR2 as [HX2 [HPerp|Heq2]].
      assert_diffs; apply (l10_2_uniqueness A B P); apply is_image_is_image_spec; assumption.
   congruence.
Qed.
l10_2_existence_spec
Proof.
    intros.
    induction (Col_dec A B P).
      unfold ReflectL.
      exists P.
      split.
        exists P.
        split.
          apply l7_3_2.
        assumption.
      right.
      reflexivity.
    assert (exists X, Col A B X /\ Perp A B P X).
      eapply l8_18_existence.
      assumption.
    ex_and H0 X.
    double P X P'.
    exists P'.
    unfold ReflectL.
    split.
      exists X.
      split; assumption.
    left.
    apply perp_sym.
    eapply perp_col.
      intro.
      subst P'.
      apply l7_3 in H2.
      subst X.
      apply perp_distinct in H1.
      spliter.
      absurde.
      apply perp_sym.
      apply H1.
    unfold Col.
    left.
    apply midpoint_bet.
    assumption.
Qed.
l10_2_existence
Proof.
    intros.
    induction (eq_dec_points A B).
      subst B.
      unfold Reflect.
      elim (symmetric_point_construction P A).
      intros P'.
      exists P'.
      tauto.
    elim (l10_2_existence_spec A B P).
    intros P'; intros.
    exists P'.
    unfold Reflect.
    tauto.
Qed.
l10_4_spec
Proof.
    intros.
    unfold ReflectL in *.
    spliter.
    ex_and H X.
    split.
      exists X.
      split.
        apply l7_2.
        assumption.
      assumption.
    induction H0.
      left.
      apply perp_right_comm.
      assumption.
    auto.
Qed.
l10_4
Proof.
    intros.
    induction (eq_dec_points A B).
      subst B.
      unfold Reflect in *.
      elim H;intros.
        intuition.
      right.
      spliter.
      split.
        assumption.
      apply l7_2.
      assumption.
    rewrite -> (is_image_is_image_spec) in * by apply H0.
    apply l10_4_spec;auto.
Qed.
l10_5
Proof.
    intros.
    induction (eq_dec_points A B).
      unfold Reflect in *.
      subst.
      induction H.
        intuition.
      induction H0.
        intuition.
      spliter.
      apply symmetric_point_uniqueness with P' B.
        apply l7_2.
        assumption.
      assumption.
    rewrite -> (is_image_is_image_spec) in * by apply H1.
    eapply l10_2_uniqueness.
      eapply l10_4.
      apply is_image_is_image_spec.
        apply H1.
      apply H.
    apply is_image_is_image_spec.
      assumption.
    assumption.
Qed.
l10_6_uniqueness
Proof.
    intros.
    induction (eq_dec_points A B).
      subst.
      unfold Reflect in *.
      induction H.
        intuition.
      induction H0.
        intuition.
      spliter.
      apply symmetric_point_uniqueness with P B.
        apply l7_2.
        assumption.
      apply l7_2.
      assumption.
    eapply l10_2_uniqueness.
      apply l10_4.
      apply H.
    apply l10_4.
    assumption.
Qed.
l10_6_uniqueness_spec
Proof.
    intros A B P P1 P2 HP1 HP2.
    assert (HR1 := HP1).
    assert (HR2 := HP2).
    destruct HR1 as [HX1 [HPerp|Heq1]].
      assert_diffs; apply (l10_6_uniqueness A B P); apply is_image_is_image_spec; assumption.
    destruct HR2 as [HX2 [HPerp|Heq2]].
      assert_diffs; apply (l10_6_uniqueness A B P); apply is_image_is_image_spec; assumption.
    subst; reflexivity.
Qed.
l10_6_existence_spec
Proof.
    intros.
    assert (exists P, ReflectL P P' A B).
      eapply l10_2_existence_spec.
    ex_and H0 P.
    exists P.
    apply l10_4_spec.
    assumption.
Qed.
l10_6_existence
Proof.
    intros.
    assert (exists P, Reflect P P' A B).
      eapply l10_2_existence.
    ex_and H P.
    exists P.
    apply l10_4.
    assumption.
Qed.
l10_7
Proof.
    intros.
    subst Q'.
    eapply l10_2_uniqueness.
      apply l10_4.
      apply H.
    apply l10_4.
    assumption.
Qed.
l10_8
Proof.
    intros.
    induction (eq_dec_points A B).
      subst;Col.
    unfold Reflect in H.
    unfold ReflectL in H.
    induction H.
      spliter.
      ex_and H1 X.
      apply l7_3 in H1.
      subst X.
      Col.
    spliter. subst. Col.
Qed.
col__refl
Proof.
    intros A B P HCol.
    split.
      exists P; repeat split; finish; Between.
    right; reflexivity.
Qed.
is_image_col_cong
Proof.
    intros.
    rewrite is_image_is_image_spec in H0 by apply H.
    unfold ReflectL in *.
    spliter.
    ex_and H0 M0.
    induction H2.
      assert (HH:= H2).
      apply perp_distinct in HH.
      spliter.
      induction (eq_dec_points M0 X).
        subst X.
        unfold Midpoint in *.
        spliter.
        Cong.
      assert (Perp M0 X P' P).
        eapply perp_col2;eauto.
      assert(~ Col A B P /\ Per P M0 X).
        eapply l8_16_1.
          assumption.
          assumption.
          assumption.
          auto.
        apply perp_sym.
        eapply perp_col.
          intro.
          subst P.
          apply l7_2 in H0.
          apply is_midpoint_id in H0.
          subst P'.
          absurde.
          apply perp_left_comm.
          apply perp_sym.
          apply H2; eapply perp_left_comm.
        unfold Col.
        right; left.
        apply midpoint_bet.
        assumption.
      spliter.
      eapply l8_2 in H9.
      unfold Per in H9.
      ex_and H9 P0.
      assert (P0 = P').
        eapply symmetric_point_uniqueness.
          apply H9.
        apply l7_2.
        assumption.
      subst P0.
      apply cong_commutativity.
      assumption.
    subst P'.
    apply cong_reflexivity.
Qed.
is_image_spec_col_cong
Proof.
    intros.
    unfold ReflectL in *.
    spliter.
    ex_and H M0.
    induction H1.
      assert (HH:= H1).
      apply perp_distinct in HH.
      spliter.
      induction (eq_dec_points M0 X).
        subst X.
        unfold Midpoint in *.
        spliter.
        Cong.
      assert (Perp M0 X P' P) by (eauto using perp_col2).
      assert(~ Col A B P /\ Per P M0 X).
        eapply l8_16_1.
          assumption.
          assumption.
          assumption.
          auto.
        apply perp_sym.
        eapply perp_col.
          intro.
          subst P.
          apply l7_2 in H.
          apply is_midpoint_id in H.
          subst P'.
          absurde.
          apply perp_left_comm.
          apply perp_sym.
          apply H1; eapply perp_left_comm.
        unfold Col.
        right; left.
        apply midpoint_bet.
        assumption.
      spliter.
      eapply l8_2 in H8.
      unfold Per in H8.
      ex_and H8 P0.
      assert (P0 = P').
        eapply symmetric_point_uniqueness.
          apply H8.
        apply l7_2.
        assumption.
      subst P0.
      Cong.
    subst.
    Cong.
Qed.
image_id
Proof.
    intros.
    rewrite is_image_is_image_spec in H1 by apply H.
    unfold ReflectL in H1.
    spliter.
    ex_and H1 X.
    induction H2.
      assert (A <> B /\ T' <> T).
        apply perp_distinct in H2.
        spliter.
        split; assumption.
      spliter.
      induction (eq_dec_points A X).
        subst X.
        assert (Perp A B T' A).
          apply perp_sym.
          eapply perp_col.
            intro.
            subst T'.
            apply is_midpoint_id in H1.
            subst A.
            absurde.
            apply perp_sym.
            apply H2.
          unfold Col.
          right; left.
          apply midpoint_bet.
          apply l7_2.
          assumption.
        assert (~ Col  A T' B).
          apply perp_not_col.
          apply perp_comm.
          apply perp_sym.
          assumption.
        assert (A = T).
          apply l6_21 with A T' B T; assert_cols; Col.
          intro; treat_equalities; Col.
        subst A.
        apply l7_2 in H1.
        apply is_midpoint_id in H1.
        subst T'.
        absurde.
      induction (eq_dec_points B X).
        subst X.
        assert (Perp A B T' B).
          apply perp_sym.
          eapply perp_col.
            intro.
            subst T'.
            apply is_midpoint_id in H1.
            subst B.
            absurde.
            apply perp_sym.
            apply H2.
          unfold Col.
          right; left.
          apply midpoint_bet.
          apply l7_2.
          assumption.
        assert (~ Col  B T' A).
          apply perp_not_col.
          apply perp_left_comm.
          apply perp_sym.
          assumption.
        assert (B = T).
          eapply l6_21.
            apply H8.
            apply H4.
            apply col_trivial_3.
            unfold Col.
            right; right.
            apply midpoint_bet.
            apply l7_2.
            apply H1.
            apply col_trivial_2.
            assumption.
        subst B.
        apply l7_2 in H1.
        apply is_midpoint_id in H1.
        subst T'.
        absurde.
      assert (Col A X T) by ColR.
      assert (Perp A B T' X).
        apply perp_sym.
        eapply perp_col.
          intro.
          subst T'.
          apply is_midpoint_id in H1.
          subst X.
          absurde.
          apply perp_sym.
          apply H2.
        assert_cols.
        Col.
      assert (~ Col  X T' A).
        apply perp_not_col.
        apply perp_left_comm.
        apply perp_sym.
        eapply perp_col.
          assumption.
          apply H9.
        assumption.
      assert (X = T).
        eapply l6_21.
          apply H10.
          apply H6.
          apply col_trivial_3.
          unfold Col.
          right; right.
          apply midpoint_bet.
          apply l7_2.
          apply H1.
          apply col_trivial_2.
          assumption.
      subst X.
      apply l7_2 in H1.
      apply is_midpoint_id in H1.
      subst T'.
      absurde.
    subst T'.
    reflexivity.
Qed.
osym_not_col
Proof.
    intros.
    unfold Reflect in *.
    induction H.
      spliter.
      assert ( HH:= H1).
      unfold ReflectL in HH.
      spliter.
      ex_and H2 T.
      intro.
      induction H3.
        assert (P'=P).
          eapply image_id.
            apply H.
            assumption.
          apply l10_4.
          apply is_image_is_image_spec.
            assumption.
          assumption.
        subst P'.
        apply perp_distinct in H3.
        spliter.
        absurde.
      apply H0.
      subst P'.
      assumption.
    spliter. subst. Col5.
Qed.
midpoint_preserves_image
Proof.
    intros.
    rewrite is_image_is_image_spec in * by apply H.
    assert (HH1:=H1).
    unfold ReflectL in H1.
    spliter.
    ex_and H1 X.
    induction H4.
      double X M Y.
      assert (Midpoint Y Q Q').
        eapply symmetry_preserves_midpoint.
          apply H2.
          apply H6.
          apply H3.
        apply l7_2.
        apply H1.
      assert (P <> P').
        intro.
        subst P'.
        apply perp_distinct in H4.
        spliter.
        absurde.
      assert (Q <> Q').
        intro.
        subst Q'.
        apply l7_3 in H7.
        subst Q.
        assert (P=P').
          eapply l7_9.
            apply H2.
          apply H3.
        subst P'.
        apply perp_distinct in H4.
        spliter.
        absurde.
      split.
        exists Y.
        split.
          apply l7_2.
          apply H7.
        induction (eq_dec_points X Y).
          subst Y.
          assumption.
        assert_diffs.
        ColR.
      left.
      assert(Per M Y Q).
        unfold Per.
        exists Q'.
        split.
          assumption.
        unfold Midpoint in *.
        spliter.
        eapply cong_transitivity.
          apply cong_symmetry.
          apply H14.
        apply cong_symmetry.
        eapply cong_transitivity.
          apply cong_symmetry.
          apply H13.
        eapply is_image_col_cong.
          apply H.
          apply l10_4.
          apply is_image_is_image_spec.
            assumption.
          apply HH1.
        assumption.
      induction (eq_dec_points X Y).
        subst Y.
        apply l7_3 in H6.
        subst X.
        apply perp_sym.
        eapply perp_col.
          auto.
          apply perp_left_comm.
          eapply perp_col.
            2:apply perp_sym.
            2:apply H4.
            intro.
            subst Q'.
            apply l7_3 in H3.
            subst P'.
            apply is_midpoint_id in H1.
            subst P.
            absurde.
          eapply (col_transitivity_2 M).
            intro.
            subst P'.
            apply is_midpoint_id in H1.
            subst P.
            absurde.
            unfold Col.
            right; right.
            apply midpoint_bet.
            apply l7_2.
            assumption.
          unfold Col.
          right; right.
          apply midpoint_bet.
          apply l7_2.
          assumption.
        eapply (col_transitivity_2 M).
          intro.
          subst Q'.
          apply l7_2 in H7.
          apply is_midpoint_id in H7.
          subst Q.
          absurde.
          unfold Col.
          right; right.
          apply midpoint_bet.
          assumption.
        unfold Col.
        right; right.
        apply midpoint_bet.
        assumption.
      apply per_perp_in in H10.
        apply perp_in_perp_bis in H10.
        induction H10.
          apply perp_distinct in H10.
          spliter.
          absurde.
        apply perp_comm.
        apply perp_sym.
        eapply perp_col.
          assumption.
          apply perp_comm.
          eapply (perp_col  Y Q).
            intro.
            subst Q.
            apply perp_distinct in H10.
            spliter.
            absurde.
            apply perp_sym.
            induction (eq_dec_points A M).
              subst A.
              apply perp_left_comm.
              eapply (perp_col _ M).
                auto.
                apply perp_left_comm.
                eapply (perp_col _ Y).
                  assumption.
                  assumption.
                induction (eq_dec_points M X).
                  subst X.
                  apply is_midpoint_id in H6.
                  subst M.
                  apply col_trivial_1.
                eapply (col_transitivity_1 _ X).
                  assumption.
                  unfold Col.
                  right; right.
                  apply midpoint_bet.
                  apply l7_2.
                  assumption.
                apply col_permutation_5.
                assumption.
              apply col_trivial_2.
            induction (eq_dec_points B M).
              subst M.
              apply perp_left_comm.
              apply (perp_col _ Y).
                auto.
                assumption.
              induction (eq_dec_points B X).
                subst X.
                apply is_midpoint_id in H6.
                subst Y.
                absurde.
              eapply col_transitivity_1.
                apply H13.
                unfold Col.
                right; right.
                apply midpoint_bet.
                apply l7_2.
                assumption.
              apply col_permutation_1.
              assumption.
            eapply perp_col.
              assumption.
              apply perp_left_comm.
              eapply (perp_col M Y).
                auto.
                assumption.
              assert(Col B X M).
                eapply col_transitivity_2.
                  apply H.
                  assumption.
                assumption.
              induction (eq_dec_points M X).
                subst X.
                apply is_midpoint_id in H6.
                contradiction.
              assert(Col B Y M).
                apply col_permutation_1.
                eapply (col_transitivity_2  X).
                  auto.
                  apply col_permutation_1.
                  assumption.
                unfold Col.
                left.
                apply midpoint_bet.
                assumption.
              eapply (col_transitivity_1 _ B).
                auto.
                apply col_permutation_2.
                assumption.
              apply col_permutation_3.
              apply H0.
            apply col_permutation_5.
            apply H0.
          apply col_trivial_2.
        unfold Col.
        left.
        apply midpoint_bet.
        apply H7.
        intro.
        subst Y.
        apply l7_2 in H6.
        apply is_midpoint_id in H6.
        subst X.
        absurde.
      intro.
      subst Q.
      apply is_midpoint_id in H7.
      subst Q'.
      absurde.
    subst P'.
    apply l7_3 in H1.
    subst P.
    assert(Q = Q').
      eapply l7_9.
        apply l7_2.
        apply H2.
      apply l7_2.
      apply H3.
    subst Q'.
    split.
      exists Q.
      split.
        apply l7_3_2.
      induction (eq_dec_points M X).
        subst X.
        assert(M=Q).
          apply is_midpoint_id.
          assumption.
        subst Q.
        assumption.
      ColR.
    right.
    reflexivity.
Qed.
image_in_is_image_spec
Proof.
    intros.
    unfold ReflectL_at in H.
    spliter.
    unfold ReflectL.
    split.
      exists M.
      split; assumption.
    assumption.
Qed.
image_in_gen_is_image
Proof.
    intros.
    unfold Reflect_at in H.
    induction H.
      spliter.
      apply image_in_is_image_spec in H0.
      unfold Reflect.
      tauto.
    spliter.
    subst.
    subst.
    unfold Reflect.
    right.
    auto.
Qed.
image_image_in
Proof.
    intros.
    unfold ReflectL_at.
    split.
      split.
        assert(HH:=H0).
        unfold ReflectL in H0.
        spliter.
        ex_and H0 M'.
        induction H3.
          assert (Perp P M' A B).
            eapply perp_col.
              intro.
              subst P.
              apply l7_2 in H0.
              apply is_midpoint_id in H0.
              subst P'.
              apply perp_distinct in H3.
              spliter.
              absurde.
              apply perp_sym.
              apply perp_right_comm.
              apply H3.
            unfold Col.
            right; left.
            apply midpoint_bet.
            assumption.
          assert (M'=M).
            eapply l6_21.
              2: apply H.
              2: apply H4.
              induction (eq_dec_points A M').
                subst M'.
                assert (~ Col A B P /\ Per P A B).
                  eapply l8_16_1.
                    apply perp_distinct in H3.
                    spliter.
                    assumption.
                    apply col_trivial_3.
                    apply col_trivial_2.
                    apply perp_distinct in H3.
                    spliter.
                    auto.
                  apply perp_sym.
                  assumption.
                spliter.
                intro.
                apply H6.
                assumption.
              assert (~ Col A B P /\ Per P M' A).
                eapply l8_16_1.
                  apply perp_distinct in H3.
                  spliter.
                  assumption.
                  assumption.
                  apply col_trivial_3.
                  assumption.
                apply perp_sym.
                assumption.
              spliter.
              intro.
              apply H7.
              assumption.
              assumption.
              unfold Col.
              right; left.
              apply midpoint_bet.
              apply H0.
              apply col_permutation_5.
              assumption.
            apply perp_distinct in H3.
            spliter.
            auto.
          subst M'.
          assumption.
        subst P'.
        absurde.
      assumption.
    assert (HH:=H0).
    unfold ReflectL in H0.
    spliter.
    induction H3.
      left.
      assumption.
    right.
    assumption.
Qed.
image_in_col0
Proof.
    intros.
    unfold ReflectL_at in *.
    spliter.
    assert_cols.
    Col.
Qed.
is_image_spec_rev
Proof.
    unfold ReflectL.
    intros.
    spliter.
    split.
      ex_and H M0.
      exists M0.
      split.
        assumption.
      apply col_permutation_4.
      assumption.
    induction H0.
      left.
      apply perp_left_comm.
      assumption.
    right.
    assumption.
Qed.
is_image_rev
Proof.
    intros.
    unfold Reflect in *.
    induction H.
      spliter.
      left.
      split.
        auto.
      apply is_image_spec_rev.
      assumption.
    right.
    spliter. subst. tauto.
Qed.
midpoint_preserves_per
Proof.
    intros.
    unfold Per in *.
    ex_and H C'.
    double C' M C1'.
    exists C1'.
    split.
      eapply symmetry_preserves_midpoint.
        apply H2.
        apply H1.
        apply H4.
      assumption.
    eapply l7_16.
      apply H0.
      apply H2.
      apply H0.
      apply H4.
    assumption.
Qed.
image_col
Proof.
    intros.
    unfold ReflectL.
    split.
      exists X.
      split.
        apply l7_3_2.
      assumption.
    right.
    reflexivity.
Qed.
is_image_spec_triv
Proof.
    intros.
    apply image_col.
    Col.
Qed.
is_image_spec_dec
Proof.
    intros.
    elim (eq_dec_points C D); intro HCD.
      subst.
      elim (eq_dec_points A B); intro HAB.
        subst.
        left.
        apply is_image_spec_triv.
      right.
      intro H.
      unfold ReflectL in *.
      destruct H as [H HFalse].
      elim HFalse; clear HFalse; intro HFalse.
        apply perp_distinct in HFalse.
        intuition.
      intuition.
    elim (l10_6_existence_spec C D A HCD); intros B' HB'.
    elim (eq_dec_points B B'); intro HBB'.
      subst.
      tauto.
    right.
    intro H.
    apply HBB'.
    apply l10_6_uniqueness with C D A.
      unfold Reflect.
      tauto.
    unfold Reflect.
    tauto.
Qed.
l10_14
Proof.
    intros.
    rewrite is_image_is_image_spec in H1 by apply H0.
    unfold ReflectL in H1.
    spliter.
    ex_and H1 M0.
    induction H2.
      assert (P <> M0).
        intro.
        subst P.
        apply l7_2 in H1.
        apply is_midpoint_id in H1.
        subst P'.
        absurde.
      induction (eq_dec_points A M0).
        subst A.
        assert (Perp M0 B P M0).
          apply perp_sym.
          eapply (perp_col _ P').
            assumption.
            apply perp_sym.
            apply perp_right_comm.
            apply H2.
          unfold Col.
          right; left.
          apply midpoint_bet.
          assumption.
        assert (Perp_at M0 M0 B P M0).
          eapply perp_perp_in.
          assumption.
        assert(Per B M0 P).
          eapply perp_in_per.
          apply perp_in_comm.
          assumption.
        assert (B <> M0).
          intro.
          repeat split.
          subst B.
          apply perp_distinct in H2.
          spliter.
          absurde.
        assert (~Col B M0 P).
          eapply per_not_col.
            assumption.
            auto.
          assumption.
        repeat split.
          auto.
          intro.
          apply H9.
          Col.
          intro.
          apply H9.
          apply col_permutation_2.
          eapply (col_transitivity_1 _ P').
            intro.
            subst P'.
            apply is_midpoint_id in H1.
            subst P.
            absurde.
            unfold Col.
            right; right.
            apply midpoint_bet.
            apply l7_2.
            assumption.
          apply col_permutation_4.
          assumption.
        exists M0.
        split.
          apply col_trivial_1.
        apply midpoint_bet.
        apply l7_2.
        assumption.
      induction (eq_dec_points B M0).
        subst B.
        assert (Perp M0 A P M0).
          apply perp_sym.
          eapply (perp_col _ P').
            assumption.
            apply perp_sym.
            apply perp_comm.
            apply H2.
          unfold Col.
          right; left.
          apply midpoint_bet.
          assumption.
        assert (Perp_at M0 M0 A P M0).
          eapply perp_perp_in.
          assumption.
        assert(Per A M0 P).
          eapply perp_in_per.
          apply perp_in_comm.
          assumption.
        repeat split.
          assert (~Col A M0 P).
            eapply per_not_col.
              assumption.
              auto.
            assumption.
          intro.
          apply H9.
          apply col_permutation_1.
          assumption.
          intro.
          assert (Col M0 A P).
            eapply (col_transitivity_1 _ P').
              intro.
              subst P'.
              apply is_midpoint_id in H1.
              subst P.
              absurde.
              apply col_permutation_2.
              assumption.
            unfold Col.
            right; right.
            apply midpoint_bet.
            apply l7_2.
            assumption.
          eapply (per_not_col ).
            3: apply H8.
            assumption.
            auto.
          apply col_permutation_4.
          assumption.
        exists M0.
        split.
          apply col_trivial_3.
        apply midpoint_bet.
        apply l7_2.
        assumption.
      repeat split.
        assert(Perp  P M0 A B).
          eapply perp_col.
            assumption.
            apply perp_sym.
            apply perp_right_comm.
            apply H2.
          unfold Col.
          right; left.
          apply midpoint_bet.
          assumption.
        assert (~ Col M0 P A).
          apply perp_not_col.
          apply perp_sym.
          eapply perp_col.
            assumption.
            apply perp_sym.
            apply perp_left_comm.
            apply H7.
          assumption.
        intro.
        apply H8.
        apply col_permutation_1.
        eapply col_transitivity_1.
          apply perp_distinct in H2.
          spliter.
          apply H2.
          assumption.
        apply col_permutation_1.
        assumption.
        assert(Perp  P' M0 A B).
          eapply perp_col.
            intro.
            subst P'.
            apply is_midpoint_id in H1.
            subst P.
            absurde.
            apply perp_sym.
            apply H2.
          unfold Col.
          right; left.
          apply midpoint_bet.
          apply l7_2.
          assumption.
        assert (~ Col M0 P' A).
          apply perp_not_col.
          apply perp_sym.
          eapply perp_col.
            assumption.
            apply perp_sym.
            apply perp_left_comm.
            apply H7.
          assumption.
        intro.
        apply H8.
        apply col_permutation_1.
        eapply col_transitivity_1.
          apply perp_distinct in H2.
          spliter.
          apply H2.
          assumption.
        apply col_permutation_1.
        assumption.
      exists M0.
      split.
        apply col_permutation_2.
        assumption.
      apply midpoint_bet.
      apply l7_2.
      assumption.
    subst P'.
    absurde.
Qed.
l10_15
Proof.
    intros.
    assert (A<>B).
      intro;subst.
      Col.
    assert (exists X , TS A B P X).
      apply l9_10.
        assumption.
      intro.
      apply H0.
      apply col_permutation_1.
      assumption.
    ex_elim H2 X.
    induction (eq_dec_points A C).
      subst C.
      assert (exists Q, exists T, Perp A B Q A /\ Col A B T /\ Bet X T Q).
        apply l8_21.
        assumption.
      ex_elim H2 Q.
      ex_and H4 T.
      exists Q.
      split.
        assumption.
      eapply l9_8_1.
        apply H3.
      unfold TS.
      repeat split.
        apply perp_not_col in H2.
        intro.
        apply H2.
        apply col_permutation_1.
        assumption.
        unfold TS in H3.
        spliter.
        assumption.
      exists T.
      split.
        apply col_permutation_2.
        assumption.
      apply between_symmetry.
      assumption.
    assert (exists Q, exists T, Perp C A Q C /\ Col C A T /\ Bet X T Q).
      apply l8_21.
      auto.
    ex_elim H4 Q.
    ex_and H5 T.
    exists Q.
    split.
      eapply perp_col.
        assumption.
        apply perp_left_comm.
        apply H4.
      apply col_permutation_5.
      assumption.
    eapply l9_8_1.
      apply H3.
    unfold TS.
    repeat split.
      eapply perp_not_col in H4.
      intro.
      apply H4.
      apply col_permutation_2.
      eapply col_transitivity_1.
        apply H1.
        apply col_permutation_1.
        assumption.
      assumption.
      unfold TS in H3.
      spliter.
      assumption.
    exists T.
    split.
      apply col_permutation_2.
      eapply col_transitivity_1.
        apply H2.
        apply col_permutation_5.
        assumption.
      apply col_permutation_4.
      assumption.
    apply between_symmetry.
    assumption.
Qed.
perp_exists
Proof.
    intros.
    assert(HH:=not_col_exists A B H).
    ex_and HH Q.
    induction(Col_dec O A B).
      assert(exists P, Perp A B P O /\ OS A B Q P).
        apply(l10_15 A B O Q ).
          Col.
        auto.
      ex_and H2 P.
      exists P.
      apply perp_sym.
      apply perp_right_comm.
      auto.
    assert(exists P : Tpoint, Col A B P /\ Perp A B O P).
      apply (l8_18_existence A B O).
      intro.
      apply H1.
      Col.
    ex_and H2 P.
    exists P.
    apply perp_sym.
    auto.
Qed.
perp_vector
Proof.
intros.
exists A.
destruct (perp_exists A A B) as [Y]; auto.
exists Y; Perp.
Qed.
ex_per_cong
Proof.
    intros A B C D X Y HAB HXY HCol HNCol.
    destruct (l10_15 A B C D) as [Q [HQ1 HQ2]]; trivial.
    assert_diffs.
    destruct (segment_construction_3 C Q X Y) as [P [HP1 HP2]]; auto.
    exists P; repeat split; Cong.
    - destruct (eq_dec_points A C).
        subst; Perp.
      apply perp_per_1.
      apply perp_col1 with B; auto.
      assert_diffs; apply perp_sym, perp_col1 with Q; Col; Perp.
    - apply os_out_os with Q C; Side.
Qed.
exists_cong_per
Proof.
intros.
destruct (eq_dec_points A B).
subst.
destruct (segment_construction X B X Y).
exists x;split;spliter;finish.
destruct (not_col_exists A B H) as [P HP].
destruct (eq_dec_points X Y).
exists B;split;subst;finish.
destruct (ex_per_cong A B B P X Y);finish.
spliter.
exists x;split;finish.
Qed.
l11_3
Proof.
    intros.
    unfold CongA in H.
    spliter.
    ex_and H3 A'.
    ex_and H4 C'.
    ex_and H3 D'.
    ex_and H4 F'.
    exists A'.
    exists C'.
    exists D'.
    exists F'.
    assert_diffs.
    repeat split;finish.
      apply cong_left_commutativity.
      eapply l2_11 with A D;finish.
    apply cong_left_commutativity.
    eapply l2_11; eBetween; Cong.
Qed.
l11_aux
Proof.
    intros.
    assert (A <> B).
      unfold Out in H.
      spliter.
      assumption.
    assert(Cong B A0 E D0).
      apply cong_right_commutativity.
      apply l2_11 with A D;finish.
    split.
      apply H7.
    unfold Out in *.
    spliter.
    induction H9; induction H11.
      assert(Bet B A' A0 \/ Bet B A0 A').
        eauto using l5_1.

      induction H12.
        assert(Bet E D' D0).
          eapply cong_preserves_bet.
            2: apply H1.
            apply H12.
            assumption.
          unfold Out.
          repeat split.
            assumption.
            assert_diffs.
            auto.
          eapply l5_1.
            2:apply H9.
            auto.
          assumption.
        apply cong_commutativity.
        eapply l4_3  with B E;finish.
      assert(Bet E D0 D').
        eapply cong_preserves_bet.
          2: apply H7.
          apply H12.
          assumption.
        unfold Out.
        repeat split.
          assert_diffs;auto.
          assert_diffs;auto.
        eapply l5_1.
          2:apply H3.
          auto.
        assumption.
      eapply l4_3 with B E;finish.
      apply cong_commutativity.
      eapply l4_3.
        3:apply cong_commutativity.
        3:apply H7.
        apply between_symmetry.
        eapply between_exchange4.
          apply H11.
        assumption.
        apply between_symmetry.
        eapply cong_preserves_bet.
          2: apply H1.
          2: apply H7.
          eapply between_exchange4.
            apply H11.
          assumption.
        unfold Out.
        repeat split.
          assumption.
          assert_diffs;auto.
        eapply l5_1.
          2:apply H9.
          auto.
        assumption.
      finish.
      apply cong_commutativity.
      eapply l4_3.
        3:apply cong_commutativity.
        3:apply H7.
        apply between_symmetry.
        eapply cong_preserves_bet.
          2:apply cong_symmetry.
          2:apply H1.
          2:apply cong_symmetry.
          2:apply H7.
          eapply between_exchange4.
            apply H9.
          assumption.
        unfold Out.
        repeat split.
          assumption.
          assert_diffs;auto.
        eauto using l5_1.
        apply between_symmetry.
        eapply between_exchange4.
          apply H9.
        assumption.
      finish.
    apply cong_commutativity.
    eapply l4_3.
      3:apply cong_commutativity.
      3:apply H7.
      apply between_symmetry.
      eapply between_exchange4.
        apply H11.
      assumption.
      apply between_symmetry.
      eapply between_exchange4.
        apply H9.
      assumption.
    finish.
Qed.
l11_3_bis
Proof.
    intros.
    unfold CongA.
    ex_and H A'.
    ex_and H0 C'.
    ex_and H D'.
    ex_and H0 F'.
    prolong B A A0 E D.
    prolong B C C0 E F.
    prolong E D D0 B A.
    prolong E F F0 B C.
    assert(HH0:=H0).
    assert(HH1:=H1).
    assert(HH2:=H2).
    assert(HH:=H).
    unfold Out in HH.
    unfold Out in HH0.
    unfold Out in HH1.
    unfold Out in HH2.
    spliter.
    repeat split;try assumption.
    repeat split;try assumption.
    exists A0.
    exists C0.
    exists D0.
    exists F0.
    repeat split; try (assumption).
    unfold Cong_3 in H3.
    spliter.
    assert(Cong B A0 E D0 /\ Cong A' A0 D' D0).
      eapply l11_aux with A D;finish.
    assert(Cong B C0 E F0 /\ Cong C' C0 F' F0).
      eapply l11_aux with C F;finish.
    spliter.
    assert (Cong_3 B A' A0 E D' D0)
      by (repeat split;finish).
    assert (Cong_3 B C' C0 E F' F0)
      by (repeat split;finish).
    assert (Cong C0 A' F0 D').
      apply l4_16 with B C' E F';
        unfold FSC;repeat split;finish;ColR.
    apply l4_16 with B A' E D';
    unfold FSC;repeat split;finish;ColR.
Qed.
l11_4_1
Proof.
    intros.
    assert (HH:=H).
    apply l11_3 in HH.
    unfold CongA in H.
    spliter.
    repeat split; try assumption.
    clear H3.
    intros.
    ex_and HH A0.
    ex_and H4 C0.
    ex_and H10 D0.
    ex_and H4 F0.
    unfold Cong_3 in H13.
    spliter.
    assert (Out B A' A0).
      eapply l6_7.
        apply H3.
      apply l6_6.
      assumption.
    assert (Out E D' D0).
      eapply l6_7.
        apply H6.
      apply l6_6.
      assumption.
    assert(Cong A' A0 D' D0).
      eapply out_cong_cong.
        apply H16.
        apply H17.
        assumption.
      Cong.
    assert (Cong A' C0 D' F0).
      eapply (l4_16 B A0 A' C0 E D0 D' F0).
        unfold FSC.
        repeat split.
          assert_cols;Col.
          Cong.
          assumption.
          Cong.
          assumption.
        assumption.
      intro.
      subst A0.
      unfold Out in H4.
      spliter.
      absurde.
    assert (Out B C' C0).
      eapply l6_7.
        apply H5.
      assumption.
    assert (Out E F' F0).
      eapply l6_7.
        apply H7.
      assumption.
    assert(Cong C' C0 F' F0).
      eapply out_cong_cong.
        3:apply H9.
        assumption.
        assumption.
      assumption.
    apply cong_commutativity.
    eapply (l4_16 B C0 C' A' E F0 F' D').
      unfold FSC.
      repeat split.
        apply out_col.
        apply l6_6.
        assumption.
        assumption.
        assumption.
        Cong.
        assumption.
      Cong.
    intro.
    subst C0.
    unfold Out in H10.
    spliter.
    absurde.
Qed.
l11_4_2
Proof.
    intros.
    spliter.
    apply l11_3_bis.
    prolong B A A' E D.
    prolong B C C' E F.
    prolong E D D' B A.
    prolong E F F' B C.
    exists A'.
    exists C'.
    exists D'.
    exists F'.
    assert(Cong A' B D' E).
     {
      apply cong_right_commutativity.
      eapply l2_11 with A D;finish.
     }
    assert (Cong B C' E F').
      apply cong_right_commutativity.
      eapply l2_11 with C F;finish.
    assert_diffs;repeat split;finish.
    apply H3;repeat split;finish.
Qed.
conga_refl
Proof.
    intros.
    apply l11_3_bis.
    exists A.
    exists C.
    exists A.
    exists C.
    repeat split; finish.
Qed.
conga_sym
Proof.
    unfold CongA.
    intros.
    spliter.
    ex_and H3 A0.
    ex_and H4 C0.
    ex_and H3 D0.
    ex_and H4 F0.
    repeat split; try assumption.
    exists D0.
    exists F0.
    exists A0.
    exists C0.
    repeat split; finish.
Qed.
out_conga
Proof.
    intros.
    apply l11_4_1 in H.
    spliter.
    apply l11_4_2.
    assert_diffs.
    repeat split;try assumption.
    intros.
    spliter.
    apply H7.
    assert_diffs.
    repeat split;finish.
      eapply l6_7 with A0;finish.
      eapply l6_7 with C0;finish.
      eapply l6_7 with A1;finish.
      eapply l6_7 with C1;finish.
Qed.
cong3_diff
Proof.
unfold Cong_3 in *.
intros.
spliter.
assert_diffs.
auto.
Qed.
cong3_diff2:
Proof.
unfold Cong_3 in *.
intros.
spliter.
assert_diffs.
auto.
Qed.
cong3_conga
Proof.
    intros.
    assert (A' <> B') by (eauto using cong3_diff).
    assert (B' <> C') by (eauto using cong3_diff2).
    apply (l11_3_bis A B C A' B' C').
    exists A. exists C. exists A'. exists C'.
    intuition finish.
Qed.
cong3_conga2
Proof.
    intros.
    unfold CongA in H0.
    spliter.
    ex_and H4 A0.
    ex_and H5 C0.
    ex_and H4 A2.
    ex_and H5 C2.
    unfold Cong_3 in H.
    spliter.
    unfold CongA.
    assert_diffs.
    repeat split;try solve [auto].
    prolong B' A' A1 B'' A''.
    prolong B' C' C1 B'' C''.
    exists A1.
    exists C1.
    exists A2.
    exists C2.
    repeat split;try assumption.
      eapply cong_transitivity with B A;finish.
      eapply cong_transitivity with B C;finish.
    assert (Cong A A0 A' A1).
      eapply cong_transitivity with B'' A'';finish.
    assert(Cong B A0 B' A1).
      eapply l2_11 with A A';finish.
    assert (Cong C C0 C' C1).
      eapply cong_transitivity with B'' C'';finish.
    assert(Cong B C0 B' C1).
      eapply l2_11 with C C';finish.
    assert(FSC B A A0 C B' A' A1 C').
      unfold FSC;assert_cols;repeat split;finish.
    assert(Cong A0 C A1 C').
      eauto using l4_16.
    apply cong_commutativity.
    assert(Cong C0 A0 C1 A1).
      eapply (l4_16 B C C0 A0 B' C' C1 A1).
        unfold FSC;assert_cols;repeat split;finish.
      auto.
    apply cong_transitivity with A0 C0; Cong.
Qed.
conga_diff1
Proof.
    intros.
    unfold CongA in H.
    spliter.
    assumption.
Qed.
conga_diff2
Proof.
    intros.
    unfold CongA in H.
    spliter.
    assumption.
Qed.
conga_diff45
Proof.
  intros A B C A' B' C' H.
  apply (conga_diff1 A' B' C' A B C); apply conga_sym; auto.
Qed.
conga_diff56
Proof.
  intros A B C A' B' C' H.
  apply (conga_diff2 A' B' C' A B C); apply conga_sym; auto.
Qed.
conga_trans
Proof.
    intros.
    assert (HH:=H).
    unfold CongA in H.
    spliter.
    ex_and H4 A0.
    ex_and H5 C0.
    ex_and H4 A1.
    ex_and H5 C1.
    assert_diffs.
    assert(A'' <> B'' /\ C'' <> B'').
      unfold CongA in H0.
      spliter.
      split; assumption.
    spliter.
    assert(CongA A1 B' C1 A'' B'' C'')
      by (apply out_conga with A' C' A'' C'';finish).
    assert (CongA A0 B C0 A' B' C')
      by (apply out_conga with A C A' C';finish).
    assert (Cong B A0 B' A1).
      {
      apply cong_right_commutativity.
      apply l2_11 with A A';finish.
      }
    assert (Cong B C0 B' C1).
      {
      apply cong_right_commutativity.
      eapply l2_11 with C C';finish.
      }
    assert (Cong A0 C0 A1 C1).
    {
      apply (l11_4_1) in H24.
      spliter.
      apply H30.
      repeat split;finish.
    }
    assert (Cong_3 A0 B C0 A1 B' C1)
      by (repeat split;finish).
    apply cong3_symmetry in H28.
    assert( CongA A0 B C0 A'' B'' C'')
      by (eauto using cong3_conga2).
    eapply out_conga with A0 C0 A'' C'';finish.
Qed.
conga_pseudo_refl
Proof.
    intros.
    unfold CongA.
    repeat split; try assumption.
    prolong B A A' B C.
    prolong B C C' B A.
    prolong B A A'' B C.
    prolong B C C'' B A.
    exists A'.
    exists C'.
    exists C''.
    exists A''.
    repeat split; try assumption.
    assert (A' = A'') by (eauto using (construction_uniqueness B A)).
    subst A''.
    assert (C' = C'') by (eauto using (construction_uniqueness B C)).
    subst C''.
    Cong.
Qed.
conga_trivial_1
Proof.
    intros.
    unfold CongA.
    repeat split; try assumption.
    prolong B A A' D C.
    prolong D C C' B A.
    exists A'.
    exists A'.
    exists C'.
    exists C'.
    repeat split;finish.
Qed.
l11_10
Proof.
    intros.
    apply (out_conga A B C D E F); auto using l6_6.
Qed.
out2__conga
Proof.
  intros A B C A' C' HAOut HCOut.
  assert_diffs.
  apply l11_10 with A C A C;finish.
  apply conga_refl;auto.
Qed.
l11_13
Proof.
    intros.
    unfold CongA in H.
    spliter.
    ex_and H7 A''.
    ex_and H8 C''.
    ex_and H7 D''.
    ex_and H8 F''.
    prolong B A' A0 E D'.
    prolong E D' D0 B A'.
    unfold CongA.
    repeat split; try assumption.
    exists A0.
    exists C''.
    exists D0.
    exists F''.
    repeat split; try assumption.
    apply (five_segment_with_def A'' B A0 C'' D'' E D0 F'').
      unfold OFSC.
      repeat split.
        eapply outer_transitivity_between2.
          apply between_symmetry.
          apply H7.
          eapply outer_transitivity_between.
            apply H0.
            assumption.
          auto.
        assumption.
        eapply outer_transitivity_between2.
          apply between_symmetry.
          apply H11.
          eapply outer_transitivity_between.
            apply H2.
            assumption.
          auto.
        assumption.
        apply cong_left_commutativity.
        eapply l2_11.
          apply H7.
          apply between_symmetry.
          apply H11.
          Cong.
        Cong.
        apply cong_right_commutativity.
        eapply l2_11.
          apply H16.
          apply between_symmetry.
          apply H18.
          apply cong_symmetry.
          Cong.
        Cong.
        assumption.
      apply cong_right_commutativity.
      eapply l2_11 with C F;finish.
    assert_diffs;auto.
Qed.
conga_right_comm
Proof.
    intros.
    apply conga_trans with D E F.
    apply H.
    unfold CongA in H.
    spliter.
    apply conga_pseudo_refl;auto.
Qed.
conga_left_comm
Proof.
    intros.
    apply conga_sym.
    apply conga_trans with A B C.
      apply conga_sym.
      apply H.
    unfold CongA in H.
    spliter.
    apply conga_pseudo_refl.
      assumption.
    assumption.
Qed.
conga_comm
Proof.
    intros.
    apply conga_left_comm.
    apply conga_right_comm.
    assumption.
Qed.
conga_line
Proof.
    intros.
    assert_diffs.
    prolong B C C0 B' C'.
    prolong B' C' C1 B C.
    prolong B A A0 B' A'.
    prolong B' A' A1 B A.
    unfold CongA.
    repeat split; try assumption.
      auto.
      auto.
    exists A0.
    exists C0.
    exists A1.
    exists C1.
    repeat split; try assumption.
    apply (l2_11 A0 B C0 A1 B' C1).
      eapply outer_transitivity_between2.
        apply between_symmetry.
        apply H11.
        eapply outer_transitivity_between.
          apply H3.
          assumption.
        assumption.
      assumption.
      eapply outer_transitivity_between2.
        apply between_symmetry.
        apply H13.
        eapply outer_transitivity_between.
          apply H4.
          assumption.
        assumption.
      assumption.
      apply cong_right_commutativity.
      eapply l2_11.
        apply between_symmetry.
        apply H11.
        apply H13.
        apply cong_left_commutativity.
        assumption.
      apply cong_symmetry.
      apply cong_right_commutativity.
      assumption.
    apply cong_right_commutativity.
    eapply l2_11.
      apply H7.
      apply between_symmetry.
      apply H9.
      apply cong_symmetry.
      apply cong_left_commutativity.
      assumption.
    apply cong_right_commutativity.
    assumption.
Qed.
l11_14
Proof.
    intros.
    assert_diffs.
    assert (CongA A' B C  C' B A).
    {
      apply l11_13 with A C;finish.
      apply conga_pseudo_refl;finish.
    }
      apply l11_13 with A' A;finish.
      apply conga_right_comm.
      auto.
Qed.
l11_16
Proof.
    intros.
    prolong B C C0 B' C'.
    prolong B' C' C1 B C.
    prolong B A A0 B' A'.
    prolong B' A' A1 B A.
    unfold CongA.
    repeat split; try assumption.
    exists A0.
    exists C0.
    exists A1.
    exists C1.
    repeat split; try assumption.
    apply (l10_12 A0 B C0 A1 B' C1).
      eapply (per_col _ _ C).
        intro;subst.
        auto.
        apply l8_2.
        eapply (per_col _ _ A).
          auto.
          apply l8_2.
          assumption.
        unfold Col.
        left.
        assumption.
      unfold Col.
      left.
      assumption.
      eapply (per_col _ _ C').
        auto.
        apply l8_2.
        eapply (per_col _ _ A').
          auto.
          apply l8_2.
          assumption.
        unfold Col.
        left.
        assumption.
      unfold Col.
      left.
      assumption.
      apply cong_right_commutativity.
      eapply l2_11.
        apply between_symmetry.
        apply H9.
        apply H11.
        apply cong_left_commutativity.
        assumption.
      apply cong_symmetry.
      apply cong_right_commutativity.
      assumption.
    apply cong_right_commutativity.
    eapply l2_11.
      apply H5.
      apply between_symmetry.
      apply H7.
      apply cong_symmetry.
      apply cong_left_commutativity.
      assumption.
    apply cong_right_commutativity.
    assumption.
Qed.
l11_17
Proof.
    intros.
    unfold CongA in H0.
    spliter.
    ex_and H4 A0.
    ex_and H5 C0.
    ex_and H4 A1.
    ex_and H5 C1.
    assert (Per A0 B C0).
      eapply (per_col _ _ C).
        auto.
        apply l8_2.
        eapply (per_col _ _ A).
          auto.
          apply l8_2.
          assumption.
        unfold Col.
        left.
        assumption.
      unfold Col.
      left.
      assumption.
    assert(Per A1 B' C1).
      eapply l8_10.
        apply H13.
      repeat split.
        apply cong_right_commutativity.
        eapply l2_11.
          apply between_symmetry.
          apply H4.
          apply H8.
          apply cong_left_commutativity.
          assumption.
        apply cong_symmetry.
        apply cong_right_commutativity.
        assumption.
        assumption.
      apply cong_right_commutativity.
      eapply l2_11.
        apply H6.
        apply between_symmetry.
        apply H10.
        apply cong_left_commutativity.
        apply cong_symmetry.
        apply cong_commutativity.
        assumption.
      apply cong_right_commutativity.
      assumption.
    eapply (per_col _ _ C1).
      intro.
      subst C1.
      apply between_identity in H10.
      subst C'.
      absurde.
      apply l8_2.
      eapply (per_col _ _ A1).
        intro.
        subst A1.
        apply between_identity in H8.
        subst A'.
        absurde.
        apply l8_2.
        assumption.
      unfold Col.
      right; left.
      apply between_symmetry.
      assumption.
    unfold Col.
    right; left.
    apply between_symmetry.
    assumption.
Qed.
l11_18_1
Proof.
    intros.
    spliter.
    assert (Per A B D).
      eapply per_col.
        apply H0.
        assumption.
      unfold Col.
      right; right.
      apply between_symmetry.
      assumption.
    eapply l11_16; try assumption.
      auto.
    auto.
Qed.
l11_18_2
Proof.
    intros.
    unfold CongA in H0.
    spliter.
    ex_and H4 A0.
    ex_and H5 C0.
    ex_and H4 A1.
    ex_and H5 D0.
    assert( A0 = A1).
      eapply construction_uniqueness.
        2: apply H4.
        auto.
        apply H5.
        assumption.
      assumption.
    subst A1.
    assert(Per A0 B C0).
      unfold Per.
      exists D0.
      repeat split.
        eapply outer_transitivity_between2.
          apply between_symmetry.
          apply H6.
          eapply outer_transitivity_between.
            apply H.
            assumption.
          auto.
        assumption.
        eapply l2_11.
          apply between_symmetry.
          apply H6.
          apply H10.
          apply cong_left_commutativity.
          assumption.
        apply cong_symmetry.
        apply cong_right_commutativity.
        assumption.
      assumption.
    eapply (per_col _ _ C0).
      intro.
      subst C0.
      apply between_identity in H6.
      subst C.
      absurde.
      apply l8_2.
      eapply (per_col _ _ A0).
        intro.
        subst A0.
        apply between_identity in H8.
        subst A.
        absurde.
        apply l8_2.
        assumption.
      unfold Col.
      right; left.
      apply between_symmetry.
      assumption.
    unfold Col.
    right; left.
    apply between_symmetry.
    assumption.
Qed.
cong3_preserves_out
Proof.
    intros.
    unfold Out in *.
    spliter.
    assert(HH:=H0).
    unfold Cong_3 in H0.
    spliter.
    repeat split.
      intro.
      subst A'.
      apply cong_identity in H0.
      subst A.
      absurde.
      intro.
      subst A'.
      apply cong_identity in H3.
      subst A.
      absurde.
    induction H2.
      left.
      eapply l4_6.
        2:apply HH.
      assumption.
    right.
    eapply l4_6.
      apply H2.
    unfold Cong_3.
    repeat split.
      assumption.
      assumption.
    apply cong_commutativity.
    assumption.
Qed.
l11_21_a
Proof.
    intros.
    unfold CongA in H0.
    spliter.
    ex_and H4 A0.
    ex_and H5 C0.
    ex_and H4 A1.
    ex_and H5 C1.
    assert (Out B A0 C0).
      unfold Out.
      repeat split.
        intro.
        subst A0.
        apply between_identity in H4.
        subst A.
        absurde.
        intro.
        subst C0.
        apply between_identity in H6.
        subst C.
        absurde.
      unfold Out in H.
      spliter.
      induction H14.
        eapply l5_1.
          2: apply H4.
          auto.
        eapply between_exchange4.
          apply H14.
        assumption.
      eapply l5_1.
        3: apply H6.
        auto.
      eapply between_exchange4.
        apply H14.
      assumption.
    assert (Out B' A1 C1).
      eapply cong3_preserves_out.
        apply H13.
      unfold Cong_3.
      repeat split.
        apply cong_right_commutativity.
        eapply l2_11.
          apply H4.
          apply between_symmetry.
          apply H8.
          apply cong_symmetry.
          apply cong_left_commutativity.
          assumption.
        apply cong_right_commutativity.
        assumption; apply H8.
        apply cong_right_commutativity.
        eapply l2_11.
          apply H6.
          apply between_symmetry.
          apply H10.
          apply cong_symmetry.
          apply cong_left_commutativity.
          assumption.
        apply cong_right_commutativity.
        assumption.
      assumption.
    eapply l6_7.
      apply l6_6.
      eapply l6_7.
        apply H14.
      eapply l6_7.
        apply l6_6.
        apply H14.
      unfold Out.
      repeat split.
        intro.
        subst A1.
        unfold Out in H14.
        spliter.
        absurde.
        assumption.
      right.
      assumption.
    eapply l6_7.
      apply H14.
    unfold Out.
    repeat split.
      intro.
      subst C1.
      unfold Out in H14.
      spliter.
      absurde.
      assumption.
    right.
    assumption.
Qed.
l11_21_b
Proof.
    intros.
    prolong A B A0 A B.
    prolong C B C0 B C.
    prolong A' B' A1 A' B'.
    prolong C' B' C1 B' C'.
    eapply l11_13.
      eapply conga_line.
        5: apply between_symmetry.
        5: apply H3.
        5: apply between_symmetry.
        5: apply H7.
        intro.
        subst C0.
        apply cong_symmetry in H4.
        apply cong_identity in H4.
        subst C.
        unfold Out in H.
        spliter.
        absurde.
        intro.
        subst C.
        unfold Out in H.
        spliter.
        absurde.
        intro.
        subst C1.
        apply cong_symmetry in H8.
        apply cong_identity in H8.
        subst C'.
        unfold Out in H0.
        spliter.
        absurde.
        intro.
        subst C'.
        unfold Out in H0.
        spliter.
        absurde.
      unfold Out in H0.
      spliter.
      auto.
      unfold Out in H.
      spliter.
      induction H12.
        eapply between_inner_transitivity.
          apply between_symmetry.
          apply H3.
        assumption.
      eapply outer_transitivity_between.
        apply between_symmetry.
        apply H3.
        assumption.
      auto.
      unfold Out in H.
      spliter.
      assumption.
      unfold Out in H0.
      spliter.
      induction H10.
        eapply between_inner_transitivity.
          apply between_symmetry.
          apply H7.
        assumption.
      eapply outer_transitivity_between.
        apply between_symmetry.
        apply H7.
        assumption.
      auto.
    unfold Out in H0.
    spliter.
    assumption.
Qed.
conga__or_out_ts
Proof.
    intros.
    unfold CongA in H.
    spliter.
    ex_and H3 A0.
    ex_and H4 C0.
    ex_and H3 A1.
    ex_and H4 C1.
    assert (A0=A1).
      eapply construction_uniqueness.
        3:apply H4.
        2:apply H3.
        auto.
        assumption.
      assumption.
    subst A1.
    induction (eq_dec_points C0 C1).
      subst C1.
      left.
      unfold Out.
      repeat split; try assumption.
      eapply l5_3.
        apply H5.
      assumption.
    right.
    assert(exists M, Midpoint M C0 C1).
      apply midpoint_existence.
    ex_and H13 M.
    assert(Cong B C0 B C1).
      apply cong_right_commutativity.
      eapply l2_11.
        apply H5.
        apply between_symmetry.
        apply H9.
        apply cong_symmetry.
        apply cong_left_commutativity.
        assumption.
      apply cong_right_commutativity.
      assumption.
    assert(Per A0 M C0).
      unfold Per.
      exists C1.
      split.
        assumption.
      assumption.
    assert(Per B M C0).
      unfold Per.
      exists C1.
      split.
        assumption.
      assumption.
    assert(Per A0 M C1).
      unfold Per.
      exists C0.
      split.
        apply l7_2.
        assumption.
      apply cong_symmetry.
      assumption.
    assert(Per B M C1).
      unfold Per.
      exists C0.
      split.
        apply l7_2.
        assumption.
      apply cong_symmetry.
      assumption.
    assert (B <> A0).
      intro.
      subst A0.
      apply between_identity in H7.
      subst A.
      absurde.
    assert (Cong A C0 A C1).
      eapply (l4_2 B A A0 C0 B A A0 C1).
      unfold IFSC.
      repeat split; try assumption.
        apply cong_reflexivity.
      apply cong_reflexivity.
    assert (Per A M C0).
      unfold Per.
      exists C1.
      split.
        assumption.
      assumption.
    assert (Per A M C1).
      unfold Per.
      exists C0.
      split.
        apply l7_2.
        assumption.
      apply cong_symmetry.
      assumption.
    assert(Col B A M).
      eapply per_per_col.
        apply H16.
        intro.
        subst M.
        apply is_midpoint_id in H14.
        contradiction.
      assumption.
    (************)
    induction(eq_dec_points B M).
      subst M.
      assert(~Col A B C).
        eapply per_not_col.
          assumption.
          auto.
        eapply per_col.
          2:apply H22.
          intro.
          subst C1.
          apply l7_2 in H14.
          apply is_midpoint_id in H14.
          subst C0.
          absurde.
        assert(Bet C B C1).
          eapply between_exchange3.
            apply between_symmetry.
            apply H5.
          apply midpoint_bet.
          assumption.
        unfold Col.
        right; right.
        assumption.
      assert(~Col A B C').
        eapply per_not_col.
          assumption.
          auto.
        eapply per_col.
          2:apply H22.
          intro.
          subst C1.
          apply l7_2 in H14.
          apply is_midpoint_id in H14.
          subst C0.
          absurde.
        assert(Bet C' B C0).
          eapply between_exchange3.
            apply between_symmetry.
            apply H9.
          apply midpoint_bet.
          apply l7_2.
          assumption.
        unfold Col.
        right; left.
        apply between_symmetry.
        assumption.
      unfold TS.
      repeat split.
        Col.
        Col.
      exists B.
      split.
        Col.
      apply between_symmetry.
      eapply between_exchange3.
        apply between_symmetry.
        apply H9.
      apply between_symmetry.
      eapply between_exchange3.
        apply between_symmetry.
        apply H5.
      apply midpoint_bet.
      assumption.
    (***********)
    assert(TS B M C0 C1).
      unfold TS.
      repeat split.
        intro.
        apply per_not_col in H16.
          apply H16.
          apply col_permutation_1.
          assumption.
          assumption.
        intro.
        subst C0.
        apply is_midpoint_id in H14.
        subst C1.
        absurde.
        intro.
        apply per_not_col in H18.
          apply H18.
          Col.
          assumption.
        intro.
        subst C1.
        apply l7_2 in H14.
        apply is_midpoint_id in H14.
        subst C0.
        absurde.
      exists M.
      split.
        apply col_trivial_3.
      apply midpoint_bet.
      assumption.
    apply (col_two_sides _ _ A) in H25.
      apply invert_two_sides in H25.
      (*************************)
      assert(TS A B C C1).
        eapply l9_5.
          apply H25.
          apply col_trivial_3.
        unfold Out.
        repeat split.
          intro.
          subst C0.
          apply cong_symmetry in H13.
          apply cong_identity in H13.
          subst C1.
          absurde.
          assumption.
        right.
        assumption.
      apply l9_2.
      eapply l9_5.
        apply l9_2.
        apply H26.
        apply col_trivial_3.
      unfold Out.
      repeat split.
        intro.
        subst C1.
        apply cong_identity in H13.
        subst C0.
        absurde.
        intro.
        subst C'.
        apply cong_identity in H6.
        subst C0.
        absurde.
      right.
      assumption.
      Col.
    auto.
Qed.
cong2_conga_cong
Proof.
    intros.
    unfold CongA in H.
    spliter.
    ex_and H5 A0.
    ex_and H6 C0.
    ex_and H5 A1.
    ex_and H6 C1.
    assert(Cong A C0 A' C1).
      eapply (l4_2 B A A0 C0 B' A' A1 C1).
      repeat split; try assumption.
        eapply l2_11.
          apply H5.
          apply H9.
          apply cong_commutativity.
          assumption.
        eapply cong_transitivity.
          apply H6.
        apply cong_commutativity.
        apply cong_symmetry.
        eapply cong_transitivity.
          2: apply H0.
        apply cong_commutativity.
        assumption.
        eapply cong_transitivity.
          apply H6.
        apply cong_commutativity.
        apply cong_symmetry.
        eapply cong_transitivity.
          2: apply H0.
        apply cong_commutativity.
        assumption.
      eapply cong_transitivity.
        eapply l2_11.
          apply H7.
          apply H11.
          assumption.
        eapply cong_transitivity.
          apply H8.
        apply cong_symmetry.
        eapply cong_transitivity.
          apply H12.
        assumption.
      apply cong_reflexivity.
    apply cong_commutativity.
    eapply (l4_2 B C C0 A B' C' C1 A').
    repeat split; try assumption.
      eapply l2_11.
        apply H7.
        apply H11.
        assumption.
      eapply cong_transitivity.
        apply H8.
      eapply cong_transitivity.
        apply cong_symmetry.
        apply H1.
      apply cong_symmetry.
      assumption.
      eapply cong_transitivity.
        apply H8.
      eapply cong_transitivity.
        apply cong_symmetry.
        apply H1.
      apply cong_symmetry.
      assumption.
      apply cong_commutativity.
      assumption.
    apply cong_commutativity.
    assumption.
Qed.
angle_construction_1
Proof.
    intros.
    assert (exists C0, Col B A C0 /\ Perp B A C C0).
      eapply l8_18_existence.
      intro.
      apply H.
      apply col_permutation_4.
      assumption.
    ex_and H1 C0.
    induction(eq_dec_points B C0).
      subst C0.
      assert (exists  C', Per C' B' A' /\ Cong C' B' C B /\ OS A' B' C' P).
        apply ex_per_cong.
          intro.
          subst A'.
          apply H0.
          apply col_trivial_1.
          intro.
          subst C.
          apply H.
          apply col_trivial_2.
          apply col_trivial_2.
        assumption.
      ex_and  H3 C'.
      exists C'.
      split.
        eapply l11_16.
          apply perp_perp_in in H2.
          apply perp_in_comm in H2.
          apply perp_in_per in H2.
          assumption.
          intro.
          subst A.
          apply H.
          apply col_trivial_1.
          intro.
          subst C.
          apply H.
          apply col_trivial_2.
          apply l8_2.
          assumption.
          intro.
          subst A'.
          apply H0.
          apply col_trivial_1.
        intro.
        subst C'.
        apply cong_symmetry in H4.
        apply cong_identity in H4.
        subst C.
        apply H.
        apply col_trivial_2.
      assumption.
    (*********** B <> C0 ***********)
    induction (out_dec B A C0).
      assert (exists C0', Out B' A' C0' /\ Cong B' C0' B C0).
        eapply segment_construction_3.
          intro.
          subst A'.
          apply H0.
          apply col_trivial_1.
        assert (Perp_at C0 C0 C B C0).
          eapply perp_perp_in.
          apply perp_sym.
          eapply perp_col.
            assumption.
            apply perp_right_comm.
            apply H2.
          assumption.
        assumption.
      ex_and H5 C0'.
      assert (exists C' , Per C' C0' B' /\ Cong C' C0' C C0 /\ OS B' C0' C' P).
        apply ex_per_cong.
          intro.
          subst C0'.
          unfold Out in H5.
          spliter.
          absurde.
          intro.
          subst C0.
          unfold Perp in H2.
          ex_and H2 X.
          unfold Perp_at in H7.
          spliter.
          absurde.
          apply col_trivial_2.
        intro.
        apply H0.
        apply col_permutation_2.
        eapply (col_transitivity_1 _ C0').
          intro.
          subst C0'.
          unfold Out in H5.
          spliter.
          absurde.
          assumption.
        apply out_col.
        apply l6_6.
        assumption.
      ex_and H7 C'.
      assert (Cong_3 C0 B C C0' B' C').
        unfold Cong_3.
        repeat split.
          apply cong_symmetry.
          apply cong_commutativity.
          assumption.
          apply cong_symmetry.
          apply cong_commutativity.
          assumption.
        eapply (l10_12 _ C0).
          assert(Perp  B C0 C C0 ).
            eapply perp_col.
              intro.
              subst C0.
              apply perp_distinct in H2.
              spliter.
              absurde.
              apply H2.
            assumption.
          apply perp_left_comm in H10.
          apply perp_perp_in in H10.
          apply perp_in_per.
          apply perp_in_comm.
          assumption.
          apply l8_2.
          apply H7.
          apply cong_symmetry.
          assumption.
        apply cong_symmetry.
        apply cong_commutativity.
        assumption.
      exists C'.
      split.
        eapply (l11_10 C0 _ _ C0').
          apply cong3_conga.
            3: apply H10.
            intro.
            subst C0.
            absurde.
          intro.
          subst C.
          apply H.
          apply col_trivial_2.
          assumption.
          apply out_trivial.
          intro.
          subst C.
          apply H.
          apply col_trivial_2.
          assumption.
        apply out_trivial.
        intro.
        subst C'.
        apply l8_8 in H7.
        subst C0'.
        unfold Out in H5.
        spliter.
        absurde.
      apply invert_one_side.
      eapply col_one_side.
        3: apply H9.
        apply out_col.
        apply l6_6.
        assumption.
      intro.
      subst A'.
      apply H0.
      apply col_trivial_1.
    (*********************)
    apply not_out_bet in H4.
      prolong A' B' C0' B C0.
      assert (exists C' , Per C' C0' B' /\ Cong C' C0' C C0 /\ OS B' C0' C' P).
        apply ex_per_cong.
          intro.
          subst C0'.
          apply cong_symmetry in H6.
          apply cong_identity in H6.
          subst C0.
          absurde.
          intro.
          subst C0.
          apply perp_distinct in H2.
          spliter.
          absurde.
          apply col_trivial_2.
        intro.
        apply H0.
        apply col_permutation_2.
        eapply col_transitivity_1.
          2:apply H7.
          intro.
          subst C0'.
          apply cong_symmetry in H6.
          apply cong_identity in H6.
          subst C0.
          absurde.
        unfold Col.
        right; right.
        assumption.
      ex_and H7 C'.
      exists C'.
      split.
        assert (Cong_3 C0 B C C0' B' C').
          repeat split.
            apply cong_symmetry.
            apply cong_commutativity.
            assumption.
            apply cong_symmetry.
            apply cong_commutativity.
            assumption.
          apply cong_commutativity.
          eapply (l10_12 _ C0 _ _ C0').
            assert(Perp  B C0 C C0 ).
              eapply perp_col.
                intro.
                subst C0.
                apply perp_distinct in H2.
                spliter.
                absurde.
                apply H2.
              assumption.
            apply perp_left_comm in H10.
            apply perp_perp_in in H10.
            apply perp_in_per.
            apply perp_in_sym.
            assumption.
            assumption.
            apply cong_symmetry.
            assumption.
          apply cong_symmetry.
          apply cong_commutativity.
          assumption.
        eapply l11_13.
          apply cong3_conga.
            3: apply H10.
            auto.
          intro.
          subst C.
          apply H.
          apply col_trivial_2.
          apply between_symmetry.
          assumption.
          intro.
          subst A.
          apply H.
          apply col_trivial_1.
          apply between_symmetry.
          assumption.
        intro.
        subst A'.
        apply H0.
        apply col_trivial_1.
      apply invert_one_side.
      eapply col_one_side.
        3: apply H9.
        unfold Col.
        right; right.
        assumption.
      intro.
      subst A'.
      apply H0.
      apply col_trivial_1.
    apply col_permutation_4.
    assumption.
Qed.
angle_construction_2
Proof.
    intros.
    spliter.
    induction (Col_dec A B C).
      induction (out_dec B A C).
        exists A'.
        split.
          assert(CongA A B A A B C).
            eapply l11_10.
              apply conga_refl.
                3: apply H5.
              auto.
              2: apply H5.
              auto.
              assumption.
            apply out_trivial.
            auto.
          assert (CongA A B A A' B' A').
            apply conga_trivial_1.
              assumption.
            assumption.
          apply conga_sym.
          eapply conga_trans.
            apply conga_sym.
            apply H7.
          assumption.
        right.
        apply col_trivial_3.
      apply not_out_bet in H5.
        prolong A' B' C' A'  B'.
        exists C'.
        split.
          eapply conga_line; try assumption.
            intro.
            subst C'.
            apply cong_symmetry in H7.
            apply cong_identity in H7.
            subst A'.
            absurde.
        right.
        unfold Col.
        left.
        assumption.
      assumption.
    assert(exists C' , CongA A B C A' B' C' /\ OS A' B' C' P).
      apply angle_construction_1.
        assumption.
      assumption.
    ex_and H5 C'.
    exists C'.
    split.
      assumption.
    left.
    assumption.
Qed.
ex_conga_ts
Proof.
  intros A B C A' B' P HNCol HNCol'.
  assert (HP' : exists P', Midpoint A' P P') by (apply symmetric_point_construction).
  destruct HP' as [P' HMid].
  assert (~ Col A' B' P').
  { intro HCol.
    apply HNCol'.
    assert (Col A' P P') by (apply midpoint_col; auto).
    apply (col3 A' P'); Col.
    intro; treat_equalities; Col.
  }
  assert (HC' : exists C', CongA A B C A' B' C' /\ OS A' B' C' P').
  apply (angle_construction_1 A B C A' B' P'); auto.
  destruct HC' as [C' [HConga HOne]].
  exists C'.
  split; auto.
  apply (l9_8_2 A' B' P'); Side.
  split; Col; split; Col.
  exists A'.
  split; Col.
  destruct HMid; Between.
Qed.
l11_15
Proof.
    intros.
    assert(exists F, CongA A B C D E F /\  OS D E F P)
      by (apply angle_construction_1; assumption).
    ex_and H1 F.
    exists F.
    split.
      assumption.
    split.
      apply invert_one_side.
      assumption.
    intros.
    spliter.
    assert(Out E F1 F2 \/ TS D E F1 F2).
      apply conga__or_out_ts.
      eapply conga_trans.
        apply conga_sym.
        apply H3.
      assumption.
    induction H7.
      assumption.
    assert(OS E D F1 F2).
      eapply one_side_transitivity.
        apply H6.
      apply one_side_symmetry.
      assumption.
    apply l9_9_bis in H8.
    apply invert_two_sides in H7.
    contradiction.
Qed.
l11_19
Proof.
    intros.
    induction (Col_dec A B P1).
      induction (l8_9 A B P1 H H2).
        subst.
        unfold OS in *.
        decompose [ex and] H1.
        unfold TS in *.
        intuition.
      subst.
      unfold OS in *.
      decompose [ex and] H1.
      unfold TS in *.
      spliter.
      assert (Col B A B) by Col.
      intuition.
    induction (Col_dec A B P2).
      induction (l8_9 A B P2 H0 ).
        subst.
        unfold OS in *.
        decompose [ex and] H1.
        unfold TS in *.
        intuition.
        subst.
        unfold OS in *.
        decompose [ex and] H1.
        unfold TS in *.
        spliter.
        assert (Col B A B) by Col.
        intuition.
      Col.
    assert (T:=l11_15 A B P1 A B P2 H2 H3).
    decompose [ex and] T.
    apply H7.
    split.
      split.
        apply conga_refl.
          intro;subst;Col.
        intro;subst;Col.
      apply invert_one_side;auto.
    split.
      apply l11_16;try assumption.
        intro;subst;Col.
        intro;subst;Col.
        intro;subst;Col.
      intro;subst;Col.
    apply one_side_reflexivity.
    Col.
Qed.
l11_22_bet
Proof.
    intros.
    spliter.
    prolong A' B' C'' B C.
    assert(CongA C B P C'' B' P').
      eapply l11_13.
        2:apply H.
        apply H1.
        unfold CongA in H2.
        spliter.
        assumption.
        assumption.
      intro.
      subst C''.
      apply cong_symmetry in H4.
      apply cong_identity in H4.
      subst C.
      unfold CongA in H2.
      spliter.
      absurde.
    assert (CongA C'' B' P' C' B' P').
      eapply conga_trans.
        apply conga_sym.
        apply H5.
      apply conga_comm.
      assumption.
    assert(Out B' C' C'' \/ TS P' B' C' C'').
      apply conga__or_out_ts.
      apply conga_comm.
      apply conga_sym.
      assumption.
    induction H7.
      unfold Out in H7.
      spliter.
      induction H9.
        eapply between_inner_transitivity.
          apply H3.
        assumption.
      eapply outer_transitivity_between.
        apply H3.
        assumption.
      auto.
    induction (Col_dec C' B' P').
      unfold TS in H7.
      spliter.
      apply False_ind.
      apply H7.
      apply col_permutation_5.
      assumption.
    assert (B' <> P').
      intro.
      subst P'.
      apply H8.
      apply col_trivial_2.
    assert (TS B' P' A' C'').
      unfold TS.
      repeat split.
        unfold TS in H0.
        spliter.
        intro.
        apply H0.
        apply col_permutation_5.
        assumption.
        intro.
        unfold TS in H7.
        spliter.
        apply H11.
        apply col_permutation_5.
        assumption.
      exists B'.
      split.
        apply col_trivial_1.
      assumption.
    assert (OS B' P' C' C'').
      eapply l9_8_1.
        apply l9_2.
        apply invert_two_sides.
        apply H0.
      apply l9_2.
      assumption.
    apply l9_9_bis in H11.
    apply invert_two_sides in H7.
    contradiction.
Qed.
l11_22a
Proof.
    intros.
    spliter.
    assert (A <> B /\ A' <> B' /\ P <> B /\ P' <> B' /\ C <> B /\ C' <> B').
      unfold CongA in *.
      spliter.
      repeat split; assumption.
    assert(A <> C /\ A' <> C').
      unfold TS in *.
      spliter.
      ex_and H12 T.
      ex_and H10 T'.
      split.
        intro.
        subst C.
        apply between_identity in H13.
        subst T.
        contradiction.
      intro.
      subst C'.
      apply between_identity in H14.
      subst T'.
      contradiction.
    spliter.
    assert(exists A'', Out B' A' A'' /\ Cong B' A'' B A).
      eapply segment_construction_3; auto.
    ex_and H11 A''.
    unfold TS in H.
    assert (~ Col A B P).
      spliter.
      assumption.
    spliter.
    ex_and H15 T.
    induction (eq_dec_points B T).
      subst T.
      assert(Bet A' B' C').
        eapply l11_22_bet.
          apply H16.
          apply invert_two_sides.
          apply H0.
        split.
          apply H1.
        assumption.
      apply conga_line.
        assumption.
        auto.
        assumption.
        auto.
      assumption.
      assumption.
    induction(bet_dec P B T).
      assert(exists T'', Col B' P' T'' /\ (Out B' P' T'' <-> Out B P T) /\ Cong B' T'' B T).
        prolong P' B' T'' B T.
        exists T''.
        split.
          unfold Col.
          right; right.
          apply between_symmetry.
          assumption.
        split.
          split.
            intro.
            assert(Bet P' B' T'' /\ Out B' P' T'').
              split; assumption.
            apply (not_bet_and_out _ _  _)in H22.
            contradiction.
          intro.
          assert(Bet P B T /\ Out B P T).
            split; assumption.
          apply (not_bet_and_out _ _  _)in H22.
          contradiction.
        assumption.
      ex_and H19 T''.
      destruct H20.
      assert (B' <> T'').
        intro.
        subst T''.
        apply cong_symmetry in H21.
        apply cong_identity in H21.
        contradiction.
      assert(exists C'', Bet A'' T'' C'' /\ Cong T'' C'' T C).
        prolong A'' T'' C'' T C.
        exists C''.
        split; assumption.
      ex_and H24 C''.
      assert(CongA A B T A' B' T'').
        apply conga_comm.
        eapply l11_13.
          apply conga_comm.
          apply H1.
          assumption.
          auto.
          eapply out_to_bet.
            apply col_permutation_4.
            assumption.
            split.
              apply H22.
            assumption.
          assumption.
        auto.
      assert(CongA A B T A'' B'  T'').
        eapply l11_10.
          apply H26.
          apply out_trivial.
          auto.
          apply out_trivial.
          auto.
          apply l6_6.
          assumption.
        apply out_trivial.
        auto.
      assert(Cong A T A'' T'').
        assert(HH:= l11_4_1 A B T A'' B' T'' H27).
        spliter.
        apply H32.
        split.
          apply out_trivial.
          auto.
        split.
          apply out_trivial.
          auto.
        split.
          apply out_trivial.
          intro.
          subst A''.
          absurde.
        split.
          apply out_trivial.
          assumption.
        split.
          apply cong_symmetry.
          assumption.
        apply cong_symmetry.
        assumption.
      assert(Cong A C A'' C'').
        eapply l2_11.
          apply H16.
          apply H24.
          assumption.
        apply cong_symmetry.
        assumption.
      assert(Cong C B C'' B').
        eapply (five_segment).
          5:apply H16.
          5: apply H24.
          assumption.
          apply cong_symmetry.
          assumption.
          apply cong_symmetry.
          apply cong_commutativity.
          assumption.
          apply cong_symmetry.
          apply cong_commutativity.
          assumption.
        intro.
        subst T.
        apply H13.
        assumption.
      assert(CongA A B C A'' B' C'').
        apply cong3_conga.
          assumption.
          assumption.
        repeat split.
          apply cong_commutativity.
          apply cong_symmetry.
          assumption.
          assumption.
        apply cong_commutativity.
        assumption.
      assert(CongA C B T  C'' B' T'').
        apply cong3_conga.
          assumption.
          auto.
        repeat split.
          assumption.
          apply cong_symmetry.
          apply cong_commutativity.
          assumption.
        apply cong_symmetry.
        assumption.
      assert (CongA P B C P' B' C'').
        eapply l11_13.
          apply conga_comm.
          apply H32.
          apply between_symmetry.
          assumption.
          assumption.
          apply between_symmetry.
          eapply out_to_bet.
            eapply col_permutation_4.
            assumption.
            split.
              apply H22.
            assumption.
          assumption.
        assumption.
      assert(CongA P' B' C' P' B' C'').
        eapply conga_trans.
          apply conga_sym.
          apply H2.
        assumption.
      assert(Out B' C' C'' \/ TS P' B' C' C'').
        apply conga__or_out_ts.
        assumption.
      induction H35.
        eapply l11_10.
          apply H31.
          apply out_trivial.
          auto.
          apply out_trivial.
          auto.
          assumption.
        assumption.
      assert(TS B' P' A'' C').
        apply l9_2.
        eapply l9_5.
          eapply l9_2.
          eapply l9_5.
            apply H0.
            apply col_trivial_1.
          assumption.
          apply col_trivial_1.
        apply out_trivial.
        auto.
      apply invert_two_sides in H35.
      apply l9_2 in H35.
      assert(OS B' P'  A'' C'').
        unfold OS.
        exists C'.
        split; assumption.
      assert (TS B' P' A''  C'').
        unfold TS.
        repeat split.
          intro.
          unfold TS in H0.
          assert (~ Col A' B' P').
            spliter.
            assumption.
          spliter.
          apply H39.
          apply col_permutation_2.
          eapply (col_transitivity_1 _ A'').
            intro.
            subst A''.
            unfold Out in H11.
            spliter.
            absurde.
            apply col_permutation_4.
            assumption.
          apply out_col in H11.
          apply col_permutation_5.
          assumption.
          intro.
          unfold TS in H35.
          spliter.
          apply H35.
          assumption.
        exists T''.
        split.
          apply col_permutation_2.
          assumption.
        assumption.
      apply l9_9 in H38.
      contradiction.
    apply not_bet_out in H18.
      assert(exists T'', Col B' P' T'' /\ (Out B' P' T'' <-> Out B P T) /\ Cong B' T'' B T).
        assert (exists T'', Out B' P' T'' /\ Cong B' T'' B T).
          apply segment_construction_3.
            auto.
          assumption.
        ex_and H19 T''.
        exists T''.
        split.
          apply out_col in H19.
          assumption.
        split.
          split.
            intro.
            assumption.
          intro.
          assumption.
        assumption.
      ex_and H19 T''.
      destruct H20.
      assert (B' <> T'').
        intro.
        subst T''.
        apply cong_symmetry in H21.
        apply cong_identity in H21.
        contradiction.
      assert(exists C'', Bet A'' T'' C'' /\ Cong T'' C'' T C).
        prolong A'' T'' C'' T C.
        exists C''.
        split; assumption.
      ex_and H24 C''.
      assert(CongA A B T A' B' T'').
        eapply l11_10.
          apply H1.
          apply out_trivial.
          auto.
          apply l6_6.
          assumption.
          apply out_trivial.
          auto.
        apply l6_6.
        apply H22.
        assumption.
      assert(CongA A B T A'' B'  T'').
        eapply l11_10.
          apply H26.
          apply out_trivial.
          auto.
          apply out_trivial.
          auto.
          apply l6_6.
          assumption.
        apply out_trivial.
        auto.
      assert(Cong A T A'' T'').
        assert(HH:= l11_4_1 A B T A'' B' T'' H27).
        spliter.
        apply H32.
        split.
          apply out_trivial.
          auto.
        split.
          apply out_trivial.
          assumption.
        split.
          apply out_trivial.
          intro.
          subst A''.
          absurde.
        split.
          apply out_trivial.
          assumption.
        split.
          apply cong_symmetry.
          assumption.
        apply cong_symmetry.
        assumption.
      assert(Cong A C A'' C'').
        eapply l2_11.
          apply H16.
          apply H24.
          assumption.
        apply cong_symmetry.
        assumption.
      assert(Cong C B C'' B').
        eapply (five_segment).
          5:apply H16.
          5: apply H24.
          assumption.
          apply cong_symmetry.
          assumption.
          apply cong_symmetry.
          apply cong_commutativity.
          assumption.
          apply cong_symmetry.
          apply cong_commutativity.
          assumption.
        intro.
        apply H13.
        subst T.
        assumption.
      assert(CongA A B C A'' B' C'').
        apply cong3_conga.
          assumption.
          assumption.
        repeat split.
          apply cong_commutativity.
          apply cong_symmetry.
          assumption.
          assumption.
        apply cong_commutativity.
        assumption.
      assert(CongA C B T  C'' B' T'').
        apply cong3_conga.
          assumption.
          auto.
        repeat split.
          assumption.
          apply cong_symmetry.
          apply cong_commutativity.
          assumption.
        apply cong_symmetry.
        assumption.
      eapply l11_10.
        apply H31.
        apply out_trivial.
        auto.
        apply out_trivial.
        auto.
        assumption.
      assert(Out B' C' C'' \/ TS P' B' C' C'').
        apply conga__or_out_ts.
        apply conga_comm.
        eapply conga_trans.
          apply conga_comm.
          apply conga_sym.
          apply H2.
        eapply l11_10.
          apply H32.
          apply out_trivial.
          auto.
          assumption.
          apply out_trivial.
          intro.
          subst C''.
          apply cong_identity in H30.
          contradiction.
        apply H22.
        assumption.
      induction H33.
        assumption.
      assert(TS B' P' A'' C').
        apply l9_2.
        eapply l9_5.
          eapply l9_2.
          eapply l9_5.
            apply H0.
            apply col_trivial_1.
          assumption.
          apply col_trivial_1.
        apply out_trivial.
        auto.
      assert(OS B' P'  A'' C'').
        unfold OS.
        exists C'.
        split.
          assumption.
        apply invert_two_sides in H33.
        apply l9_2 in H33.
        assumption.
      assert (TS B' P' A''  C'').
        unfold TS.
        repeat split.
          intro.
          unfold TS in H34.
          spliter.
          apply H34.
          assumption.
          intro.
          unfold TS in H33.
          spliter.
          apply H37.
          apply col_permutation_5.
          assumption.
        exists T''.
        split.
          apply col_permutation_2.
          assumption.
        assumption.
      apply l9_9 in H36.
      contradiction.
      auto.
    apply col_permutation_3.
    assumption.
Qed.
l11_22b
Proof.
    intros.
    spliter.
    prolong A B D A B.
    prolong A' B' D' A' B'.
    assert(CongA D B P D' B' P').
      eapply l11_13.
        apply H1.
        assumption.
        intro.
        subst D.
        apply cong_symmetry in H4.
        apply cong_identity in H4.
        subst A.
        unfold CongA in H1.
        spliter.
        absurde.
        assumption.
      intro.
      subst D'.
      apply cong_symmetry in H6.
      apply cong_identity in H6.
      subst A'.
      unfold CongA in H1.
      spliter.
      absurde.
    assert (CongA D B C D' B' C').
      eapply (l11_22a _ _ _ P _ _ _ P').
      split.
        eapply l9_2.
        eapply l9_8_2.
          2: apply H.
        unfold OS in H.
        ex_and H T.
        unfold TS in H.
        unfold TS in H8.
        spliter.
        repeat split.
          assumption.
          intro.
          apply H.
          apply col_permutation_2.
          eapply (col_transitivity_1 _ D).
            intro.
            subst D.
            unfold CongA in H7.
            spliter.
            absurde.
            apply col_permutation_4.
            assumption.
          unfold Col.
          right; right.
          assumption.
        exists B.
        split.
          apply col_trivial_1.
        assumption.
      split.
        eapply l9_2.
        eapply l9_8_2.
          2: apply H0.
        unfold OS in H0.
        ex_and H0 T'.
        unfold TS in H0.
        unfold TS in H8.
        spliter.
        repeat split.
          assumption.
          intro.
          apply H0.
          apply col_permutation_2.
          eapply (col_transitivity_1 _ D').
            intro.
            subst D'.
            unfold CongA in H7.
            spliter.
            absurde.
            apply col_permutation_4.
            assumption.
          unfold Col.
          right; right.
          assumption.
        exists B'.
        split.
          apply col_trivial_1.
        assumption.
      split; assumption.
    eapply l11_13.
      apply H8.
      apply between_symmetry.
      assumption.
      intro.
      subst A.
      unfold CongA in H1.
      spliter.
      absurde.
      apply between_symmetry.
      assumption.
    intro.
    subst A'.
    unfold CongA in H1.
    spliter.
    absurde.
Qed.
l11_22
Proof.
    intros.
    spliter.
    induction H.
      eapply (l11_22a _ _ _ P _ _ _ P');tauto.
    eapply (l11_22b _ _ _ P _ _ _ P');tauto.
Qed.
l11_24
Proof.
    unfold InAngle.
    intros.
    spliter.
    ex_and H2 X.
    repeat split; try assumption.
    exists X.
    split.
      apply between_symmetry.
      assumption.
    assumption.
Qed.
out_in_angle
Proof.
    intros.
    unfold InAngle.
    unfold Out in H.
    unfold Out in H0.
    spliter.
    split.
      assumption.
    split.
      assumption.
    split.
      assumption.
    induction H4; induction H2.
      assert(exists X, Midpoint X A C).
        eapply midpoint_existence.
      ex_and H5 X.
      exists X.
      split.
        apply midpoint_bet.
        assumption.
      right.
      repeat split.
        intro.
        subst X.
        apply midpoint_bet in H6.
        assert (A = B).
          eapply between_equality.
            apply H6.
          assumption.
        contradiction.
        assumption.
      right.
      induction (eq_dec_points P A).
        subst P.
        eapply between_inner_transitivity.
          apply H4.
        apply midpoint_bet.
        assumption.
      assert(Bet P A C).
        eapply between_exchange3.
          apply H2.
        assumption.
      assert(Bet P A X).
        eapply between_inner_transitivity.
          apply H7.
        apply midpoint_bet.
        assumption.
      eapply outer_transitivity_between.
        apply H2.
        assumption.
      assumption.
      assert(exists X, Midpoint X A C).
        eapply midpoint_existence.
      ex_and H5 X.
      exists X.
      repeat split.
        apply midpoint_bet.
        assumption.
      right.
      repeat split.
        intro.
        subst X.
        apply midpoint_bet in H6.
        assert (A = B).
          eapply between_equality.
            apply H6.
          assumption.
        contradiction.
        assumption.
      assert(Bet B C P \/ Bet B P C).
        eapply l5_1.
          2: apply H4.
          auto.
        assumption.
      induction H5.
        left.
        assert(Bet B X C).
          eapply between_exchange2.
            apply H4.
          apply midpoint_bet.
          assumption.
        eapply between_exchange4.
          apply H7.
        assumption.
      assert(Bet B A X).
        eapply between_inner_transitivity.
          apply H4.
        apply  midpoint_bet.
        assumption.
      eapply l5_1.
        2:apply H7.
        auto.
      assumption.
      assert(Bet B P C \/ Bet B C P).
        eapply l5_3.
          apply H2.
        assumption.
      induction H5.
        assert(exists X, Midpoint X A C).
          eapply midpoint_existence.
        ex_and H6 X.
        exists X.
        split.
          apply midpoint_bet.
          assumption.
        right.
        repeat split.
          intro.
          subst X.
          apply midpoint_bet in H7.
          apply between_symmetry in H7.
          assert (C = B).
            eapply between_equality.
              apply H7.
            assumption.
          contradiction.
          assumption.
        right.
        assert(Bet B C X).
          eapply between_inner_transitivity.
            apply H4.
          apply midpoint_bet.
          apply l7_2.
          assumption.
        eapply between_exchange4.
          apply H5.
        assumption.
      assert(exists X, Midpoint X A C).
        eapply midpoint_existence.
      ex_and H6 X.
      exists X.
      repeat split.
        apply midpoint_bet.
        assumption.
      right.
      repeat split.
        intro.
        subst X.
        apply midpoint_bet in H7.
        apply between_symmetry in H7.
        assert (C = B).
          eapply between_equality.
            apply H7.
          assumption.
        contradiction.
        assumption.
      assert (Bet B C X).
        eapply between_inner_transitivity.
          apply H4.
        apply midpoint_bet.
        eapply l7_2.
        assumption.
      eapply l5_1.
        2:apply H6.
        auto.
      assumption.
    assert(exists X, Midpoint X A C).
      eapply midpoint_existence.
    ex_and H5 X.
    exists X.
    split.
      apply midpoint_bet.
      assumption.
    right.
    repeat split.
      intro.
      subst X.
      apply midpoint_bet in H6.
      apply between_symmetry in H6.
      assert (C = B).
        eapply between_equality.
          apply H6.
        assumption.
      contradiction.
      assumption.
    left.
    assert(Bet B X A).
      eapply between_exchange2.
        apply H4.
      apply midpoint_bet.
      apply l7_2.
      assumption.
    eapply between_exchange4.
      apply H5.
    assumption.
Qed.
col_in_angle
Proof.
    intros.
    induction H2.
      repeat split; try assumption.
      exists A.
      split.
        apply between_symmetry.
        apply between_trivial.
      right.
      assumption.
    repeat split; try assumption.
    exists C.
    split.
      apply between_trivial.
    right.
    assumption.
Qed.
out321__inangle
Proof.
    intros.
    assert_diffs.
    apply col_in_angle; auto.
Qed.
inangle1123
Proof.
    intros.
    apply out321__inangle; auto.
    apply out_trivial; auto.
Qed.
out341__inangle
Proof.
    intros.
    assert_diffs.
    apply col_in_angle; auto.
Qed.
inangle3123
Proof.
    intros.
    apply out341__inangle; auto.
    apply out_trivial; auto.
Qed.
in_angle_two_sides
Proof.
    intros.
    unfold InAngle in H1.
    spliter.
    ex_and H4 X.
    induction H5.
      subst X.
      unfold TS.
      repeat split.
        intro.
        apply H.
        apply col_permutation_2.
        assumption.
        intro.
        apply H0.
        apply col_permutation_2.
        assumption.
      exists B.
      split.
        apply col_trivial_3.
      assumption.
    repeat split.
      intro.
      apply H.
      apply col_permutation_2.
      assumption.
      intro.
      apply H0.
      apply col_permutation_2.
      assumption.
    exists X.
    split.
      apply out_col in H5.
      apply col_permutation_1.
      assumption.
    assumption.
Qed.
in_angle_out
Proof.
    intros.
    unfold InAngle in H0.
    spliter.
    ex_and H3 X.
    induction H4.
      subst X.
      assert( Bet A B C /\ Out B A C).
        split; assumption.
      apply not_bet_and_out in H4.
      contradiction.
    unfold Out in *.
    spliter.
    induction H8; induction H6.
      repeat split; try assumption.
      left.
      assert(Bet B A X).
        eapply between_inner_transitivity.
          apply H8.
        apply H3.
      eapply between_exchange4.
        apply H9.
      assumption.
      repeat split; try assumption.
      assert(Bet B A X).
        eapply between_inner_transitivity.
          apply H8.
        assumption.
      eapply l5_3.
        apply H9.
      assumption.
      repeat split; try assumption.
      assert(Bet B X A).
        eapply between_exchange2.
          apply H8.
        apply between_symmetry.
        assumption.
      eapply l5_1.
        2: apply H9.
        auto.
      assumption.
    repeat split; try assumption.
    right.
    assert(Bet B X A).
      eapply between_exchange2.
        apply H8.
      apply between_symmetry.
      assumption.
    eapply between_exchange4.
      apply H6.
    assumption.
Qed.
col_in_angle_out
Proof.
    intros.
    unfold InAngle in H1.
    spliter.
    ex_and H4 X.
    induction H5.
      subst X.
      contradiction.
    induction (eq_dec_points A X).
      subst X.
      assumption.
    apply not_bet_out in H0.
      assert(Out B A P /\ Out B C P).
        eapply out2_bet_out.
          assumption.
          apply H5.
        assumption.
      spliter.
      assumption.
    assert (Col B A X).
      eapply col_transitivity_1.
        2: apply col_permutation_5.
        2: apply H.
        auto.
      apply out_col in H5.
      apply col_permutation_5.
      assumption.
    eapply col_transitivity_2.
      2: apply col_permutation_3.
      2:apply H7.
      auto.
    unfold Col.
    right; right.
    apply between_symmetry.
    assumption.
Qed.
l11_25_aux
Proof.
    intros.
    unfold Out in H1.
    unfold InAngle in H.
    spliter.
    repeat  split ; try assumption.
    induction H3.
      ex_and H6 X.
      assert(exists T, Bet A' T C /\ Bet X T B).
        eapply inner_pasch.
          apply H3.
        apply between_symmetry.
        assumption.
      ex_and H8 T.
      exists T.
      split.
        assumption.
      right.
      induction H7.
        subst B.
        contradiction.
      unfold Out in *.
      spliter.
      repeat split.
        intro.
        subst T.
        apply H0.
        apply between_symmetry.
        eapply outer_transitivity_between.
          apply between_symmetry.
          apply H8.
          assumption.
        auto.
        assumption.
      induction H11.
        left.
        eapply between_exchange4.
          apply between_symmetry.
          apply H9.
        assumption.
      eapply l5_3.
        apply between_symmetry.
        apply H9.
      assumption.
    ex_and H6 X.
    induction H7.
      subst X.
      contradiction.
    assert(exists T, Bet A' T C /\ Bet B X T).
      eapply outer_pasch.
        apply between_symmetry.
        apply H3.
      apply between_symmetry.
      assumption.
    ex_and H8 T.
    exists T.
    split.
      assumption.
    right.
    unfold Out in H7.
    spliter.
    repeat split.
      intro.
      subst T.
      apply between_identity in H9.
      subst X.
      absurde.
      assumption.
    induction H11.
      eapply l5_1.
        2: apply H9.
        auto.
      assumption.
    right.
    eapply between_exchange4.
      apply H11.
    assumption.
Qed.
l11_25
Proof.
    intros.
    induction (bet_dec A B C).
      repeat split.
        unfold Out in H0.
        spliter.
        assumption.
        unfold Out in H1.
        spliter.
        assumption.
        unfold Out in H2.
        spliter.
        assumption.
      exists B.
      split.
        eapply bet_out_out_bet.
          apply H3.
          apply l6_6.
          assumption.
        apply l6_6.
        assumption.
      left.
      reflexivity.
    assert(InAngle P A' B C).
      eapply l11_25_aux.
        apply H.
        assumption.
      assumption.
    assert(InAngle P A' B C').
      apply l11_24.
      eapply l11_25_aux.
        apply l11_24.
        apply H4.
        intro.
        apply H3.
        apply between_symmetry.
        eapply bet_out_out_bet.
          apply H5.
          apply out_trivial.
          unfold InAngle in H.
          spliter.
          auto.
        assumption.
      assumption.
    unfold InAngle in H5.
    spliter.
    ex_and H8 X.
    induction H9.
      subst X.
      apply False_ind.
      apply H3.
      eapply bet_out_out_bet.
        apply H8.
        assumption.
      assumption.
    repeat split.
      assumption.
      assumption.
      intro.
      subst P'.
      unfold Out in H2.
      spliter.
      absurde.
    exists X.
    split.
      assumption.
    right.
    eapply l6_7.
      apply H9.
    apply l6_6.
    assumption.
Qed.
inangle_distincts
Proof.
  intros; unfold InAngle in *; spliter; repeat split; assumption.
Qed.
segment_construction_0
Proof.
    intros.
    induction (eq_dec_points A B).
      exists A'.
      subst B.
      apply cong_trivial_identity.
    assert(exists X : Tpoint, A' <> X).
      apply another_point.
    ex_and H0 X.
    assert(HH:=segment_construction_3 A' X A B H1 H).
    ex_and HH B'.
    exists B'.
    assumption.
Qed.
angle_construction_3
Proof.
    intros.
    assert(exists P, ~Col A' B' P).
      eapply not_col_exists.
      assumption.
    ex_and H2 P.
    induction (eq_dec_points A C).
      subst C.
      exists A'.
      apply conga_trivial_1; assumption.
    assert(exists C', CongA A B C A' B' C' /\ (OS A' B' C' P \/ Col A' B' C')).
      apply angle_construction_2.
        assumption.
        assumption.
        auto.
        assumption.
      assumption.
    ex_and H4 C'.
    exists C'.
    assumption.
Qed.
l11_28
Proof.
    intros.
    induction (eq_dec_points A C).
      subst C.
      unfold Cong_3 in H.
      spliter.
      apply cong_symmetry in H1.
      apply cong_identity in H1.
      subst C'.
      induction(eq_dec_points A B).
        subst B.
        apply cong_symmetry in H2.
        apply cong_identity in H2.
        subst B'.
        assert(exists D', Cong A' D' A D).
          apply segment_construction_0.
        ex_and H1 D'.
        exists D'.
        apply cong_symmetry in H2.
        repeat split; assumption.
      induction (eq_dec_points A D).
        exists A'.
        subst D.
        repeat split.
          apply cong_trivial_identity.
          assumption.
        apply cong_trivial_identity.
      induction (eq_dec_points B D).
        subst D.
        exists B'.
        repeat split.
          assumption.
          apply cong_trivial_identity.
        assumption.
      assert(exists D'', CongA B A D B' A' D'').
        eapply angle_construction_3.
          auto.
          auto.
        intro.
        subst B'.
        apply cong_identity in H.
        contradiction.
      ex_and H5 D''.
      assert(exists D', Out A' D'' D' /\ Cong A' D' A D).
        apply segment_construction_3.
          unfold CongA in H6.
          spliter.
          auto.
        assumption.
      ex_and H5 D'.
      exists D'.
      repeat split.
        apply cong_symmetry.
        assumption.
        assert(CongA B A D B' A' D').
          eapply (l11_10 B A D B' A' D''); try apply out_trivial; try solve [auto].
            intro.
            subst B'.
            unfold CongA in H6.
            spliter.
            absurde.
          apply l6_6.
          assumption.
        eapply (cong2_conga_cong _ A _ _ A' _).
          apply H8.
          assumption.
        Cong.
      Cong.
    unfold Cong_3 in H.
    spliter.
    (*****************)
    induction(eq_dec_points A D).
      subst D.
      exists A'.
      repeat split.
        apply cong_trivial_identity.
        apply cong_commutativity.
        assumption.
      apply cong_commutativity.
      assumption.
    unfold Col in H0.
    induction H0.
      prolong A' C' D' C D.
      exists D'.
      repeat split.
        eapply (l2_11 A C D A' C' D'); try assumption.
        apply cong_symmetry.
        assumption.
        apply cong_commutativity.
        eapply (five_segment_with_def A C D B A' C' D' B').
          repeat split; try assumption.
            apply cong_symmetry.
            assumption.
          apply cong_commutativity.
          assumption.
        assumption.
      apply cong_symmetry.
      assumption.
    induction H0.
      assert(exists D', Bet A' D' C' /\ Cong_3 A D C A' D' C').
        eapply l4_5.
          apply between_symmetry.
          assumption.
        assumption.
      ex_and H5 D'.
      unfold Cong_3 in H6.
      spliter.
      exists D'.
      repeat split.
        assumption.
        apply cong_commutativity.
        eapply (l4_2 A D C B A' D' C' B').
        repeat split; try assumption.
          apply between_symmetry.
          assumption.
        apply cong_commutativity.
        assumption.
      apply cong_commutativity.
      assumption.
    prolong C' A' D' A D.
    exists D'.
    repeat split.
      apply cong_symmetry.
      assumption.
      apply cong_commutativity.
      eapply (five_segment_with_def C A D B C' A' D' B').
        repeat split; try assumption.
          apply between_symmetry.
          assumption.
          apply cong_commutativity.
          assumption.
          apply cong_symmetry.
          assumption.
        apply cong_commutativity.
        assumption.
      auto.
    eapply l2_11.
      apply between_symmetry.
      apply H0.
      apply H5.
      apply cong_commutativity.
      assumption.
    apply cong_symmetry.
    assumption.
Qed.
bet_conga_bet
Proof.
    intros.
    unfold CongA in H0.
    spliter.
    ex_and H4 A0.
    ex_and H5 C0.
    ex_and H4 A1.
    ex_and H5 C1.
    assert(Bet A0 B C0).
      eapply outer_transitivity_between.
        2:apply H6.
        apply between_symmetry.
        eapply outer_transitivity_between.
          2:apply H4.
          apply between_symmetry.
          assumption.
        auto.
      auto.
    assert(Cong_3 A0 B C0 A1 B' C1).
      repeat split.
        apply cong_right_commutativity.
        eapply l2_11.
          apply between_symmetry.
          apply H4.
          apply H8.
          apply cong_left_commutativity.
          assumption.
        apply cong_symmetry.
        apply cong_right_commutativity.
        assumption.
        assumption.
      apply cong_right_commutativity.
      eapply l2_11.
        apply H6.
        apply between_symmetry.
        apply H10.
        apply cong_symmetry.
        apply cong_left_commutativity.
        assumption.
      apply cong_right_commutativity.
      assumption.
    assert(Bet A1 B' C1).
      eapply l4_6.
        apply H13.
      assumption.
    eapply between_inner_transitivity.
      2:apply H10.
    eapply between_exchange3.
      apply between_symmetry.
      apply H8.
    assumption.
Qed.
out_in_angle_out
Proof.
    intros.
    unfold InAngle in H0.
    spliter.
    ex_and H3 X.
    induction H4.
      subst X.
      unfold Out in H.
      spliter.
      induction H5.
        assert (A = B).
          eapply between_equality.
            apply H3.
          assumption.
        contradiction.
      assert (C = B).
        eapply between_equality.
          apply between_symmetry.
          apply H3.
        assumption.
      contradiction.
    unfold Out in H.
    spliter.
    induction H6.
      assert(Bet B A X).
        eapply between_inner_transitivity.
          apply H6.
        assumption.
      unfold Out in H4.
      spliter.
      induction H9.
        assert(Bet B A P).
          eapply between_exchange4.
            apply H7.
          assumption.
        apply bet_out; assumption.
      assert(Bet B A P \/ Bet B P A).
        eapply l5_3.
          apply H7.
        assumption.
      unfold Out.
      repeat split; assumption.
    assert (Bet B X A).
      eapply between_exchange2.
        apply H6.
      apply between_symmetry.
      assumption.
    unfold Out in H4.
    spliter.
    induction H9.
      assert(Bet B A P \/ Bet B P A).
        eapply l5_1.
          2: apply H7.
          auto.
        assumption.
      unfold Out.
      repeat split; try assumption.
    assert(Bet B P A).
      eapply between_exchange4.
        apply H9.
      assumption.
    eapply l6_6.
    apply bet_out; assumption.
Qed.
in_angle_one_side
Proof.
    intros.
    unfold InAngle in H1.
    spliter.
    ex_and H4 X.
    induction H5.
      subst X.
      apply False_ind.
      apply H.
      unfold Col.
      left.
      assumption.
    unfold OS.
    prolong C A C' C A.
    exists C'.
    assert(TS A B X C').
      repeat split.
        intro.
        apply H0.
        eapply (col_transitivity_1 _ X).
          intro.
          subst X.
          apply H.
          left.
          assumption.
          eapply (col_transitivity_1 _ A).
            auto.
            apply col_permutation_3.
            assumption.
          apply col_trivial_2.
        apply out_col.
        assumption.
        intro.
        apply H.
        eapply (col_transitivity_1 _  C').
          intro.
          subst C'.
          apply cong_symmetry in H7.
          apply cong_identity in H7.
          subst C.
          apply H.
          apply col_trivial_3.
          apply col_permutation_4.
          assumption.
        unfold Col.
        right; right.
        assumption.
      exists A.
      split.
        apply col_trivial_1.
      eapply between_exchange3.
        2: apply H6.
      apply between_symmetry.
      assumption.
    split.
      eapply l9_5.
        apply H8.
        2: apply H5.
      apply col_trivial_3.
    repeat split.
      intro.
      apply H.
      apply col_permutation_1.
      assumption.
      intro.
      apply H.
      eapply (col_transitivity_1 _ C').
        intro.
        subst C'.
        unfold TS in H8.
        spliter.
        apply H10.
        apply col_trivial_1.
        apply col_permutation_4.
        assumption.
      unfold Col.
      right; right.
      assumption.
    exists A.
    split.
      apply col_trivial_1.
    assumption.
Qed.
inangle_one_side
Proof.
    intros.
    unfold InAngle in *.
    spliter.
    ex_and H9 P'.
    ex_and H6 Q'.
    induction H10.
      subst P'.
      apply bet_col in H9.
      contradiction.
    induction H11.
      subst Q'.
      apply bet_col in H6.
      contradiction.
    assert(OS A B P' Q').
      prolong P' A T A C.
      unfold OS.
      exists T.
      unfold TS.
      assert(A <> P').
        intro.
        subst P'.
        apply out_col in H10.
        apply H0.
        Col.
      repeat split; auto.
        intro.
        apply H0.
        assert(P' <> B).
          unfold Out in H10.
          spliter.
          assumption.
        apply out_col in H10.
        ColR.
        intro.
        induction(eq_dec_points A T).
          subst T.
          apply cong_symmetry in H13.
          apply cong_identity in H13.
          subst C.
          apply H.
          Col.
        apply H.
        apply bet_col in H9.
        apply bet_col in H12.
        assert(Col T A C).
          ColR.
        eapply (col_transitivity_1 _ T); Col.
        exists A.
        split; Col.
        intro.
        apply H1.
        assert(Q' <> B).
          unfold Out in H11.
          spliter.
          assumption.
        apply out_col in H11.
        ColR.
        intro.
        induction(eq_dec_points A T).
          subst T.
          apply cong_symmetry in H13.
          apply cong_identity in H13.
          subst C.
          apply H.
          Col.
        apply H.
        apply bet_col in H9.
        apply bet_col in H12.
        assert(Col T A C).
          ColR.
        eapply (col_transitivity_1 _ T); Col.
      exists A.
      split; Col.
      assert(Bet A P' Q' \/ Bet A Q' P').
        eapply l5_3.
          apply H9.
        assumption.
      induction H15.
        eapply (outer_transitivity_between2 _ P'); Between.
      eapply (between_exchange3 P'); Between.
    assert(OS A B P P').
      eapply (out_one_side_1  _ _ _ _  B); Col.
      apply l6_6.
      auto.
    assert(OS A B Q Q').
      eapply (out_one_side_1  _ _ _ _ B); Col.
      apply l6_6.
      auto.
    eapply one_side_transitivity.
      apply H13.
    apply one_side_symmetry.
    eapply one_side_transitivity.
      apply H14.
    apply one_side_symmetry.
    assumption.
Qed.
inangle_one_side2
Proof.
    intros.
    split.
      apply (inangle_one_side _ _ C); Col.
    apply (inangle_one_side _ _ A); Col.
      apply l11_24.
      auto.
    apply l11_24.
    auto.
Qed.
in_angle_trivial_1
Proof.
    intros.
    repeat split.
      assumption.
      assumption.
      assumption.
    exists A.
    split.
      apply between_symmetry.
      apply between_trivial.
    right.
    apply out_trivial.
    auto.
Qed.
in_angle_trivial_2
Proof.
    intros.
    apply l11_24.
    apply in_angle_trivial_1; assumption.
Qed.
col_conga_col
Proof.
    intros.
    induction H.
      assert (Bet D E F).
        eapply bet_conga_bet.
          apply H.
        assumption.
      unfold Col.
      left.
      assumption.
    induction H.
      assert (Out E D F).
        eapply l11_21_a.
          2: apply H0.
        apply bet_out in H.
          apply l6_6.
          assumption.
          unfold CongA in H0.
          spliter.
          assumption.
      unfold Out in H1.
      spliter.
      unfold Col.
      induction H3.
        right; right.
        apply between_symmetry.
        assumption.
      right; left.
      assumption.
    assert (Out E D F).
      eapply l11_21_a.
        2: apply H0.
      apply between_symmetry in H.
      apply bet_out in H.
        assumption.
        unfold CongA in H0.
        spliter.
        assumption.
    unfold Out in H1.
    spliter.
    unfold Col.
    induction H3.
      right; right.
      apply between_symmetry.
      assumption.
    right; left.
    assumption.
Qed.
ncol_conga_ncol
Proof.
    intros.
    intro.
    apply H.
    eapply col_conga_col.
      apply H1.
    apply conga_sym.
    assumption.
Qed.
l11_29_a
Proof.
    intros.
    unfold LeA in H.
    ex_and H P.
    assert(E <> D /\ B <> A /\ E <> F /\ E <> P /\ B <> C).
      unfold CongA in *.
      unfold InAngle in H.
      spliter.
      repeat split.
        auto.
        auto.
        auto.
        auto.
      auto.
    spliter.
    assert(A <> B /\ C <> B).
      intuition.
    spliter.
    assert(HH:=or_bet_out A B C).
    induction HH.
      assert(Bet D E P).
        eapply bet_conga_bet.
          apply H8.
        assumption.
      exists C.
      split.
        apply in_angle_trivial_2; assumption.
      assert(HH:=H).
      unfold InAngle in HH.
      spliter.
      ex_and H13 X.
      induction H14.
        subst X.
        assert(Bet E F P \/ Bet E P F).
          eapply (l5_2 D).
            auto.
            assumption.
          assumption.
        eapply l11_10.
          apply H0.
          apply out_trivial.
          auto.
          apply out_trivial.
          auto.
          apply out_trivial.
          assumption.
        repeat split.
          auto.
          auto.
        assumption.
      assert(Out E P F).
        unfold Out in H14.
        spliter.
        induction H16.
          assert( Bet D X P).
            eapply between_exchange2.
              apply H9.
            assumption.
          assert(Bet D E X).
            eapply between_inner_transitivity.
              apply H9.
            assumption.
          assert(Bet D E F).
            eapply between_exchange4.
              apply H18.
            assumption.
          unfold Out.
          repeat split.
            auto.
            auto.
          eapply l5_2.
            2:apply H9.
            auto.
          assumption.
        assert(Bet D P X).
          eapply outer_transitivity_between2.
            apply H9.
            assumption.
          assumption.
        assert(Bet D P F).
          eapply between_exchange4.
            apply H17.
          assumption.
        assert(Bet E P F).
          eapply between_exchange3.
            apply H9.
          assumption.
        repeat split.
          auto.
          auto.
        left.
        assumption.
      eapply l11_10.
        apply H0.
        apply out_trivial.
        auto.
        apply out_trivial.
        auto.
        apply out_trivial.
        assumption.
      eapply l6_6.
      assumption.
    induction H8.
      assert(exists Q, CongA D E F A B Q).
        apply angle_construction_3.
          auto.
          auto.
        assumption.
      ex_and H9 Q.
      exists Q.
      split.
        repeat split.
          assumption.
          intro.
          subst Q.
          unfold CongA in H10.
          spliter.
          intuition.
          auto.
        (* absurde.
        assumption. *)
        exists A.
        split.
          apply between_trivial2.
        right.
        assumption.
      apply conga_sym.
      assumption.
    assert(D <> E /\ F <> E).
      intuition.
    spliter.
    assert(HH:=or_bet_out D E F).
    induction HH.
      prolong A B Q E F.
      exists Q.
      split.
        repeat split.
          assumption.
          intro.
          treat_equalities.
          auto.
          assumption.
        exists B.
        split.
          assumption.
        left.
        reflexivity.
      eapply conga_line; try assumption.
        intro.
        treat_equalities.
        auto.
    induction H11.
      assert(Out E D P).
        eapply in_angle_out.
          apply H11.
        assumption.
      assert (Out B A C).
        eapply l11_21_a.
          apply H12.
        apply conga_sym.
        assumption.
      apply False_ind.
      apply H8.
      apply out_col in H13.
      Col.
    (************)
    assert(exists Q, CongA D E F A B Q /\ OS A B Q C).
      apply angle_construction_1; assumption.
    ex_and H12 Q.
    exists Q.
    assert(exists DD, Out E D DD /\ Cong E DD B A).
      eapply segment_construction_3; auto.
    ex_and H14 DD.
    assert(exists FF, Out E F FF /\ Cong E FF B Q).
      eapply segment_construction_3.
        auto.
      unfold CongA in H12.
      spliter.
      auto.
    ex_and H16 FF.
    assert(InAngle P DD E FF).
      eapply l11_25.
        apply H.
        apply l6_6.
        assumption.
        apply l6_6.
        assumption.
      apply out_trivial.
      auto.
    assert(HH18:=H18).
    unfold InAngle in H18.
    spliter.
    ex_and H21 X.
    induction H22.
      subst X.
      assert (Bet D E F).
        eapply bet_out_out_bet.
          apply H21.
          apply l6_6.
          assumption.
        apply l6_6.
        assumption.
      apply False_ind.
      apply H11.
      unfold Col.
      left.
      assumption.
    assert(exists CC, Out B C CC /\ Cong B CC E X).
      apply segment_construction_3.
        auto.
      unfold Out in H22.
      spliter.
      auto.
    ex_and H23 CC.
    assert (CongA A B CC DD E X).
      eapply l11_10.
        apply H0.
        apply out_trivial.
        auto.
        apply l6_6.
        assumption.
        apply l6_6.
        assumption.
      assumption.
    assert(Cong A CC DD X).
      eapply cong2_conga_cong.
        apply H25.
        apply cong_symmetry.
        apply cong_commutativity.
        assumption.
      assumption.
    assert(CongA A B Q DD E FF).
      eapply l11_10.
        apply conga_sym.
        apply H12.
        apply out_trivial.
        auto.
        apply out_trivial.
        intro.
        subst Q.
        apply cong_identity in H17.
        subst FF.
        absurde.
        apply l6_6.
        assumption.
      apply l6_6.
      assumption.
    assert(Cong A Q DD FF).
      eapply cong2_conga_cong.
        apply H27.
        apply cong_symmetry.
        apply cong_commutativity.
        assumption.
      apply cong_symmetry.
      assumption.
    assert(CongA CC B Q X E FF).
      eapply (l11_22b _ _ _ A).
      split.
        apply one_side_symmetry.
        eapply out_out_one_side.
          apply invert_one_side.
          apply H13.
        assumption.
      split.
        assert(InAngle X DD E FF).
          eapply l11_25.
            apply HH18.
            apply out_trivial.
            auto.
            apply out_trivial.
            auto.
          assumption.
        apply in_angle_one_side in H29.
          apply invert_one_side in H29.
          apply H29.
          intro.
          apply H11.
          eapply col_out2_col.
            apply H30.
            apply l6_6.
            assumption.
          apply l6_6.
          assumption.
        intro.
        apply H8.
        eapply col_conga_col.
          2:apply conga_sym.
          2: apply H0.
        eapply col_out2_col.
          apply col_permutation_4.
          apply H30.
          apply l6_6.
          assumption.
        assumption.
      split.
        apply conga_sym.
        eapply l11_10.
          apply conga_sym.
          apply conga_comm.
          apply H0.
          assumption.
          apply l6_6.
          assumption.
          apply l6_6.
          assumption.
        apply out_trivial.
        auto.
      assumption.
    assert(Cong CC Q X FF).
      eapply cong2_conga_cong.
        apply H29.
        apply cong_commutativity.
        assumption.
      apply cong_symmetry.
      assumption.
    split.
      assert(InAngle CC A B Q).
        repeat split.
          assumption.
          intro.
          subst Q.
          unfold CongA in H12.
          spliter.
          absurde.
          intro.
          subst CC.
          unfold CongA in H25.
          spliter.
          auto.
        exists CC.
        split.
          eapply l4_6.
            apply H21.
          repeat split.
            cong.
            cong.
          cong.
        right.
        apply out_trivial.
        unfold Out in H23.
        spliter.
        auto.
      eapply l11_25.
        apply H31.
        apply out_trivial.
        auto.
        apply out_trivial.
        unfold CongA in H27.
        spliter.
        auto.
      assumption.
    apply conga_sym.
    assumption.
Qed.
in_angle_line
Proof.
    intros.
    repeat split; try assumption.
    exists B.
    split.
      assumption.
    left.
    reflexivity.
Qed.
l11_29_b
Proof.
    intros.
    ex_and H Q.
    unfold LeA.
    assert(HH:=H).
    unfold InAngle in HH.
    spliter.
    ex_and H4 X.
    induction H5.
      subst X.
      assert(exists P, CongA A B C D E P).
        apply angle_construction_3.
          assumption.
          assumption.
        unfold CongA in H0.
        spliter.
        assumption.
      ex_and H5 P.
      exists P.
      split.
        assert(Bet D E F).
          eapply bet_conga_bet.
            apply H4.
          assumption.
        apply in_angle_line.
          unfold CongA in H6.
          spliter.
          assumption.
          unfold CongA in H6.
          spliter.
          assumption.
          unfold CongA in H0.
          spliter.
          assumption.
        assumption.
      assumption.
    assert(exists DD, Out E D DD /\ Cong E DD B A).
      apply segment_construction_3.
        unfold CongA in H0.
        spliter.
        auto.
      auto.
    ex_and H6 DD.
    assert(exists FF, Out E F FF /\ Cong E FF B Q).
      apply segment_construction_3.
        unfold CongA in H0.
        spliter.
        auto.
      auto.
    ex_and H8 FF.
    assert(D <> E /\ DD <> E /\ F <> E /\ FF <> E).
      unfold Out in *.
      spliter.
      repeat split; try assumption.
    spliter.
    assert(HI:=or_bet_out A B C).
    induction HI.
      exists F.
      split.
        apply in_angle_trivial_2.
          assumption.
        assumption.
      assert(CongA A B C A B Q).
        eapply l11_10.
          apply conga_refl.
            apply H1.
          apply H3.
          apply out_trivial.
          auto.
          apply out_trivial.
          auto.
          apply out_trivial.
          auto.
        unfold Out in H5.
        spliter.
        induction H16.
          assert(Bet A B X).
            eapply between_inner_transitivity.
              apply H14.
            assumption.
          assert(Bet B X Q).
            eapply between_exchange3.
              apply H17.
            assumption.
          assert(Bet B Q C \/ Bet B C Q).
            eapply l5_1.
              2:apply H18.
              auto.
            assumption.
          unfold Out.
          repeat split.
            assumption.
            assumption.
          assumption.
        assert(Bet A B X).
          eapply outer_transitivity_between.
            apply H14.
            assumption.
          auto.
        assert(Bet B X Q).
          eapply between_exchange3.
            apply H17.
          assumption.
        assert(Bet B C Q).
          eapply between_exchange4.
            apply H16.
          assumption.
        unfold Out.
        repeat split.
          assumption.
          assumption.
        right.
        assumption.
      eapply conga_trans.
        apply H15.
      assumption.
    induction H14.
      exists D.
      split.
        apply in_angle_trivial_1.
          assumption.
        assumption.
      assert(CongA A B C A B A).
        eapply l11_10.
          apply conga_refl.
            apply H1.
          apply H3.
          apply out_trivial.
          auto.
          apply out_trivial.
          auto.
          apply out_trivial.
          auto.
        assumption.
      eapply conga_trans.
        apply H15.
      apply conga_trivial_1.
        assumption.
      assumption.
    assert(HJ:=or_bet_out A B Q).
    induction HJ.
      assert(exists P, CongA A B C D E P).
        apply angle_construction_3.
          assumption.
          assumption.
        unfold Out in H6.
        spliter.
        assumption.
      ex_and H16 P.
      exists P.
      split.
        apply in_angle_line.
          unfold CongA in H17.
          spliter.
          assumption.
          assumption.
          assumption.
        eapply bet_conga_bet.
          apply H15.
        assumption.
      assumption.
    induction H15.
      assert(Out B A C).
        eapply out_in_angle_out.
          apply H15.
        assumption.
      apply False_ind.
      apply H14.
      unfold Out in H16.
      spliter.
      unfold Col.
      induction H18.
        right; right.
        apply between_symmetry.
        assumption.
      right; left.
      assumption.
    assert(exists P, CongA A B C D E P /\ OS D E P F).
      eapply angle_construction_1.
        assumption.
      eapply ncol_conga_ncol.
        apply H15.
      apply H0.
    ex_and H16 P.
    exists P.
    split.
      assert(exists PP, Out E P PP /\ Cong E PP B X).
        eapply segment_construction_3.
          unfold CongA in H16.
          spliter.
          auto.
        unfold Out in H5.
        spliter.
        auto.
      ex_and H18 PP.
      eapply l11_25.
        2:apply H6.
        2:apply H8.
        2:apply H18.
      repeat split.
        assumption.
        assumption.
        unfold Out in H18.
        spliter.
        assumption.
      exists PP.
      split.
        assert(CongA C B Q P E F).
          eapply (l11_22b _ _ _ A).
          split.
            apply invert_one_side.
            eapply in_angle_one_side.
              assumption.
              intro.
              apply H14.
              apply col_permutation_4.
              assumption.
            assumption.
          split.
            apply invert_one_side.
            apply H17.
          split.
            apply conga_comm.
            assumption.
          assumption.
        assert (Cong DD FF A Q).
          eapply cong2_conga_cong.
            eapply l11_10.
              apply conga_sym.
              apply H0.
              apply l6_6.
              assumption.
              apply l6_6.
              assumption.
              apply l6_6.
              apply out_trivial.
              auto.
            apply out_trivial.
            auto.
            apply cong_commutativity.
            assumption.
          assumption.
        assert(Cong A X DD PP).
          eapply cong2_conga_cong.
            eapply l11_10.
              apply H16.
              apply out_trivial.
              auto.
              assumption.
              apply l6_6.
              assumption.
            apply l6_6.
            assumption.
            apply cong_symmetry.
            apply cong_commutativity.
            assumption.
          apply cong_symmetry.
          assumption.
        assert(Cong X Q PP FF).
          eapply cong2_conga_cong.
            eapply l11_10.
              apply H20.
              assumption.
              apply out_trivial.
              auto.
              apply l6_6.
              assumption.
            apply l6_6.
            assumption.
            apply cong_symmetry.
            apply cong_commutativity.
            assumption.
          apply cong_symmetry.
          assumption.
        eapply l4_6.
          apply H4.
        repeat split.
          assumption.
          apply cong_symmetry.
          assumption.
        assumption.
      right.
      apply out_trivial.
      unfold Out in H15.
      spliter.
      unfold Out in H18.
      spliter.
      auto.
    assumption.
Qed.
bet_in_angle_bet
Proof.
    intros.
    unfold InAngle in H0.
    spliter.
    ex_and H3 X.
    induction H4.
      subst X.
      assumption.
    unfold Out in H4.
    spliter.
    induction H6.
      assert(Bet A X P).
        eapply between_exchange2.
          apply H.
        assumption.
      assert(Bet A P C \/ Bet A C P).
        eapply (l5_1 _ X).
          intro.
          subst X.
          assert(A = B).
            eapply between_equality.
              apply H.
            assumption.
          contradiction.
          assumption.
        assumption.
      induction H8.
        eapply between_exchange4.
          apply H.
        assumption.
      assert(Bet A B X).
        eapply between_inner_transitivity.
          apply H.
        assumption.
      eapply between_exchange4.
        apply H9.
      assumption.
    assert(Bet A B X).
      eapply outer_transitivity_between.
        apply H.
        assumption.
      auto.
    eapply between_exchange4.
      apply H7.
    assumption.
Qed.
lea_line
Proof.
    intros.
    unfold LeA in H0.
    ex_and H0 PP.
    assert (HH:=H0).
    unfold InAngle in H0.
    spliter.
    ex_and H4 X.
    induction H5.
      subst X.
      assumption.
    assert (Bet A B PP).
      eapply bet_conga_bet.
        apply H.
      assumption.
    eapply bet_in_angle_bet.
      apply H6.
    assumption.
Qed.
eq_conga_out
Proof.
    intros.
    assert(HH:=H).
    unfold CongA in H.
    spliter.
    ex_and H3 A'.
    ex_and H4 C'.
    ex_and H3 D'.
    ex_and H4 F'.
    assert(Cong_3 B A' C' E D' F').
      repeat split.
        apply cong_right_commutativity.
        eapply l2_11.
          apply H3.
          apply between_symmetry.
          apply H7.
          apply cong_right_commutativity.
          apply cong_symmetry.
          assumption.
        apply cong_right_commutativity.
        assumption.
        apply cong_right_commutativity.
        eapply l2_11.
          apply H5.
          apply between_symmetry.
          apply H9.
          apply cong_right_commutativity.
          apply cong_symmetry.
          assumption.
        apply cong_right_commutativity.
        assumption.
      assumption.
    assert(Out E D' F').
      eapply cong3_preserves_out.
        2:apply H12.
      unfold Out.
      repeat split.
        intro.
        subst A'.
        apply between_identity in H3.
        subst A.
        absurde.
        intro.
        subst C'.
        apply between_identity in H5.
        subst A.
        absurde.
      eapply l5_1.
        2:apply H3.
        auto.
      assumption.
    eapply bet2_out_out.
      assumption.
      assumption.
      apply H13.
      assumption.
    assumption.
Qed.
out_conga_out
Proof.
    intros.
    assert(HH:=H).
    unfold Out in H.
    spliter.
    assert(D <> E /\ F <> E).
      unfold CongA in H0.
      spliter.
      split; assumption.
    spliter.
    assert(CongA A B A A B C).
      eapply l11_10.
        apply conga_refl.
          apply H.
        apply H1.
        apply out_trivial.
        auto.
        assumption.
        apply out_trivial.
        auto.
      apply out_trivial.
      auto.
    assert(CongA A B A D E F).
      eapply conga_trans.
        apply H5.
      assumption.
    eapply eq_conga_out.
    apply H6.
Qed.
conga_ex_cong3
Proof.
    intros.
    assert(B <> A /\ B <> C /\ B' <> A' /\ B' <> C').
      unfold CongA in H.
      spliter.
      repeat split; auto.
    spliter.
    assert(exists AA, Out B A AA /\ Cong B AA B' A').
      apply segment_construction_3; assumption.
    assert(exists CC, Out B C CC /\ Cong B CC B' C').
      apply segment_construction_3; assumption.
    ex_and H4 AA.
    ex_and H5 CC.
    exists AA.
    exists CC.
    intros.
    repeat split.
      apply cong_commutativity.
      assumption.
      eapply cong2_conga_cong.
        eapply l11_10.
          apply H.
          apply l6_6.
          assumption.
          apply l6_6.
          assumption.
          apply out_trivial.
          auto.
        apply out_trivial.
        auto.
        Cong.
      assumption.
    assumption.
Qed.
conga_preserves_in_angle
Proof.
    intros.
    assert(A <> B /\ C <> B /\ A' <> B' /\ C' <> B' /\ I <> B /\ I' <> B').
      unfold CongA in *.
      spliter.
      repeat split; assumption.
    spliter.
    assert(HH1:= or_bet_out A B C).
    induction HH1.
      assert(Bet A' B' C').
        eapply bet_conga_bet.
          apply H9.
        assumption.
      apply in_angle_line; assumption.
    induction H9.
      assert(Out B A I).
        eapply out_in_angle_out.
          apply H9.
        assumption.
      assert(Out B' A' I').
        eapply out_conga_out.
          apply H10.
        assumption.
      apply out_in_angle.
        eapply out_conga_out.
          apply H9.
        assumption.
      apply l6_6.
      assumption.
    assert(HH2:= or_bet_out A B I).
    induction HH2.
      assert(Bet A B C).
        eapply bet_in_angle_bet.
          apply H10.
        assumption.
      apply False_ind.
      apply H9.
      unfold Col.
      left.
      assumption.
    induction H10.
      assert(Out B' A' I').
        eapply out_conga_out.
          apply H10.
        assumption.
      eapply col_in_angle; try assumption.
      left.
      assumption.
    (*****************************)
    assert(exists AA', Out B' A' AA' /\ Cong B' AA' B A).
      apply segment_construction_3; auto.
    assert(exists CC', Out B' C' CC' /\ Cong B' CC' B C).
      apply segment_construction_3; auto.
    ex_and H11 AA'.
    ex_and H12 CC'.
    assert(HH:=H1).
    unfold InAngle in H1.
    spliter.
    ex_and H17 J.
    induction H18.
      subst J.
      eapply in_angle_line; try assumption.
      eapply bet_conga_bet.
        apply H17.
      assumption.
    assert(B <> J).
      unfold Out in H18.
      spliter.
      auto.
    assert(~Col A B J).
      intro.
      apply H10.
      apply col_permutation_2.
      eapply (col_transitivity_1 _ J).
        assumption.
        apply out_col.
        assumption.
      apply col_permutation_1.
      assumption.
    assert(exists J', CongA A B J  A' B' J' /\ OS A' B' J' I').
      apply angle_construction_1.
        intro.
        apply H10.
        apply col_permutation_2.
        eapply (col_transitivity_1 _ J).
          unfold Out in H18.
          spliter.
          auto.
          apply out_col.
          assumption.
        apply col_permutation_1.
        assumption.
      eapply ncol_conga_ncol.
        apply H10.
      assumption.
    ex_and H21 J'.
    assert(B' <> J').
      unfold CongA in H21.
      spliter.
      auto.
    assert(exists JJ', Out B' J' JJ' /\ Cong B' JJ' B J).
      apply segment_construction_3.
        assumption.
      assumption.
    ex_and H24 JJ'.
    assert(~Col A' B' J').
      intro.
      apply H20.
      eapply col_conga_col.
        apply H26.
      apply conga_sym.
      assumption.
    assert(A' <> JJ').
      intro.
      subst JJ'.
      apply H20.
      eapply col_conga_col.
        apply out_col in H24.
        apply col_permutation_2.
        apply H24.
      apply conga_sym.
      assumption.
    assert(B' <> JJ').
      unfold Out in H24.
      spliter.
      auto.
    assert(~Col A' B' JJ').
      intro.
      apply H26.
      apply col_permutation_2.
      eapply (col_transitivity_1 _ JJ').
        assumption.
        apply col_permutation_5.
        apply out_col.
        assumption.
      apply col_permutation_1.
      assumption.
    (****************************************************************)
    assert(CongA A B C AA' B' CC').
      eapply l11_10.
        apply H.
        apply out_trivial.
        auto.
        apply out_trivial.
        auto.
        apply l6_6.
        assumption.
      apply l6_6.
      assumption.
    assert(CongA A' B' J' A' B' JJ').
      eapply l11_10.
        apply conga_refl.
          apply H5.
        3: apply H24.
        auto.
        apply out_trivial.
        auto.
        apply out_trivial.
        auto.
      apply out_trivial.
      auto.
    assert(Out B' I' JJ' \/ TS A' B' I' JJ').
      apply conga__or_out_ts.
      eapply conga_trans.
        apply conga_sym.
        apply H0.
      apply conga_sym.
      eapply conga_trans.
        apply conga_sym.
        apply H31.
      eapply conga_trans.
        apply conga_sym.
        apply H21.
      eapply l11_10.
        apply (conga_refl A B I).
          assumption.
        assumption.
        apply out_trivial.
        auto.
        assumption.
        apply out_trivial.
        auto.
      apply out_trivial.
      auto.
    induction H32.
      assert(CongA J B C J' B' C').
        eapply (l11_22b _ _ _ A _ _ _ A').
        split.
          apply invert_one_side.
          apply in_angle_one_side.
            assumption.
            intro.
            apply H10.
            apply col_permutation_2.
            eapply (col_transitivity_1 _ J).
              assumption.
              apply out_col.
              assumption.
            apply col_permutation_5.
            assumption.
          eapply l11_25.
            apply HH.
            apply out_trivial.
            auto.
            apply out_trivial.
            auto.
          assumption.
        split.
          eapply one_side_transitivity.
            2:apply invert_one_side.
            2:apply H2.
          apply invert_one_side.
          assumption.
        split.
          apply conga_comm.
          assumption.
        assumption.
      assert(Cong A C AA' CC').
        eapply cong2_conga_cong.
          eapply l11_10.
            apply H.
            apply out_trivial.
            auto.
            apply out_trivial.
            auto.
            apply l6_6.
            assumption.
          apply l6_6.
          assumption.
          apply cong_symmetry.
          apply cong_commutativity.
          assumption.
        apply cong_symmetry.
        assumption.
      assert(Cong A J AA' JJ').
        eapply cong2_conga_cong.
          eapply l11_10.
            apply H0.
            apply out_trivial.
            auto.
            assumption.
            apply l6_6.
            assumption.
          apply l6_6.
          assumption.
          apply cong_symmetry.
          apply cong_commutativity.
          assumption.
        apply cong_symmetry.
        assumption.
      assert(CongA J' B' C' JJ' B' CC').
        eapply l11_10.
          apply conga_refl.
            4:apply H12.
          3:apply H24.
          auto.
          unfold CongA in H30.
          spliter.
          assumption.
          apply out_trivial.
          auto.
        apply out_trivial.
        unfold CongA in H30.
        spliter.
        auto.
      assert(Cong J C JJ' CC').
        eapply (cong2_conga_cong).
          eapply conga_trans.
            apply H33.
          apply H36.
          apply cong_symmetry.
          apply cong_commutativity.
          assumption.
        apply cong_symmetry.
        assumption.
      assert(Bet AA' JJ' CC').
        eapply l4_6.
          apply H17.
        repeat split.
          assumption.
          assumption.
        assumption.
      eapply l11_25.
        2: apply H11.
        2: apply H12.
        unfold InAngle.
        repeat split; try assumption.
          unfold Out in H11.
          spliter.
          assumption.
          unfold Out in H12.
          spliter.
          assumption.
          3:apply H32.
        auto.
      exists JJ'.
      split.
        assumption.
      right.
      apply out_trivial.
      auto.
    assert(OS B' A' I' JJ').
      eapply out_out_one_side.
        apply invert_one_side.
        apply one_side_symmetry.
        apply H22.
      assumption.
    apply invert_two_sides in H32.
    apply l9_9 in H32.
    contradiction.
Qed.
l11_30
Proof.
    intros.
    assert(HH:=H).
    apply l11_29_a in H.
    ex_and H Q.
    apply l11_29_b.
    assert(A <> B /\ C <> B /\ A' <> B' /\ C' <> B' /\ D <> E /\ F <> E /\ D' <> E' /\ F' <> E').
      unfold CongA in *.
      spliter.
      repeat split; assumption.
    spliter.
    assert(Hi:=or_bet_out A' B' C').
    induction Hi.
      prolong A' B' Q' A' B'.
      exists Q'.
      assert(B' <> Q').
        intro.
        subst Q'.
        apply cong_symmetry in H13.
        apply cong_identity in H13.
        contradiction.
      assert(A' <> Q').
        intro.
        subst Q'.
        apply between_identity in H12.
        contradiction.
      assert(CongA A' B' Q' A' B' C').
        apply conga_line; try assumption.
          auto.
      split.
        apply in_angle_line; try assumption.
        auto.
      assert(Bet A B C).
        eapply bet_conga_bet.
          apply H11.
        apply conga_sym.
        assumption.
      assert(Bet A B Q).
        eapply lea_line.
          apply H17.
        apply l11_29_b.
        exists Q.
        split.
          assumption.
        apply conga_refl.
          assumption.
        unfold CongA in H2.
        spliter.
        assumption.
      assert(Bet D E F).
        eapply bet_conga_bet.
          apply H18.
        assumption.
      assert (Bet D' E' F').
        eapply bet_conga_bet.
          apply H19.
        assumption.
      eapply conga_line; try assumption.
        auto.
    (************************)
    induction H11.
      assert(exists Q', CongA D' E' F' A' B' Q').
        eapply angle_construction_3; assumption.
      ex_and H12 Q'.
      exists Q'.
      split.
        apply col_in_angle; try assumption.
          unfold CongA in H13.
          spliter.
          assumption.
        left.
        assumption.
      apply conga_sym.
      assumption.
    assert(Hi:=or_bet_out D' E' F').
    induction Hi.
      assert(exists Q', CongA  D' E' F' A' B' Q').
        eapply angle_construction_3; try assumption.
      ex_and H13 Q'.
      exists Q'.
      assert(Bet A' B' Q').
        eapply bet_conga_bet.
          apply H12.
        assumption.
      split.
        apply in_angle_line; try assumption.
        unfold CongA in H14.
        spliter.
        assumption.
      apply conga_sym.
      assumption.
    induction H12.
      assert(exists Q', CongA  D' E' F' A' B' Q').
        eapply angle_construction_3; try assumption.
      ex_and H13 Q'.
      exists Q'.
      assert(Out B' A' Q').
        eapply out_conga_out.
          apply H12.
        assumption.
      assert(CongA A B Q D' E' F').
        eapply conga_trans.
          apply H2.
        assumption.
      assert(Out B A Q).
        eapply out_conga_out.
          apply H12.
        apply conga_sym.
        assumption.
      assert(Out B A C).
        eapply out_in_angle_out.
          apply H16.
        assumption.
      assert(Out  B' A' C').
        eapply out_conga_out.
          apply H17.
        assumption.
      split.
        eapply out_in_angle.
          assumption.
        apply l6_6.
        assumption.
      apply conga_sym.
      assumption.
    assert(exists QQ, CongA D' E' F' A' B' QQ /\ OS A' B' QQ C').
      eapply angle_construction_1.
        assumption.
      assumption.
    ex_and H13 Q'.
    exists Q'.
    split.
      eapply conga_preserves_in_angle.
        3: apply H.
        eapply conga_trans.
          apply H2.
        eapply conga_trans.
          apply H1.
        assumption.
        apply H0.
      (************** etrange ****************)
      try assumption.
      apply one_side_symmetry.
      assumption.
    apply conga_sym.
    assumption.
Qed.
l11_31_1
Proof.
    intros.
    unfold LeA.
    exists D.
    split.
      apply in_angle_trivial_1; assumption.
    apply l11_21_b.
      assumption.
    apply out_trivial.
    auto.
Qed.
l11_31_2
Proof.
intros; destruct (angle_construction_3 A B C D E) as [P HCongA]; auto.
exists P; split; try apply in_angle_line; unfold CongA in *; spliter; auto.
Qed.
lea_refl
Proof.
    intros.
    unfold LeA.
    exists C .
    split.
      apply in_angle_trivial_2; assumption.
    apply conga_refl; assumption.
Qed.
conga__lea
Proof.
    intros.
    unfold LeA.
    exists F.
    split.
      apply in_angle_trivial_2.
        apply (conga_diff45 A B C D E F); assumption.
        apply (conga_diff56 A B C D); assumption.
    assumption.
Qed.
conga__lea456123
Proof.
    intros; apply conga__lea, conga_sym; trivial.
Qed.
lea121345
Proof.
  intros A B C D E HAB HCD HDE.
  apply l11_31_1; try (apply out_trivial); auto.
Qed.
inangle__lea
Proof.
  intros A B C P HIn.
  exists P; split; trivial.
  unfold InAngle in HIn; spliter.
  apply conga_refl; auto.
Qed.
in_angle_trans
Proof.
    intros.
    assert(HA1 :=H).
    assert(HA2:= H0).
    unfold InAngle in H.
    unfold InAngle in H0.
    spliter.
    ex_and H3 DD.
    ex_and H6 CC.
    induction H8; induction H7.
      subst CC.
      subst DD.
      apply in_angle_line; assumption.
      subst CC.
      assert(Bet A B E).
        eapply bet_in_angle_bet.
          apply H6.
        assumption.
      apply in_angle_line; assumption.
      subst DD.
      apply in_angle_line; assumption.
    assert(InAngle C A B DD).
      eapply l11_25.
        apply HA1.
        apply out_trivial.
        auto.
        assumption.
      apply out_trivial.
      auto.
    unfold InAngle in H9.
    spliter.
    ex_and H12 CC'.
    induction H13.
      subst CC'.
      assert(Bet A B E).
        eapply between_exchange4.
          apply H12.
        assumption.
      apply in_angle_line; assumption.
    eapply l11_25.
      4: apply l6_6.
      4:apply H13.
      2: apply out_trivial.
      3: apply out_trivial.
      unfold InAngle.
      repeat split; try assumption.
        unfold Out in H13.
        spliter.
        assumption.
      exists CC'.
      split.
        eapply between_exchange4.
          apply H12.
        assumption.
      right.
      apply out_trivial.
      unfold Out in H13.
      spliter.
      auto.
      auto.
    auto.
Qed.
lea_trans
Proof.
    intros.
    assert(Hlea1 := H).
    assert (Hlea2 := H0).
    unfold LeA in H.
    unfold LeA in H0.
    ex_and H P1.
    ex_and H0 P2.
    assert( A <> B /\ C <> B /\ A1 <> B1 /\ C1 <> B1 /\ A2 <> B2 /\ C2 <> B2).
      unfold CongA in *.
      unfold InAngle in H0.
      spliter.
      repeat split; assumption.
    spliter.
    assert(HH1 := or_bet_out A B C).
    induction HH1.
      assert(Bet A1 B1 P1).
        eapply bet_conga_bet.
          apply H9.
        assumption.
      assert(Bet A1 B1 C1).
        eapply bet_in_angle_bet.
          apply H10.
        assumption.
      assert(Bet A2 B2 P2).
        eapply bet_conga_bet.
          apply H11.
        assumption.
      assert(Bet A2 B2 C2).
        eapply bet_in_angle_bet.
          apply H12.
        assumption.
      apply l11_31_2; assumption.
    induction H9.
      apply l11_31_1; assumption.
    assert(HH2 := or_bet_out A2 B2 C2).
    induction HH2.
      apply l11_31_2; assumption.
    induction H10.
      assert(Out B2 A2 P2).
        eapply in_angle_out.
          apply H10.
        assumption.
      assert(Out B1 A1 C1).
        eapply out_conga_out.
          apply H11.
        apply conga_sym.
        assumption.
      assert(Out B1 A1 P1).
        eapply in_angle_out.
          apply H12.
        assumption.
      assert(Out B A C).
        eapply out_conga_out.
          apply H13.
        apply conga_sym.
        assumption.
      apply l11_31_1; assumption.
    assert(exists P, CongA A B C A2 B2 P /\ OS A2 B2 P C2).
      apply angle_construction_1; assumption.
    ex_and H11 P.
    assert (OS A2 B2 P2 C2).
      apply in_angle_one_side.
        assumption.
        assert (B2 <> A2).
          auto.
        assert(P2 <> A2).
          intro.
          subst P2.
          assert(Out B1 A1 C1).
            eapply out_conga_out.
              2: apply conga_sym.
              2:apply H2.
            apply out_trivial.
            assumption.
          assert(Out B1 A1 P1).
            eapply out_in_angle_out.
              apply H14.
            assumption.
          assert(Out B A C).
            eapply out_conga_out.
              apply H15.
            apply conga_sym.
            assumption.
          apply H9.
          apply out_col in H16.
          apply col_permutation_4.
          assumption.
        assert(HH:=or_bet_out A2 B2 P2 ).
        induction HH.
          assert (Bet A2 B2 C2).
            eapply bet_in_angle_bet.
              apply H15.
            apply H0.
          intro.
          apply H10.
          unfold Col.
          left.
          assumption.
          induction H15.
            assert(Out B1 A1 C1).
              eapply out_conga_out.
                apply H15.
              apply conga_sym.
              assumption.
            assert( Out B1 A1 P1).
              eapply in_angle_out.
                apply H16.
              assumption.
            assert (Out B A C).
              eapply out_conga_out.
                apply H17.
              apply conga_sym.
              assumption.
            apply False_ind.
            apply H9.
            apply out_col in H18.
            apply col_permutation_4.
            assumption.
          intro.
          apply H15.
          apply col_permutation_4.
          assumption.
          assumption.
        unfold CongA in H2.
    assert(OS A2 B2 P P2).
      eapply one_side_transitivity.
        apply H12; eapply out_conga_out.
      apply one_side_symmetry.
      assumption.
    unfold LeA.
    exists P.
    split.
      eapply (in_angle_trans _ _ _ P2).
        eapply conga_preserves_in_angle.
          apply H2.
          2: apply H.
          eapply conga_trans.
            apply conga_sym.
            apply H1.
          assumption.
        assumption.
      assumption.
    assumption.
Qed.
in_angle_asym
Proof.
    intros.
    unfold InAngle in *.
    spliter.
    ex_and H3 CC.
    ex_and H6 DD.
    induction H7; induction H8.
      subst DD.
      subst CC.
      apply conga_line; try assumption.
        auto.
        auto.
      subst CC.
      unfold Out in H8.
      spliter.
      induction H9.
        assert(Bet A B C).
          eapply between_exchange4.
            2: apply H6.
          eapply between_inner_transitivity.
            apply H3.
          assumption.
        apply conga_line; try assumption.
          auto.
          auto.
      assert(Bet A B C).
        eapply between_exchange4.
          eapply outer_transitivity_between.
            apply H3.
            apply H9.
          auto.
        assumption.
        apply conga_line; try assumption.
          auto.
          auto.
      subst DD.
      assert(Bet A B D).
        unfold Out in H7.
        spliter.
        induction H9.
          eapply between_exchange4.
            eapply between_inner_transitivity.
              apply H6.
            apply H9.
          assumption.
        eapply between_exchange4.
          eapply outer_transitivity_between.
            apply H6.
            apply H9.
          auto.
        assumption.
        apply conga_line; try assumption.
          auto.
          auto.
    assert(exists B', Bet CC B' C /\ Bet DD B' D).
      eapply inner_pasch.
        apply between_symmetry.
        apply H3.
      apply between_symmetry.
      assumption.
    ex_and H9 X.
    assert (Out B X C).
      eapply out_bet_out_2.
        apply H7.
      assumption.
    assert(Out B X D).
      eapply out_bet_out_2.
        apply H8.
      assumption.
    assert (Out B C D).
      eapply out2_out_1.
        apply H11.
      assumption.
    eapply l11_10.
      apply conga_refl.
        4:apply H13.
      3: apply out_trivial.
      assumption.
      assumption; apply H7.
      auto.
      apply out_trivial.
      auto.
    apply out_trivial.
    auto.
Qed.
lea_asym
Proof.
    intros.
    apply l11_29_a in H.
    unfold LeA in *.
    ex_and H Q.
    ex_and H0 P.
    assert(A <> B /\ Q <> B /\ P <> B /\ D <> E /\ F <> E).
      unfold CongA in *.
      spliter.
      repeat split; assumption.
    spliter.
    assert(CongA A B Q A B P).
      eapply conga_trans.
        apply H1.
      assumption.
    assert(HH1:= or_bet_out A B Q).
    induction HH1.
      assert(Bet A B P).
        eapply bet_conga_bet.
          apply H9.
        assumption.
      assert(Bet A B C).
        eapply bet_in_angle_bet.
          apply H10.
        assumption.
      assert(Bet D E F).
        eapply bet_conga_bet.
          apply H9.
        assumption.
      eapply conga_line; try assumption.
        unfold InAngle in H0.
        spliter.
        auto.
        auto.
    induction H9.
      assert(Out E D F).
        eapply out_conga_out.
          apply H9.
        assumption.
      assert(Out B A P).
        eapply out_conga_out.
          apply H10.
        apply H2.
      assert(Out B A C).
        eapply in_angle_out.
          apply H9.
        assumption.
      eapply l11_21_b.
        assumption.
      assumption.
    assert(HH2:= or_bet_out A B P).
    induction HH2.
      assert(Bet A B C).
        eapply bet_in_angle_bet.
          apply H10.
        assumption.
      assert(Bet D E F).
        eapply bet_conga_bet.
          apply H10.
        apply conga_sym.
        assumption.
      apply conga_line; try assumption.
        unfold InAngle in H0.
        spliter.
        auto.
        auto.
    induction H10.
      assert(Out B A Q).
        eapply out_conga_out.
          apply H10.
        apply conga_sym.
        assumption.
      assert (Out B A C).
        eapply in_angle_out.
          apply H11.
        assumption.
      assert(Out E D F).
        eapply out_conga_out.
          apply H11.
        assumption.
      apply l11_21_b.
        assumption.
      assumption.
    assert(Out B P Q \/ TS A B P Q).
      apply conga__or_out_ts.
      apply conga_sym.
      assumption.
    induction H11.
      assert(InAngle C A B P).
        eapply l11_25.
          3: apply H11.
          apply H.
          apply out_trivial.
          auto.
        apply out_trivial.
        intro.
        subst C.
        unfold InAngle in H0.
        spliter.
        absurde.
      assert(CongA A B C A B P).
        apply in_angle_asym; assumption.
      eapply conga_trans.
        apply H13.
      eapply conga_trans.
        apply conga_sym.
        apply H8.
      assumption.
    assert(C <> B).
      unfold InAngle in H0.
      spliter.
      assumption.
    assert(HH:=or_bet_out A B C).
    induction HH.
      assert(Bet A B Q).
        eapply bet_in_angle_bet.
          apply H13.
        apply H.
      apply False_ind.
      apply H9.
      unfold Col.
      left.
      assumption.
    induction H13.
      assert(Out B A P).
        eapply in_angle_out.
          apply H13.
        assumption.
      apply False_ind.
      apply H10.
      apply out_col in H14.
      apply col_permutation_4.
      assumption.
    apply in_angle_one_side in H.
      apply in_angle_one_side in H0.
        assert(OS A B P Q).
          eapply one_side_transitivity.
            apply H0.
          assumption.
        apply l9_9 in H14.
          contradiction.
        assumption.
        assumption.
      intro.
      apply H10.
      apply col_permutation_4.
      assumption.
      assumption.
    intro.
    apply H13.
    apply col_permutation_4.
    assumption.
Qed.
two_sides_in_angle
Proof.
    intros.
    unfold TS in H0.
    spliter.
    ex_and H3 T.
    assert(A <> B).
      intro.
      subst A.
      apply H0.
      apply col_trivial_1.
    assert(C <> B).
      intro.
      subst C.
      apply H2.
      apply col_trivial_1.
    induction (eq_dec_points B T).
      subst T.
      left.
      repeat split.
        assumption.
        assumption.
        intro.
        subst B.
        Col.
      exists B.
      split.
        assumption.
      left.
      reflexivity.
    assert(P <> B /\ T <> B).
      split.
        intro.
        subst B.
        Col.
      auto.
    spliter.
    assert(HH:= or_bet_out P B T).
    induction HH.
      right.
      unfold InAngle.
      repeat split; try assumption.
        unfold Out in H1.
        spliter.
        auto.
      exists T.
      split.
        assumption.
      right.
      unfold Out.
      repeat split.
        auto.
        auto.
      eapply l5_2.
        2:apply H10.
        auto.
      assumption.
    induction H10.
      left.
      unfold InAngle.
      repeat split; try assumption.
      auto.
      exists T.
      split.
        assumption.
      right.
      apply l6_6.
      assumption.
    apply col_permutation_3 in H3.
    contradiction.
Qed.
col_perp_perp_col
Proof.
apply upper_dim_implies_col_perp_perp_col;
apply all_coplanar_implies_upper_dim; unfold all_coplanar_axiom;
apply all_coplanar.
Qed.
not_two_sides_one_side
Proof.
apply upper_dim_implies_not_two_sides_one_side;
apply all_coplanar_implies_upper_dim; unfold all_coplanar_axiom;
apply all_coplanar.
Qed.
in_angle_reverse
Proof.
    intros.
    assert (Hd := H1).
    apply inangle_distincts in Hd.
    spliter.
    induction (Col_dec B A C).
      assert(HH:=or_bet_out C B A).
      induction HH.
        assert(Bet A B D).
          eapply bet_in_angle_bet.
            apply between_symmetry.
            apply H6.
          assumption.
        assert(Out B A' C).
          repeat split; try assumption.
          eapply l5_2.
            apply H2.
            assumption.
          apply between_symmetry.
          assumption.
        assert( Out B D A').
          repeat split; try assumption.
          eapply l5_2.
            apply H2.
            assumption.
          assumption.
        apply out_in_angle.
          assumption.
        assumption.
      induction H6.
        repeat split; try assumption.
        exists B.
        split.
          unfold Out in H6.
          spliter.
          induction H8.
            eapply between_inner_transitivity.
              apply between_symmetry.
              apply H0.
            assumption.
          eapply outer_transitivity_between.
            apply between_symmetry.
            apply H0.
            assumption.
          auto.
        left.
        reflexivity.
      apply False_ind.
      apply H6.
      apply col_permutation_2.
      assumption.
    induction (Col_dec B D C).
      assert(HH:=or_bet_out C B D).
      induction HH.
        assert(OS A B C D).
          apply in_angle_one_side.
            intro.
            apply H5.
            eapply (col_transitivity_1 _ D).
              auto.
              apply col_permutation_1.
              assumption.
            assumption.
            assumption.
          assumption.
        assert(TS A B C D).
          repeat split; try assumption.
            intro.
            apply H5.
            apply col_permutation_3.
            assumption.
            intro.
            apply H5.
            eapply (col_transitivity_1 _ D).
              auto.
              apply col_permutation_2.
              assumption.
            assumption.
          exists B.
          split.
            apply col_trivial_3.
          assumption.
        apply l9_9 in H9.
        contradiction.
      induction H7.
        assert(InAngle C A' B C).
          apply in_angle_trivial_2; assumption.
        eapply l11_25.
          apply H8.
          apply out_trivial.
          auto.
          apply out_trivial.
          auto.
        apply l6_6.
        assumption.
      apply False_ind.
      apply H7.
      apply col_permutation_2.
      assumption.
    assert( HH:= H1).
    apply in_angle_two_sides in HH.
      assert(HH1:=H1).
      unfold InAngle in H1.
      spliter.
      ex_and H9 X.
      induction H10.
        subst X.
        apply col_in_angle; try assumption.
        left.
        repeat split; try assumption.
        eapply l5_2.
          apply H1.
          assumption.
        assumption.
      assert(HH0:= HH).
      unfold TS in HH.
      assert (C <> B).
        spliter.
        intro.
        subst B.
        Col.
      spliter.
      assert(OS D B C A).
        apply in_angle_one_side.
          intro.
          apply H12.
          apply col_permutation_1.
          eapply (col_transitivity_1 _ X).
            unfold Out in H10.
            spliter.
            auto.
            apply col_permutation_1.
            eapply (col_transitivity_1 _ D).
              intro.
              subst D.
              apply between_identity in H9.
              subst X.
              ex_and H14 T.
              apply between_identity in H14.
              subst T.
              contradiction.
              apply col_permutation_2.
              assumption.
            apply col_permutation_5.
            apply bet_col.
            assumption.
          apply out_col.
          assumption.
          intro.
          apply H13.
          apply col_permutation_1.
          assumption.
        apply l11_24.
        assumption.
      assert(~Col A D B).
        intro.
        apply H12.
        apply col_permutation_1.
        eapply (col_transitivity_1 _ X).
          unfold Out in H10.
          spliter.
          auto.
          apply col_permutation_1.
          eapply (col_transitivity_1 _ D).
            intro.
            subst D.
            apply between_identity in H9.
            subst X.
            apply H13.
            apply col_permutation_1.
            apply out_col.
            assumption.
            assumption.
          apply col_permutation_5.
          apply bet_col.
          assumption.
        apply out_col.
        assumption.
      assert(~Col A' D B).
        intro.
        apply H16.
        apply col_permutation_1.
        eapply (col_transitivity_1 _ A').
          auto.
          apply col_permutation_1.
          apply bet_col.
          assumption.
        apply col_permutation_2.
        assumption.
      assert(TS D B A A').
        repeat split; try assumption.
        exists B.
        split.
          apply col_trivial_3.
        assumption.
      assert(TS D B C A' ).
        eapply l9_8_2.
          apply H18.
        apply one_side_symmetry.
        assumption.
      unfold TS in H19.
      assert (~ Col C D B).
        spliter.
        assumption.
      spliter.
      ex_and H22 Y.
      repeat split; try assumption.
      exists Y.
      split.
        apply between_symmetry.
        assumption.
      right.
      apply col_permutation_1 in H22.
      unfold Col in H22.
      induction H22.
        assert(OS C B A' Y).
          apply out_one_side.
            left.
            intro.
            apply H12.
            apply col_permutation_1.
            eapply (col_transitivity_1 _ A').
              auto.
              apply col_permutation_1.
              apply bet_col.
              assumption.
            apply col_permutation_1.
            assumption.
          apply l6_6.
          apply bet_out.
            intro.
            subst Y.
            apply H13.
            apply col_permutation_5.
            apply bet_col.
            assumption.
          assumption.
        assert(TS C B Y D).
          repeat split.
            intro.
            apply H20.
            apply col_permutation_1.
            eapply (col_transitivity_1 _ Y).
              intro.
              subst Y.
              unfold OS in H24.
              ex_and H24 C0.
              unfold TS in H26.
              spliter.
              apply H26.
              apply col_trivial_3.
              apply col_permutation_2.
              assumption.
            apply col_permutation_1.
            apply bet_col.
            assumption.
            intro.
            apply H20.
            apply col_permutation_4.
            assumption.
          exists B.
          split.
            apply col_trivial_3.
          apply between_symmetry.
          assumption.
        assert(TS C B A A').
          repeat split; try assumption.
            intro.
            apply H12.
            apply col_permutation_1.
            eapply (col_transitivity_1 _ A').
              auto.
              apply col_permutation_1.
              apply bet_col.
              assumption.
            apply col_permutation_2.
            assumption.
          exists B.
          split.
            apply col_trivial_3.
          assumption.
        assert(TS C B Y A).
          eapply l9_8_2.
            apply l9_2.
            apply H26.
          assumption.
        assert(OS C B A D).
          eapply l9_8_1.
            apply l9_2.
            apply H27.
          apply l9_2.
          assumption.
        apply l9_9 in HH0.
        contradiction.
      repeat split.
        intro.
        subst Y.
        apply H12.
        apply col_permutation_1.
        eapply (col_transitivity_1 _ A').
          auto.
          apply col_permutation_1.
          apply bet_col.
          assumption.
        apply col_permutation_1.
        apply bet_col.
        assumption.
        assumption.
      induction H22.
        left.
        assumption.
      right.
      apply between_symmetry.
      assumption.
      intro.
      apply H5.
      assumption.
    assumption.
Qed.
in_angle_trans2
Proof.
  intros A B C D E HC HD.
  destruct (segment_construction E B E B) as [E' [HE1 HE2]].
  assert (Hd := HD).
  apply inangle_distincts in Hd.
  spliter; assert_diffs.
  apply l11_24, in_angle_reverse with E'; Between.
  apply l11_24, in_angle_trans with A; apply l11_24; trivial.
  apply in_angle_reverse with E; auto.
  apply l11_24; trivial.
Qed.
l11_36
Proof.
    intros.
    split.
      intro.
      assert(HH:=H5).
      apply l11_29_a in H5.
      unfold LeA.
      ex_and H5 P.
      exists P.
      split.
        eapply (in_angle_reverse A); try assumption.
      eapply l11_13.
        apply conga_sym.
        apply H6.
        assumption.
        assumption.
        assumption.
      assumption.
    intro.
    assert(HH:=H5).
    unfold LeA in H5.
    apply l11_29_b.
    ex_and H5 P.
    exists P.
    split.
      eapply (in_angle_reverse A'); try assumption.
      apply between_symmetry.
      assumption.
    eapply l11_13.
      apply conga_sym.
      apply H6.
      apply between_symmetry.
      assumption.
      assumption.
      apply between_symmetry.
      assumption.
    assumption.
Qed.
l11_41_aux
Proof.
    intros.
    assert(exists M , Midpoint M A C).
      apply midpoint_existence.
    ex_and H2 M.
    double B M P.
    assert(Cong_3 A C B C A P).
      repeat split.
        apply cong_pseudo_reflexivity.
        eapply l7_13.
          apply l7_2.
          apply H3.
        apply l7_2.
        assumption.
      eapply l7_13.
        apply H3.
      apply l7_2.
      assumption.
    assert(A <> C).
      intro.
      subst C.
      apply H.
      apply col_trivial_3.
    assert(B <> C).
      intro.
      subst C.
      apply H.
      apply col_trivial_2.
    assert(C <> D).
      intro.
      subst C.
      apply H.
      apply col_permutation_4.
      apply bet_col.
      assumption.
    assert(A <> M).
      intro.
      subst M.
      apply is_midpoint_id in H3.
      contradiction.
    assert(CongA A C B C A P).
      apply cong3_conga; assumption.
    assert(exists X, Bet A X P /\ Bet M X D).
      eapply inner_pasch.
        apply between_symmetry.
        apply H0.
      apply midpoint_bet.
      apply l7_2.
      assumption.
    ex_and H10 X.
    split.
      unfold LeA.
      exists P.
      split.
        assert(InAngle P M A D).
          repeat split.
            auto.
            auto.
            intro.
            subst P.
            unfold CongA in H9.
            spliter.
            absurde.
          exists X.
          split.
            assumption.
          right.
          apply bet_out.
            intro.
            subst X.
            apply H.
            eapply (col_transitivity_1 _ M).
              assumption.
              eapply (col_transitivity_1 _ D).
                assumption.
                apply col_permutation_1.
                apply bet_col.
                assumption.
              apply col_permutation_1.
              apply bet_col.
              assumption.
            apply bet_col.
            apply midpoint_bet.
            assumption.
          assumption.
        eapply l11_25.
          apply H12.
          apply l6_6.
          apply bet_out.
            auto.
            auto.
          apply midpoint_bet.
          assumption.
          apply out_trivial.
          auto.
        apply out_trivial.
        unfold CongA in H9.
        spliter.
        auto.
      assumption.
    intro.
    assert(CongA C A D C A P).
      eapply conga_trans.
        apply conga_sym.
        apply H12.
      assumption.
    apply conga__or_out_ts in H13.
    induction H13.
      apply H.
      assert(Col B A P).
        apply col_permutation_2.
        eapply (col_transitivity_1 _ D).
          assumption.
          apply out_col.
          assumption.
        apply col_permutation_1.
        apply bet_col.
        assumption.
      assert(B <> P).
        intro.
        subst P.
        apply l7_3 in H2.
        subst M.
        apply H.
        apply bet_col.
        apply midpoint_bet.
        assumption.
      assert(Col M B A).
        apply col_permutation_2.
        eapply (col_transitivity_1 _ P).
          assumption.
          apply col_permutation_5.
          assumption.
        apply col_permutation_5.
        apply bet_col.
        apply midpoint_bet.
        assumption.
      eapply col_transitivity_1.
        apply H8.
        apply col_permutation_2.
        assumption.
      apply bet_col.
      apply midpoint_bet.
      assumption.
    assert(TS A C B P).
      repeat split.
        intro.
        apply H.
        apply col_permutation_4.
        assumption.
        intro.
        apply H.
        assert(Col M C P).
          apply col_permutation_2.
          eapply (col_transitivity_1 _ A).
            auto.
            apply col_permutation_3.
            assumption.
          apply col_permutation_2.
          apply bet_col.
          apply midpoint_bet.
          assumption.
        assert(Col M B C).
          eapply (col_transitivity_1 _ P).
            intro.
            subst M.
            apply l7_2 in H2.
            apply is_midpoint_id in H2.
            subst P.
            apply H.
            apply col_permutation_4.
            assumption.
            apply col_permutation_1.
            apply bet_col.
            apply midpoint_bet.
            assumption.
          apply col_permutation_5.
          assumption.
        apply col_permutation_1.
        eapply (col_transitivity_1 _ M).
          intro.
          subst M.
          apply l7_2 in H3.
          apply is_midpoint_id in H3.
          subst C.
          absurde.
          apply col_permutation_3.
          apply bet_col.
          apply midpoint_bet.
          assumption.
        apply col_permutation_2.
        assumption.
      exists M.
      split.
        apply col_permutation_4.
        apply bet_col.
        apply midpoint_bet.
        assumption.
      apply midpoint_bet.
      assumption.
    assert(TS A C B D).
      repeat split.
        intro.
        apply H.
        apply col_permutation_4.
        assumption.
        intro.
        apply H.
        eapply (col_transitivity_1 _ D).
          assumption.
          apply col_permutation_1.
          apply bet_col.
          assumption.
        apply col_permutation_4.
        assumption.
      exists A.
      split.
        apply col_trivial_1.
      assumption.
    assert(OS A C D P).
      unfold OS.
      exists B.
      split.
        apply l9_2.
        assumption.
      apply l9_2.
      assumption.
    apply invert_two_sides in H13.
    apply l9_9 in H13.
    contradiction.
Qed.
l11_41
Proof.
    intros.
    split.
      apply l11_41_aux.
        assumption.
        assumption.
      assumption.
    prolong C A E C A.
    assert(LtA A B C B A E).
      eapply l11_41_aux.
        intro.
        apply H.
        apply col_permutation_5.
        assumption.
        assumption.
        assert_diffs;auto.
    assert(CongA B A C C A B).
    {
      apply conga_left_comm.
      apply conga_refl;
      assert_diffs;auto.
    }
    assert(CongA D A C E A B)
      by (eapply l11_13 with B C;assert_diffs;auto).
    unfold LtA in *.
    spliter.
    repeat split.
      eapply l11_30 with A B C B A E;finish.
        apply conga_refl;assert_diffs;auto.
      apply conga_sym.
      apply conga_comm.
      assumption.
    intro.
    apply H7.
    eapply conga_trans.
      apply H8.
    apply conga_comm.
    assumption.
Qed.
not_conga
Proof.
    intros.
    intro.
    apply H0.
    eapply conga_trans.
      apply H.
    assumption.
Qed.
not_conga_sym
Proof.
    intros.
    intro.
    apply H.
    apply conga_sym.
    assumption.
Qed.
not_and_lta
Proof.
    intros.
    intro.
    unfold LtA in *.
    spliter.
    assert(CongA A B C D E F).
      apply lea_asym.
        assumption.
      assumption.
    contradiction.
Qed.
conga_preserves_lta
Proof.
    intros.
    unfold LtA in *.
    spliter.
    split.
      eapply l11_30.
        apply H1.
        assumption.
      assumption.
    intro.
    apply H2.
    eapply conga_trans.
      apply H.
    eapply conga_trans.
      apply H3.
    apply conga_sym.
    assumption.
Qed.
conga_preserves_gta
Proof.
    intros.
    unfold GtA in *.
    eapply conga_preserves_lta.
      apply H0.
      apply H.
    assumption.
Qed.
lta_trans
Proof.
    intros.
    assert(HH1:= H).
    assert(HH2:= H0).
    unfold LtA in H.
    unfold LtA in H0.
    spliter.
    assert(LeA A B C A2 B2 C2).
      eapply lea_trans.
        apply H.
      assumption.
    split.
      assumption.
    intro.
    assert(LtA A2 B2 C2 A1 B1 C1).
      eapply conga_preserves_lta.
        apply H4.
        apply conga_refl.
          unfold LeA in H0.
          ex_and H0 X.
          unfold CongA in H5.
          spliter.
          assumption.
        unfold LeA in H0.
        ex_and H0 X.
        unfold CongA in H5.
        spliter.
        assumption.
      assumption.
    apply (not_and_lta A1 B1 C1 A2 B2 C2).
    split; assumption.
Qed.
gta_trans
Proof.
    intros.
    unfold GtA in *.
    eapply lta_trans.
      apply H0.
    assumption.
Qed.
lea_left_comm
Proof.
    intros.
    unfold LeA in *.
    ex_and H P.
    exists P.
    split.
      assumption.
    apply conga_left_comm.
    assumption.
Qed.
lea_right_comm
Proof.
    intros.
    apply l11_29_b.
    apply l11_29_a in H.
    ex_and H P.
    exists P.
    split.
      assumption.
    apply conga_right_comm.
    assumption.
Qed.
lea_comm
Proof.
    intros.
    apply lea_left_comm.
    apply lea_right_comm.
    assumption.
Qed.
lta_left_comm
Proof.
    unfold LtA.
    intros.
    spliter.
    split.
      apply lea_left_comm.
      assumption.
    intro.
    apply H0.
    apply conga_left_comm.
    assumption.
Qed.
lta_right_comm
Proof.
    unfold LtA.
    intros.
    spliter.
    split.
      apply lea_right_comm.
      assumption.
    intro.
    apply H0.
    apply conga_right_comm.
    assumption.
Qed.
lta_comm
Proof.
    intros.
    apply lta_left_comm.
    apply lta_right_comm.
    assumption.
Qed.
l11_43_aux
Proof.
    intros.
    apply not_col_distincts in H.
    spliter.
    prolong B A B' B A.
    assert(~ Col B' A C).
      intro.
      apply H.
      eapply (col_transitivity_1 _ B').
        intro.
        subst B'.
        apply cong_symmetry in H5.
        apply cong_identity in H5.
        subst A.
        apply H.
        apply col_trivial_1.
        apply col_permutation_1.
        apply bet_col.
        assumption.
      apply col_permutation_4.
      assumption.
    apply not_col_distincts in H6.
    spliter.
    assert(LtA A C B C A B'/\ LtA A B C C A B').
      apply l11_41.
        assumption.
        assumption.
      auto.
    spliter.
    induction H0.
      unfold Acute.
      exists C.
      exists A.
      exists B.
      split.
        apply l8_2.
        assumption.
      spliter.
      unfold LtA.
      unfold LtA in H11.
      spliter.
      assert(Per B' A C).
        apply l8_2.
        eapply (per_col _ _ B).
          assumption.
          apply l8_2.
          assumption.
        apply col_permutation_4.
        apply bet_col.
        assumption.
      assert(CongA B A C B' A C).
        apply l11_16.
          assumption.
          auto.
          auto.
          assumption.
          assumption.
        auto.
      split.
        eapply l11_30.
          apply H11.
          apply conga_refl.
            assumption.
          auto.
        apply conga_comm.
        apply conga_sym.
        assumption.
      intro.
      apply H12.
      eapply conga_trans.
        apply H15.
      apply conga_comm.
      assumption.
    unfold Acute.
    unfold Obtuse in H0.
    ex_and H0 a.
    ex_and H12 b.
    ex_and H0 c.
    unfold GtA in H12.
    assert(HH1:= H12).
    unfold LtA in H12.
    spliter.
    unfold LeA in H12.
    ex_and H12 P.
    exists B.
    exists A.
    exists P.
    assert(Per B A P).
      eapply l11_17.
        apply H0.
      assumption.
    split.
      assumption.
    assert(Per P A B').
      eapply per_col.
        apply H1.
        eapply l11_17.
          apply H0.
        apply conga_right_comm.
        assumption.
      apply col_permutation_4.
      apply bet_col.
      assumption.
    assert(CongA B A P B' A P).
      eapply l11_16.
        assumption.
        auto.
        intro.
        subst P.
        unfold CongA in H14.
        spliter.
        absurde.
        apply l8_2.
        assumption.
        assumption.
      intro.
      subst P.
      unfold CongA in H14.
      spliter.
      absurde.
    assert(LtA C A B' P A B).
      assert(B <> A).
        auto.
      assert(HH := l11_36 B A P B A C B' B' H18 H7 H18 H7 H4 H4).
      destruct HH.
      unfold LtA.
      split.
        eapply l11_30.
          apply H19.
          unfold LtA in HH1.
          spliter.
          eapply l11_30.
            apply H21.
            assumption.
          apply conga_refl.
            auto.
          auto.
          apply conga_left_comm.
          apply conga_refl.
            auto.
          assumption.
        apply conga_right_comm.
        apply conga_sym.
        assumption.
      intro.
      apply H13.
      assert(Per B' A C).
        eapply l11_17.
          apply H15.
        apply conga_comm.
        apply conga_sym.
        assumption.
      assert(Per C A B).
        eapply (per_col _ _ B').
          auto.
          apply l8_2.
          assumption.
        apply col_permutation_1.
        apply bet_col.
        assumption.
      apply l11_16.
        assumption.
        unfold CongA in H14.
        spliter.
        assumption.
        unfold CongA in H14.
        spliter.
        assumption.
        apply l8_2.
        assumption.
        auto.
      auto.
    eapply lta_trans.
      apply H11.
    apply lta_right_comm.
    assumption.
Qed.
obtuse_sym
Proof.
    unfold Obtuse.
    intros.
    ex_and H A'.
    ex_and H0 B'.
    ex_and H C'.
    exists A'.
    exists B'.
    exists C'.
    split.
      assumption.
    unfold GtA in *.
    apply lta_right_comm.
    assumption.
Qed.
acute_sym
Proof.
    unfold Acute.
    intros.
    ex_and H A'.
    ex_and H0 B'.
    ex_and H C'.
    exists A'.
    exists B'.
    exists C'.
    split;auto using lta_left_comm.
Qed.
l11_43
Proof.
    intros.
    split.
      apply l11_43_aux;finish.
    apply l11_43_aux;finish.
    induction H0.
      left;finish.
    right;apply obtuse_sym;assumption.
Qed.
acute_lea_acute
Proof.
    intros.
    unfold Acute in *.
    ex_and H A'.
    ex_and H1 B'.
    ex_and H C'.
    exists A'.
    exists B'.
    exists C'.
    split.
      assumption.
    assert(HH1:=H1).
    unfold LtA in H1.
    spliter.
    unfold LtA.
    split.
      eapply lea_trans.
        apply H0.
      assumption.
    intro.
    assert(LtA A' B' C' D E F).
      eapply conga_preserves_lta.
        apply H3.
        apply conga_refl.
          unfold LeA in H0.
          ex_and H0 X.
          unfold CongA in H4.
          spliter.
          assumption.
        apply lea_comm in H0.
        unfold LeA in H0.
        ex_and H0 X.
        unfold CongA in H4.
        spliter.
        assumption.
      split.
        assumption.
      intro.
      apply H2.
      eapply conga_trans.
        apply conga_sym.
        apply H4.
      assumption.
    apply (not_and_lta A' B' C' D E F).
    split; assumption.
Qed.
obtuse_gea_obtuse
Proof.
    intros.
    ex_and H A'.
    ex_and H1 B'.
    ex_and H C'.
    exists A'.
    exists B'.
    exists C'.
    split.
      assumption.
    assert(HH1:=H1).
    unfold GtA in H1.
    unfold LtA in H1.
    spliter.
    unfold GtA.
    unfold LtA.
    split.
      eapply lea_trans.
        apply H1.
      assumption.
    intro.
    assert(GtA A' B' C' D E F).
      eapply conga_preserves_gta.
        apply conga_sym.
        apply H3; apply H3.
        apply conga_refl.
          unfold LeA in H0.
          ex_and H0 X.
          unfold CongA in H4.
          spliter.
          assumption.
        apply lea_comm in H0.
        unfold LeA in H0.
        ex_and H0 X.
        unfold CongA in H4.
        spliter.
        assumption.
      unfold GtA.
      split.
        assumption.
      intro.
      apply H2.
      eapply conga_trans.
        apply H3.
      apply conga_sym.
      assumption.
    unfold GtA in *.
    apply (not_and_lta A' B' C' D E F).
    split; assumption.
Qed.
lea_acute_obtuse
Proof.
    intros.
    unfold Acute in H.
    unfold Obtuse in H0.
    ex_and H A1.
    ex_and H1 B1.
    ex_and H C1.
    ex_and H0 A2.
    ex_and H2 B2.
    ex_and H0 C2.
    assert(A1 <> B1 /\ C1 <> B1 /\ A2 <> B2 /\ C2 <> B2 /\ A <> B /\ C <> B).
      unfold LtA in H1.
      unfold GtA in H2.
      unfold LtA in H2.
      spliter.
      unfold LeA in *.
      ex_and H1 X.
      ex_and H2 Y.
      unfold CongA in H6.
      unfold CongA in H5.
      unfold InAngle in H1.
      spliter.
      repeat split; assumption.
    spliter.
    assert(CongA A1 B1 C1 A2 B2 C2).
      apply l11_16; assumption.
    unfold GtA in H2.
    assert(LtA A B C A2 B2 C2).
      eapply conga_preserves_lta.
        apply conga_refl.
          assumption.
        assumption.
        apply H9.
      assumption.
    assert(LtA A B C D E F).
      eapply lta_trans.
        apply H10.
      apply H2.
    unfold LtA in H11.
    spliter.
    assumption.
Qed.
l11_44_1_a
Proof.
    intros.
    destruct (midpoint_existence A C) as [P HP].
    assert_diffs.
    assert(Cong_3 B C P B A P) by (repeat split;finish).
    assert(CongA B C P B A P) by (auto using cong3_conga).
    apply conga_sym.
    eapply l11_10 with B P B P;finish.
Qed.	
l11_44_2_a
Proof.
    intros.
    apply not_col_distincts in H.
    spliter.
    unfold Lt in H0.
    spliter.
    unfold Le in H0.
    ex_and H0 C'.
    assert(C <> C').
      intro.
      subst C'.
      contradiction.
    assert(C' <> A).
      intro.
      subst C'.
      apply H.
      apply col_permutation_4.
      apply bet_col.
      assumption.
    assert(C' <> B).
      intro.
      subst C'.
      apply cong_identity in H5.
      subst A.
      absurde.
    assert(InAngle C' B A C).
      repeat split.
        auto.
        auto.
        assumption.
      exists C'.
      split.
        assumption.
      right.
      apply out_trivial.
      auto.
    assert(HH:=l11_41 C' C A B).
    assert(LtA C' A C A C' B /\ LtA C' C A A C' B).
      apply HH.
        intro.
        apply H.
        apply col_permutation_1.
        eapply col_transitivity_1.
          apply H6.
          apply col_permutation_4.
          assumption.
        apply col_permutation_3.
        apply bet_col.
        assumption.
        apply between_symmetry.
        assumption.
      assumption.
    clear HH.
    spliter.
    assert(LtA B A C' B A C).
      split.
        unfold LeA.
        exists C'.
        split.
          assumption.
        apply conga_refl.
          auto.
        assumption.
      intro.
      apply conga__or_out_ts in H12.
      induction H12.
        apply H.
        apply out_col in H12.
        apply bet_col in H0.
        apply col_permutation_1.
        eapply col_transitivity_1.
          apply H6.
          Col.
        Col.
      assert(OS B A C' C).
        apply out_one_side.
          right.
          intro.
          apply H.
          Col.
        apply bet_out;auto.
      apply l9_9 in H12.
      contradiction.
    assert(LtA B C A A C' B).
      eapply conga_preserves_lta.
        3: apply H11.
        eapply out_conga.
          apply conga_refl.
            apply H2. (* *)
          apply H3.
          apply l6_6.
          apply bet_out.
            auto.
          apply between_symmetry.
          assumption.
          apply out_trivial.
          auto.
          apply out_trivial.
          auto.
        apply out_trivial.
        auto.
      apply conga_refl.
        auto.
      auto.
    assert(CongA B A C' B C' A).
      assert(HH := l11_44_1_a A B C').
      apply HH.
        intro.
        apply H.
        apply col_permutation_2.
        eapply (col_transitivity_1 _ C').
          auto.
          apply bet_col.
          assumption.
        Col.
      assumption.
    apply conga_right_comm in H14.
    assert(LtA B C A B A C').
      eapply conga_preserves_lta.
        2: apply conga_sym.
        2: apply H14.
        apply conga_refl.
          assumption.
        assumption.
      assumption.
    eapply lta_trans.
      apply H15.
    assumption.
Qed.
not_lta_and_conga
Proof.
    intros.
    intro.
    spliter.
    unfold LtA in H.
    spliter.
    contradiction.
Qed.
not_gta_and_conga
Proof.
    intros.
    intro.
    spliter.
    unfold GtA in H.
    unfold LtA in H.
    spliter.
    apply conga_sym in H0.
    contradiction.
Qed.
not_lta_and_gta
Proof.
    intros.
    intro.
    spliter.
    unfold GtA in H0.
    unfold LtA in *.
    spliter.
    apply H2.
    apply lea_asym.
      assumption.
    assumption.
Qed.
conga_sym_equiv
Proof.
    intros.
    split; apply conga_sym.
Qed.
conga_dec
Proof.
    intros.
    induction (eq_dec_points A B).
      subst;right;intro;unfold CongA in *;intuition.
    induction (eq_dec_points C B).
      subst;right;intro;unfold CongA in *;intuition.
    induction (eq_dec_points D E).
      subst;right;intro;unfold CongA in *;intuition.
    induction (eq_dec_points F E).
      subst;right;intro;unfold CongA in *;intuition.
    assert (exists A' : Tpoint, Bet B A A' /\ Cong A A' E D) by (apply segment_construction).
    decompose [ex and] H3; clear H3.
    assert (exists C' : Tpoint, Bet B C C' /\ Cong C C' E F) by (apply segment_construction).
    decompose [ex and] H3; clear H3.
    assert (exists D' : Tpoint, Bet E D D' /\ Cong D D' B A) by (apply segment_construction).
    decompose [ex and] H3; clear H3.
    assert (exists F' : Tpoint, Bet E F F' /\ Cong F F' B C) by (apply segment_construction).
    decompose [ex and] H3; clear H3.
    induction (Cong_dec x x0 x1 x2).
      left.
      unfold CongA.
      repeat split; try assumption.
      exists x; exists x0; exists x1; exists x2.
      repeat split; assumption.
    right.
    unfold CongA.
    intro.
    decompose [and ex] H4; clear H4.
    assert (x3 = x) by (apply construction_uniqueness with B A E D; intuition).
    assert (x4 = x0) by (apply construction_uniqueness with B C E F; intuition).
    assert (x5 = x1) by (apply construction_uniqueness with E D B A; intuition).
    assert (x6 = x2) by (apply construction_uniqueness with E F B C; intuition).
    subst.
    contradiction.
Qed.
lta_not_conga
Proof.
    intros.
    intro.
    unfold LtA in H3.
    spliter.
    contradiction.
Qed.
l11_44_1_b
Proof.
    intros.
    apply not_col_distincts in H.
    spliter.
    assert(HH:= or_lt_cong_gt B A B C).
    induction HH.
      apply l11_44_2_a in H4.
        apply lta_not_conga in H4.
          apply conga_sym in H0.
          contradiction.
          assumption.
          assumption.
          auto.
        auto.
      assumption.
    induction H4.
      unfold Gt in H4.
      apply l11_44_2_a in H4.
        apply lta_not_conga in H4.
          contradiction.
          auto.
          auto.
          assumption.
        assumption.
      intro.
      apply H.
      apply col_permutation_3.
      assumption.
    assumption.
Qed.
l11_44_2_b
Proof.
    intros.
    apply not_col_distincts in H.
    spliter.
    assert(HH:= or_lt_cong_gt B A B C).
    induction HH.
      apply l11_44_2_a in H4.
        assert(HH:= not_lta_and_gta B A C B C A).
        exfalso.
        apply HH.
        split; assumption.
      assumption.
    induction H4.
      unfold Gt in H4.
      assumption.
    apply l11_44_1_a in H4.
      apply lta_not_conga in H0.
        contradiction.
        auto.
        auto.
        assumption.
      assumption.
    assumption.
Qed.
l11_44_1
Proof.
    intros;split;intro; auto using l11_44_1_b, l11_44_1_a.
Qed.
l11_44_2
Proof.
    intros;split;intro;
    auto using l11_44_2_b, l11_44_2_a with col. 
Qed.
lta_diff
Proof.
    intros.
    split.
      assumption.
    unfold LtA in H.
    spliter.
    unfold LeA in H.
    ex_and H P.
    unfold CongA in H1.
    unfold InAngle in H.
    spliter.
    repeat split; assumption.
Qed.
l11_46
Proof.
    intros.
    apply not_col_distincts in H.
    spliter.
    assert(HH:= H0).
    apply l11_43 in H0.
      spliter.
      split.
        apply lt_left_comm.
        eapply l11_44_2_b.
          intro.
          apply H.
          apply col_permutation_1.
          assumption.
        unfold Acute in H4.
        ex_and H4 A'.
        ex_and H5 B'.
        ex_and H4 C'.
        apply lta_diff in H5.
        spliter.
        induction HH.
         {
            eapply conga_preserves_lta with A C B A' B' C'.
              apply conga_refl;auto.
              apply l11_16;auto.
          apply lta_left_comm.
          assumption.
         }
        unfold Obtuse in H10.
        ex_and H10 A''.
        ex_and H11 B''.
        ex_and H10 C''.
        unfold GtA in H11.
        eapply lta_trans.
          apply lta_left_comm.
          apply H5.
        eapply conga_preserves_lta with A'' B'' C'' A B C.
          apply lta_diff in H11.
          spliter.
          apply l11_16.
            apply H10.
            assumption.
            assumption.
            assumption.
            assumption.
          assumption.
          apply conga_refl.
            assumption.
          auto.
        assumption.
      apply lt_left_comm.
      apply lt_right_comm.
      eapply l11_44_2_b.
        finish.
      unfold Acute in H0.
      ex_and H0 A'.
      ex_and H5 B'.
      ex_and H0 C'.
      apply lta_diff in H5.
      spliter.
      induction HH.
        eapply conga_preserves_lta.
          apply conga_refl.
            auto.
          auto.
          apply l11_16.
            apply H0.
            assumption.
            assumption.
            apply l8_2.
            assumption.
            auto.
          assumption.
        apply lta_left_comm.
        assumption.
      unfold Obtuse in H10.
      ex_and H10 A''.
      ex_and H11 B''.
      ex_and H10 C''.
      unfold GtA in H11.
      eapply lta_trans.
        apply lta_left_comm.
        apply H5.
      eapply conga_preserves_lta.
        apply lta_diff in H11.
        spliter.
        apply l11_16.
          apply H10.
          assumption.
          assumption.
          assumption.
          assumption.
        assumption.
        apply conga_refl.
          auto.
        assumption.
      apply lta_right_comm.
      assumption.
    finish.
Qed.
l11_47
Proof.
    intros.
    assert(HH1:= H1).
    unfold Perp_at in H1.
    spliter.
    assert(Per C H A).
      apply H5.
        apply col_trivial_1.
      apply col_trivial_1.
    assert(Perp C H A B).
      eapply l8_14_2_1a.
      apply HH1.
    induction (Col_dec A C B).
      assert(A <> H).
        intro.
        subst H.
        apply H1.
        apply sym_equal.
        eapply per_col_eq.
          apply H0.
          assumption.
        intro.
        subst B.
        assert(Perp_at C C A A C).
          apply perp_perp_in.
          assumption.
        apply H2.
        eapply l8_14_3.
          apply HH1.
        assumption.
      apply False_ind.
      apply H9.
      eapply per_col_eq.
        apply l8_2.
        apply H6.
        ColR.
       (* eapply (col_transitivity_1 _ B).
          assumption.
          apply col_permutation_1.
          assumption.
        apply col_permutation_5.
        assumption. *)
      auto.
    apply not_col_distincts in H8.
    spliter.
    assert(A <> H).
      intro.
      subst A.
      assert(Per C H B).
        apply perp_in_per.
        assumption.
      apply H1.
      eapply l8_7.
        apply l8_2.
        apply H0.
      apply l8_2.
      assumption.
    assert(Per C H B).
      eapply per_col.
        2: apply H6.
        auto.
      assumption.
    assert(H <> B).
      intro.
      subst B.
      apply H10.
      eapply l8_7.
        apply H0.
      apply l8_2.
      assumption.
    assert(Lt H A A C /\ Lt H C A C).
      apply l11_46.
        intro.
        apply H8;ColR.
      left.
      apply l8_2.
      assumption.
    assert(Lt C A A B /\ Lt C B A B).
      apply l11_46.
        assumption.
      left.
      assumption.
    assert(Lt H B B C /\ Lt H C B C).
      eapply l11_46.
        intro.
        apply H8.
        ColR.
      left.
      finish.
    split.
      unfold Lt in *.
      spliter.
      apply l5_12_b.
        finish.
        eapply le_transitivity.
          apply le_left_comm.
          apply H15.
        apply le_left_comm.
        assumption.
      eapply le_transitivity.
        apply H17.
      apply le_left_comm.
      assumption.
    split;auto.
Qed.
l11_49
Proof.
    intros.
    assert(Cong A C A' C').
      eapply cong2_conga_cong.
        apply H.
        apply cong_commutativity.
        assumption.
      assumption.
    split.
      assumption.
    intro.
    assert(A <> B /\ C <> B /\ A' <> B'  /\ C' <> B').
      unfold CongA in H.
      spliter.
      repeat split; assumption.
    spliter.
    split.
      apply l11_3_bis.
      exists B.
      exists C.
      exists B'.
      exists C'.
      split.
        apply out_trivial.
        auto.
      split.
        apply out_trivial.
        auto.
      split.
        apply out_trivial.
        auto.
      split.
        apply out_trivial.
        intro.
        subst C'.
        apply cong_identity in H2.
        contradiction.
      repeat split; assumption.
    apply l11_3_bis.
    exists B.
    exists A.
    exists B'.
    exists A'.
    split.
      apply out_trivial.
      auto.
    split.
      apply out_trivial.
      auto.
    split.
      apply out_trivial.
      auto.
    split.
      apply out_trivial.
      intro.
      subst C'.
      apply cong_identity in H2.
      contradiction.
    repeat split.
      assumption.
      assumption.
    apply cong_commutativity.
    assumption.
Qed.
l11_50_1
Proof.
    intros.
    assert(A <> B /\ C <> B /\ A' <> B'  /\ C' <> B') by (unfold CongA in *;intuition).
    spliter.
    assert(exists C'', Out B' C'' C' /\ Cong B' C'' B C).
      apply l6_11_existence;auto.
    ex_and H7 C''.
    assert(B' <> C'') by (unfold Out in *;intuition).
    assert(~ Col A' B' C') by (eapply ncol_conga_ncol;eauto).
    assert(~ Col A' B' C'').
      intro.
      apply H10.
      apply out_col in H7.
      eapply col_permutation_2.
      eapply (col_transitivity_1 _ C'').
        assumption.
        assumption.
      apply col_permutation_1.
      assumption.
    assert(HH:=l11_4_1 A B C A' B' C' H1).
    spliter.
    assert(Cong A C A' C'').
      apply H16.
      assert (C''<> B') by auto.
      repeat split;try assumption.
        left.
        apply between_trivial.
        left.
        apply between_trivial.
        left.
        apply between_trivial.
        auto.
        unfold Out in  H7.
        spliter.
        assumption.
        apply cong_commutativity.
        assumption.
      apply cong_symmetry.
      assumption.
    assert(Cong_3 B A C B' A' C'').
      repeat split.
        apply cong_commutativity.
        assumption.
        apply cong_symmetry.
        assumption.
      assumption.
    assert(CongA B A C B' A' C'').
      apply cong3_conga.
        auto.
        apply not_col_distincts in H.
        spliter.
        auto.
      assumption.
    assert(CongA B' A' C' B' A' C'').
      eapply conga_trans.
        apply conga_sym.
        apply H0.
      assumption.
    assert(C' = C'').
      assert(HH:= conga__or_out_ts B' A' C' C'' H20).
      induction HH.
        eapply l6_21.
          apply not_col_permutation_5.
          apply H10.
          apply H9.
          apply col_trivial_2.
          apply out_col.
          assumption.
          apply out_col in H7.
          assumption.
          apply col_trivial_2.
      assert(OS B' A' C' C'').
        apply out_one_side.
          left.
          intro.
          apply H10.
          apply col_permutation_4.
          assumption.
        apply l6_6.
        assumption.
      apply l9_9 in H21.
      contradiction.
    subst C''.
    clear H20.
    split.
      assumption.
    split.
      eapply cong2_conga_cong.
        apply H19.
        apply cong_commutativity.
        assumption.
      assumption.
    apply cong3_conga.
      apply not_col_distincts in H.
      spliter.
      assumption.
      auto.
    unfold Cong_3.
    repeat split.
      assumption.
      assumption.
    apply cong_symmetry.
    apply cong_commutativity.
    assumption.
Qed.
l11_50_2
Proof.
    intros.
    assert(A <> B /\ C <> B /\ A' <> B'  /\ C' <> B').
      unfold CongA in H1.
      spliter.
      repeat split; assumption.
    spliter.
    assert(exists C'',  Out B' C'' C' /\ Cong B' C'' B C).
      apply l6_11_existence.
        assumption.
      auto.
    ex_and H7 C''.
    assert(B' <> C'').
      unfold Out in H7.
      spliter.
      auto.
    assert(~Col A' B' C').
      eapply ncol_conga_ncol.
        apply H.
      assumption.
    assert(~Col A' B' C'').
      intro.
      apply H10.
      apply out_col in H7.
      eapply col_permutation_2.
      eapply (col_transitivity_1 _ C'').
        assumption.
        assumption.
      apply col_permutation_1.
      assumption.
    assert(HH:=l11_4_1 A B C A' B' C' H1).
    spliter.
    assert(Cong A C A' C'').
      apply H16.
      repeat split; try assumption.
        left.
        apply between_trivial.
        left.
        apply between_trivial.
        left.
        apply between_trivial.
        auto.
        unfold Out in  H7.
        spliter.
        assumption.
        apply cong_commutativity.
        assumption.
      apply cong_symmetry.
      assumption.
    assert(Cong_3 B C A B' C'' A').
      repeat split.
        apply cong_symmetry.
        assumption.
        apply cong_commutativity.
        assumption.
      apply cong_commutativity.
      assumption.
    assert(CongA B C A B' C'' A').
      apply cong3_conga.
        auto.
        apply not_col_distincts in H.
        spliter.
        assumption.
      assumption.
    assert(CongA B' C' A' B' C'' A').
      eapply conga_trans.
        apply conga_sym.
        apply H0.
      assumption.
    apply not_col_distincts in H.
    apply not_col_distincts in H10.
    spliter.
    clear H16.
    induction(eq_dec_points C' C'').
      induction (eq_dec_points C' C'').
        subst C''.
        split.
          assumption.
        split.
          apply cong_symmetry.
          assumption.
        assert(Cong_3 C A B C' A' B').
          repeat split.
            apply cong_commutativity.
            assumption.
            apply cong_commutativity.
            apply cong_symmetry.
            assumption.
          assumption.
        apply cong3_conga.
          auto.
          auto.
        assumption.
      apply False_ind.
      apply H27.
      assumption.
    assert(~Col C'' C' A').
      intro.
      apply H10.
      apply col_permutation_1.
      eapply col_transitivity_1.
        apply H16.
        apply col_permutation_4.
        assumption.
      apply col_permutation_3.
      apply out_col.
      assumption.
    apply not_col_distincts in H27.
    spliter.
    unfold Out in H7.
    spliter.
    induction H32.
      assert(HH:=l11_41 ).
      assert(HH1:=l11_41 C'' C' A' B' H27 (between_symmetry _ _ _ H32) H7).
      spliter.
      assert(CongA B' C' A' C'' C' A').
        eapply (l11_10 B' C' A' B' C' A').
          apply conga_refl.
            auto.
          assumption.
          apply out_trivial.
          assumption.
          apply out_trivial.
          auto.
          apply bet_out.
            auto.
          apply  between_symmetry.
          assumption.
        apply out_trivial.
        auto.
      assert(LtA B' C' A' A' C'' B').
        eapply conga_preserves_lta.
          apply conga_sym.
          apply H35.
          apply conga_refl.
            auto.
          auto.
        assumption.
      unfold LtA in H36.
      spliter.
      apply conga_right_comm in H20.
      contradiction.
    assert(~Col C' C'' A').
      intro.
      apply H27.
      apply col_permutation_4.
      assumption.
    assert(HH1:=l11_41 C' C'' A' B' H33 (between_symmetry _ _ _ H32) H15).
    spliter.
    assert(CongA B' C'' A' C' C'' A').
      eapply (l11_10 B' C'' A' B' C'' A').
        apply conga_refl.
          auto.
        auto.
        apply out_trivial.
        assumption.
        apply out_trivial.
        auto.
        apply bet_out.
          auto.
        apply  between_symmetry.
        assumption.
      apply out_trivial.
      auto.
    assert(LtA B' C'' A' A' C' B').
      eapply conga_preserves_lta.
        apply conga_sym.
        apply H36.
        apply conga_refl.
          auto.
        auto.
      assumption.
    unfold LtA in H37.
    spliter.
    apply conga_sym in H20.
    apply conga_right_comm in H20.
    contradiction.
Qed.
l11_51
Proof.
    intros.
    assert(Cong_3 B A C B' A' C' /\ Cong_3 A B C A' B' C' /\ Cong_3 B C A B' C' A').
      repeat split; cong.
    spliter.
    split.
      apply cong3_conga.
        auto.
        auto.
      assumption.
    split.
      apply cong3_conga.
        assumption.
        auto.
      assumption.
    apply cong3_conga.
      assumption.
      assumption.
    assumption.
Qed.
conga_distinct
Proof.
    intros.
    split.
      assumption.
    unfold CongA in H.
    spliter.
    repeat split; assumption.
Qed.
l11_52
Proof.
    intros.
    apply conga_distinct in H.
    spliter.
    assert(Cong B A B' A').
      induction(Col_dec A B C).
        unfold Col in H7.
        induction H7.
          assert(Bet A' B' C').
            eapply bet_conga_bet.
              apply H7.
            assumption.
          apply cong_commutativity.
          eapply l4_3.
            apply H7.
            apply H8.
            assumption.
          assumption.
        induction H7.
          assert(Out B' A' C').
            eapply out_conga_out.
              apply bet_out.
                apply H4.
              apply H7.
            apply conga_left_comm.
            assumption.
          unfold Out in H8.
          spliter.
          induction H10.
            assert(Le B' C' A' C').
              eapply l5_6.
              repeat split.
                apply H2.
                assumption.
              assumption.
            assert(B'=A').
              eapply bet_le_eq.
                apply H10.
              assumption.
            subst B'.
            absurde.
          eapply l2_11.
            apply H7.
            apply H10.
            assumption.
          cong.
        assert(B = A).
          eapply bet_le_eq.
            apply between_symmetry.
            apply H7.
          assumption.
        subst B.
        absurde.
      assert(exists A'', Out B' A'' A' /\ Cong B' A'' B A).
        apply l6_11_existence.
          assumption.
        auto.
      ex_and H8 A''.
      assert(CongA A' B' C' A'' B' C').
        eapply (l11_10  A'' _ C' A'' _ C' ).
          apply conga_refl.
            unfold Out in H8.
            spliter.
            assumption.
          assumption.
          apply l6_6.
          assumption.
          apply out_trivial.
          auto.
          apply out_trivial.
          unfold Out in H8.
          spliter.
          auto.
        apply out_trivial.
        auto.
      assert(CongA A B C A'' B' C').
        eapply l11_10.
          apply H.
          apply out_trivial.
          auto.
          apply out_trivial.
          auto.
          assumption.
        apply out_trivial.
        auto.
      assert(Cong A'' C' A C).
        eapply cong2_conga_cong.
          apply conga_sym.
          apply H11.
          cong.
        cong.
      assert(Cong_3 A'' B' C' A B C).
        repeat split; cong.
      assert(Cong A'' C' A' C').
        eapply cong_transitivity.
          apply H12.
        assumption.
      assert(~Col A' B' C').
        eapply ncol_conga_ncol.
          apply H7.
        assumption.
      assert(~Col A'' B' C').
        intro.
        apply H15.
        apply col_permutation_2.
        eapply (col_transitivity_1 _ A'').
          intro.
          subst A''.
          unfold Out in H8.
          spliter.
          absurde.
          permut.
        apply out_col in H8.
        permut.
      induction(eq_dec_points A'' A').
        subst A''.
        unfold Cong_3 in H13.
        spliter.
        cong.
      unfold Out in H8.
      spliter.
      induction H19.
        assert(HH:= l11_41 A'' B' C' A' H16 H19 H17).
        spliter.
        assert(Cong A' C' A'' C').
          eapply (cong_transitivity _ _ A C).
            cong.
          unfold Cong_3 in H13.
          spliter.
          cong.
        assert(~Col A'' C' A').
          intro.
          apply H15.
          eapply (col_transitivity_1 _ A'' ).
            auto.
            apply bet_col in H19.
            permut.
          permut.
        assert (HH:= l11_44_1 A'' C' A' H23 ).
        destruct HH.
        apply cong_commutativity in H22.
        apply cong_symmetry in H22.
        apply H25 in H22.
        assert(~Col B' C' A'').
          intro.
          apply H16.
          permut.
        assert(CongA B' A' C' A'' A' C').
          eapply l11_10.
            apply conga_refl.
              3:apply out_trivial.
              auto.
            3:apply out_trivial.
            intro.
            subst C'.
            apply H15.
            apply col_trivial_3.
            auto.
            intro.
            subst C'.
            apply H15.
            apply col_trivial_3.
            apply between_symmetry in H19.
            apply bet_out in H19.
              assumption.
              assumption.
            auto.
          apply out_trivial.
          intro.
          subst C'.
          apply H15.
          apply col_trivial_3.
        assert(~Col B' C' A').
          intro.
          apply H15.
          permut.
        assert(HH:=l11_44_2 B' C' A' H28).
        destruct HH.
        assert(Lt C' A'  C' B').
          apply H29.
          eapply conga_preserves_lta.
            apply conga_right_comm.
            apply conga_sym.
            apply H10.
            2:apply H21.
          eapply conga_trans.
            apply H22.
          apply conga_comm.
          apply conga_sym.
          assumption.
        assert(Lt C' A'' C' B').
          unfold Lt in H31.
          spliter.
          unfold Lt.
          split.
            eapply l5_6.
              apply H31.
              apply cong_commutativity.
              cong.
            cong.
          intro.
          apply H32.
          eapply cong_transitivity.
            apply cong_commutativity.
            apply cong_symmetry.
            apply H14.
          assumption.
        unfold Lt in H32.
        spliter.
        assert(Le C A C B).
          eapply l5_6.
          repeat split.
            apply H32.
            apply cong_commutativity.
            assumption.
          apply cong_commutativity.
          cong.
        assert(Cong C A C B).
          apply le_anti_symmetry.
            assumption.
          apply le_comm.
          assumption.
        apply False_ind.
        apply H33.
        apply cong_symmetry.
        eapply cong_transitivity.
          apply cong_commutativity.
          apply cong_symmetry.
          apply H1.
        eapply cong_transitivity.
          apply cong_symmetry.
          apply H35.
        apply cong_commutativity.
        cong.
      assert(A' <> A'').
        auto.
      assert(HH:= l11_41 A' B' C' A'' H15 H19 H20).
      spliter.
      assert(Cong A' C' A'' C').
        eapply (cong_transitivity _ _ A C).
          cong.
        unfold Cong_3 in H13.
        spliter.
        cong.
      assert(~Col A'' C' A').
        intro.
        apply H15.
        eapply (col_transitivity_1 _ A'' ).
          auto.
          apply bet_col in H19.
          permut.
        permut.
      assert (HH:= l11_44_1 A'' C' A' H24 ).
      destruct HH.
      apply cong_commutativity in H23.
      apply cong_symmetry in H23.
      apply H26 in H23.
      assert(~Col B' C' A'').
        intro.
        apply H16.
        permut.
      assert(CongA B' A'' C' A' A'' C').
        eapply l11_10.
          apply conga_refl.
            3:apply out_trivial.
            auto.
          3:apply out_trivial.
          intro.
          subst C'.
          apply H16.
          apply col_trivial_3.
          auto.
          intro.
          subst C'.
          apply H16.
          apply col_trivial_3.
          apply between_symmetry in H19.
          apply bet_out in H19.
            assumption.
            assumption.
          auto.
        apply out_trivial.
        intro.
        subst C'.
        apply H16.
        apply col_trivial_3.
      assert(~Col B' C' A'').
        intro.
        apply H16.
        permut.
      assert(HH:=l11_44_2 B' C' A'' H29).
      destruct HH.
      assert(Lt C' A''  C' B').
        apply H30.
        eapply conga_preserves_lta.
          apply conga_right_comm.
          apply conga_sym.
          apply conga_sym.
          apply H10.
          2:apply H22.
        eapply conga_trans.
          apply conga_sym.
          apply H23.
        apply conga_comm.
        apply conga_sym.
        assumption.
      assert(Lt C' A' C' B').
        unfold Lt in H32.
        spliter.
        unfold Lt.
        split.
          eapply l5_6.
            apply H32.
            apply cong_commutativity.
            cong.
          cong.
        intro.
        apply H33.
        eapply cong_transitivity.
          apply cong_commutativity.
          apply H14.
        assumption.
      unfold Lt in H33.
      spliter.
      assert(Le C A C B).
        eapply l5_6.
        repeat split.
          apply H32.
          apply cong_commutativity.
          assumption.
        apply cong_commutativity.
        cong.
      assert(Cong C A C B).
        apply le_anti_symmetry.
          assumption.
        apply le_comm.
        assumption.
      apply False_ind.
      apply H34.
      apply cong_symmetry.
      eapply cong_transitivity.
        apply cong_commutativity.
        apply cong_symmetry.
        apply H1.
      eapply cong_transitivity.
        apply cong_symmetry.
        apply H36.
      apply cong_commutativity.
      cong.
    assert(Cong_3 A B C A' B' C').
      repeat split; cong.
    split.
      assumption.
    split.
      apply cong3_conga.
        auto.
        intro.
        subst C.
        apply le_zero in H2.
        subst B.
        absurde.
      auto with cong3.
    apply cong3_conga.
      auto.
      intro.
      subst C.
      apply le_zero in H2.
      subst B.
      absurde.
    auto with cong3.
Qed.
l11_53
Proof.
    intros.
    assert(A<>C) by (intro; Between).
    spliter.
    assert(~Col B A D).
      intro.
      assert(Col B C D).
        eapply (col_transitivity_1 _ A).
          auto.
          apply bet_col in H3.
          permut.
        permut.
      assert(~Col  B C D).
        apply per_not_col.
          assumption.
          assumption.
        apply l8_2.
        assumption.
      contradiction.
    assert(A <> D).
      intro.
      subst D.
      apply H5.
      apply col_trivial_2.
    assert( LtA C A D C B D).
      assert(HH:=l11_41 B A D C H5 H3 H2).
      spliter.
      assert(CongA C A D B A D).
        eapply (l11_10  C A D C _ D).
          apply conga_refl.
            auto.
          auto.
          apply out_trivial.
          auto.
          apply out_trivial.
          auto.
          apply bet_out.
            auto.
          assumption.
        apply out_trivial.
        auto.
      eapply conga_preserves_lta.
        apply conga_sym.
        apply H9.
        apply conga_right_comm.
        apply conga_refl.
          intro.
          subst D.
          apply H5.
          apply col_trivial_3.
        auto.
      assumption.
    split.
      assumption.
    unfold Per in H.
    ex_and H B'.
    unfold Midpoint in H.
    spliter.
    assert(HH:= H8).
    assert(~Col B D B').
      intro.
      apply H5.
      apply (col_transitivity_1 _ B').
        intro.
        subst B'.
        apply between_identity in H.
        contradiction.
        apply (col_transitivity_1 _ C).
          assumption.
          apply bet_col.
          assumption.
        apply bet_col in H3.
        permut.
      permut.
    destruct(l11_44_1 B D B').
      assumption.
    apply H12 in H8.
    destruct(l11_44_2 A D B').
      intro.
      apply H10.
      apply col_permutation_1.
      eapply (col_transitivity_1 _ A).
        intro.
        subst B'.
        apply between_symmetry in H3.
        assert(B = C).
          eapply (between_equality _ _ A); assumption.
        contradiction.
        apply col_permutation_1.
        eapply (col_transitivity_1 _ C).
          assumption.
          apply bet_col.
          assumption.
        apply bet_col in H3.
        permut.
      permut.
    assert(LtA C A D C B' D).
      eapply conga_preserves_lta.
        apply conga_refl.
          auto.
        auto.
        apply conga_sym.
        eapply l11_10.
          3: apply out_trivial.
          apply conga_sym in H8.
          apply conga_comm in H8.
          apply H8.
          apply bet_out.
            intro.
            subst B'.
            apply cong_identity in H9.
            contradiction.
          apply between_symmetry.
          assumption.
          intro.
          subst B'.
          apply H10.
          apply col_trivial_2.
          apply bet_out.
            2: apply H.
            auto.
        apply out_trivial.
        intro.
        subst D.
        apply H10.
        apply col_trivial_1.
      assumption.
    assert(B' <> A).
      intro.
      subst B'.
      apply between_symmetry in H3.
      assert(B=C).
        eapply between_equality.
          apply H.
        assumption.
      contradiction.
    assert (Lt D B' D A).
      apply l11_44_2_b.
        intro.
        apply H10.
        apply col_permutation_1.
        eapply (col_transitivity_1 _ A).
          assumption.
          apply col_permutation_1.
          eapply (col_transitivity_1 _ C).
            assumption.
            apply bet_col.
            assumption.
          apply bet_col in H3.
          permut.
        permut.
      eapply (conga_preserves_lta D A C D B' C).
        eapply (l11_10).
          2: apply out_trivial.
          4: apply out_trivial.
          apply conga_refl.
            auto.
          5:apply out_trivial.
          assumption.
          auto.
          apply bet_out.
            auto.
          eapply outer_transitivity_between2.
            apply H3.
            assumption.
          assumption.
          auto.
        auto.
        eapply (l11_10).
          2: apply out_trivial.
          4: apply out_trivial.
          apply conga_refl.
            intro.
            subst B'.
            apply H10.
            apply col_trivial_2.
          5:apply out_trivial.
          auto.
          intro.
          subst B'.
          apply H10.
          apply col_trivial_2.
          apply bet_out.
            intro.
            subst B'.
            apply cong_identity in H9.
            contradiction.
            auto.
          eapply outer_transitivity_between.
            apply between_symmetry.
            apply H.
            apply between_symmetry.
            assumption.
          auto.
          intro.
          subst B'.
          apply H10.
          apply col_trivial_2.
        auto.
      apply lta_comm.
      assumption.
    unfold Lt in H17.
    spliter.
    unfold Lt.
    split.
      eapply l5_6.
      repeat split.
        apply H17.
        cong.
      apply cong_pseudo_reflexivity.
    intro.
    apply H18.
    eapply cong_transitivity.
      apply cong_symmetry.
      apply HH.
    apply cong_commutativity.
    assumption.
Qed.
per2_cong2__cong_conga2
Proof.
intros.
apply (l11_52 A B C A' B' C');auto.
apply l11_16;auto.
apply (l11_46 A B C);auto using per_not_col.
Qed.
per2_cong2__cong_3
Proof.
intros.
unfold Cong_3.
assert (Cong B A B' A') by
 (apply (per2_cong2__cong_conga2 A B C A' B' C');auto).
repeat split;Cong.
Qed.
hilbert_s_version_of_pasch_aux
Proof.
intros A B C I P HNC HNC' HBet HBI HIC HBC.
assert (HTS : TS I P B C).
  {
  assert_cols; split; try (intro; apply HNC'; ColR).
  split; try (intro; apply HNC'; ColR).
  exists I; Col.
  }
elim (two_sides_dec I P A B); intro HTS'.

  {
  destruct HTS' as [Hc1 [Hc2 [T [HCol HBet']]]].
  exists T; split; Col.
  left; split; Col.
  split; try (intro; treat_equalities; Col).
  split; intro; treat_equalities; Col.
  }

  {
  rename HTS' into HOS.
  assert (HTS' : TS I P A C).
    {
    apply l9_8_2 with B; Col.
    apply not_two_sides_one_side; unfold TS in HTS; spliter; assert_diffs; Col.
    intro; apply HOS; apply l9_2; Col.
    }
  destruct HTS' as [Hc1 [Hc2 [T [HCol HBet']]]].
  exists T; split; Col.
  right; split; Col.
  split; try (intro; treat_equalities; Col).
  split; intro; treat_equalities; Col.
  }
Qed.
not_one_side_two_sides
Proof.
apply upper_dim_implies_not_one_side_two_sides.
apply all_coplanar_implies_upper_dim; unfold all_coplanar_axiom;
apply all_coplanar.
Qed.
one_or_two_sides
Proof.
apply upper_dim_implies_one_or_two_sides.
apply all_coplanar_implies_upper_dim; unfold all_coplanar_axiom;
apply all_coplanar.
Qed.
two_sides_cases
Proof.
intros.
assert(TS O A P B \/ OS O A P B).
{
  apply(one_or_two_sides O A P B); Col.
  unfold OS in H0.
  ex_and H0 R.
  unfold TS in H0.
  spliter.
  Col.
}
induction H1.
left; auto.
right.

assert(TS O B P A \/ OS O B P A).
{
  apply(one_or_two_sides O B P A); Col.
  unfold OS in H0.
  ex_and H0 R.
  unfold TS in H2.
  spliter.
  Col.
}
induction H2.
assumption.
assert(TS O P A B).
{
  apply(l9_31 O A P B); auto.
}
apply l9_9 in H3.
contradiction.
Qed.
not_par_two_sides
Proof.
intros A B C D I HCD HCol1 HCol2 HNC.
assert (HX : exists X, Col C D X /\ I <> X) by (exists C; split; try intro; treat_equalities; Col).
destruct HX as [X [HCol3 HIX]].
destruct (symmetric_point_construction X I) as [Y HMid].
exists X; exists Y; assert_diffs; assert_cols; do 2 (split; try ColR).
split; try (intro; assert (I = X) by (assert_diffs; assert_cols; apply l6_21 with A B C D; Col); Col).
split; try (intro; assert (I = Y) by (assert_diffs; assert_cols; apply l6_21 with A B C D;
                                      Col; ColR); Col).
exists I; unfold Midpoint in HMid; spliter; split; Col; Between.
Qed.
not_par_other_side
Proof.
intros A B C D I P HCD HCol1 HCol2 HNC1 HNC2.
destruct (not_par_two_sides A B C D I HCD HCol1 HCol2 HNC1) as [X [Y [HCol3 [HCol4 HTS]]]].
elim (two_sides_dec A B P X); intro HOS; [exists X; Col|].
assert_diffs; apply not_two_sides_one_side in HOS; Col; [|intro; unfold TS in HTS; intuition].
exists Y; split; Col.
apply l9_8_2 with X; [|apply one_side_symmetry]; Col.
Qed.
not_par_same_side
Proof.
intros A B C D I P HCD HCol1 HCol2 HNC1 HNC2.
destruct (not_par_two_sides A B C D I HCD HCol1 HCol2 HNC1) as [X [Y [HCol3 [HCol4 HTS]]]].
elim (one_side_dec A B P X); intro HTS2; [exists X; Col|].
assert_diffs; apply not_one_side_two_sides in HTS2; Col; [|intro; unfold TS in HTS; intuition].
exists Y; split; Col.
exists X; split; Side.
Qed.
os_ts__inangle
Proof.
  intros A B C P Hts Hos.
  assert(HNCol : ~ Col A B P) by (destruct Hts as []; Col).
  assert(~ Col B A C) by (apply (one_side_not_col123 _ _ _ P); auto).
  assert (HP' := symmetric_point_construction P B).
  destruct HP' as [P'].
  assert_diffs.
  assert(~ Col B A P') by (intro; apply HNCol; ColR).
  assert(HUn := two_sides_in_angle A B C P P').
  destruct HUn as [|Habs]; Between.
  exfalso.
  apply in_angle_one_side in Habs; Col.
  apply l9_9_bis in Habs.
  apply Habs.
  apply invert_two_sides; apply l9_2.
  apply (l9_8_2 _ _ P); Side.
  repeat split; Col; exists B; split; Col; Between.
Qed.
os2__inangle
Proof.
  intros A B C P Hos1 Hos2.
  apply os_ts__inangle; auto.
  apply l9_31; Side.
Qed.
lea_distincts
Proof.
  intros A B C D E F Hlea.
  destruct Hlea as [X [HInAngle HConga]].
  destruct HInAngle as [HDE [HEF _]].
  repeat split; auto.
  apply (conga_diff1 A B C D E X); auto.
  apply (conga_diff2 A B C D E X); auto.
Qed.
gea_distincts
Proof.
  intros A B C D E F Hgea.
  apply lea_distincts in Hgea.
  spliter.
  repeat split; auto.
Qed.
lta_distincts
Proof.
  intros A B C D E F Hlta.
  destruct Hlta as [Hlea HConga].
  apply lea_distincts in Hlea.
  spliter.
  repeat split; auto.
Qed.
gta_distincts
Proof.
  intros A B C D E F Hgta.
  apply lta_distincts in Hgta.
  spliter.
  repeat split; auto.
Qed.
acute_distincts
Proof.
  intros A B C Hacute.
  destruct Hacute as [x [y [z [HPer Hlta]]]].
  apply lta_distincts in Hlta.
  spliter.
  split; auto.
Qed.
obtuse_distincts
Proof.
  intros A B C Hobtuse.
  destruct Hobtuse as [x [y [z [HPer Hgta]]]].
  apply gta_distincts in Hgta.
  spliter.
  split; auto.
Qed.
acute_conga__acute
Proof.
  intros A B C D E F Hacute HConga.
  apply (acute_lea_acute _ _ _ A B C); auto.
  apply conga__lea.
  apply conga_sym; assumption.
Qed.
obtuse_conga__obtuse
Proof.
  intros A B C D E F Hobtuse HConga.
  apply (obtuse_gea_obtuse _ _ _ A B C); auto.
  apply conga__lea; assumption.
Qed.
bet_lea__bet
Proof.
  intros A B C D E F HBet Hlea.
  apply (bet_conga_bet A B C); auto.
  apply lea_asym; auto.
  apply lea_distincts in Hlea.
  spliter.
  apply l11_31_2; auto.
Qed.
out_lea__out
Proof.
  intros A B C D E F Hout Hlea.
  apply (out_conga_out D E F); auto.
  apply lea_asym; auto.
  apply lea_distincts in Hlea.
  spliter.
  apply l11_31_1; auto.
Qed.
bet2_lta__lta
Proof.
  intros A B C D E F A' D' Hlta.
  intros.
  apply lta_diff in Hlta.
  unfold LtA in *.
  spliter.
  split.
  apply (l11_36 A _ _ D); auto.
  intro.
  assert(CongA A B C D E F); auto.
  apply (l11_13 A' _ _ D'); try (apply conga_sym); Between.
Qed.
lta__lea
Proof.
  intros.
  destruct H.
  assumption.
Qed.
lea123456_lta__lta
Proof.
  intros A B C D E F G H I Hlea Hlta.
  split.
  - apply (lea_trans _ _ _ D E F).
    assumption.
    apply lta__lea; assumption.
  - intro.
    destruct Hlta as [Hlea' HNConga].
    apply HNConga.
    apply lea_asym.
    assumption.
    apply (l11_30 A B C D E F); auto.
    apply lea_distincts in Hlea.
    spliter.
    apply conga_refl; assumption.
Qed.
lea456789_lta__lta
Proof.
  intros A B C D E F G H I Hlta Hlea.
  split.
  - apply (lea_trans _ _ _ D E F).
    apply lta__lea; assumption.
    assumption.
  - intro.
    destruct Hlta as [Hlea' HNConga].
    apply HNConga.
    apply lea_asym.
    assumption.
    apply (l11_30 D E F G H I); auto.
    2: apply conga_sym; assumption.
    apply lea_distincts in Hlea.
    spliter.
    apply conga_refl; assumption.
Qed.
acute_per__lta
Proof.
  intros A B C D E F Hacute HDE HEF HPer.
  intros.
  destruct Hacute as [G [H [I [HPer2 Hlta]]]].
  assert(Hdiff := lta_distincts A B C G H I Hlta).
  spliter.
  apply (conga_preserves_lta A B C G H I); try (apply conga_refl); auto.
  apply l11_16; auto.
Qed.
obtuse_per__lta
Proof.
  intros A B C D E F Hobtuse HDE HEF HPer.
  intros.
  destruct Hobtuse as [G [H [I [HPer2 Hgta]]]].
  assert(Hdiff := gta_distincts A B C G H I Hgta).
  spliter.
  apply (conga_preserves_lta G H I A B C); try (apply conga_refl); auto.
  apply l11_16; auto.
Qed.
acute_obtuse__lta
Proof.
  intros A B C D E F Hacute Hobtuse.
  destruct Hacute as [G [H [I [HPer Hlta]]]].
  apply (lta_trans _ _ _ G H I); auto.
  apply lta_distincts in Hlta.
  spliter.
  apply obtuse_per__lta; auto.
Qed.
out__acute
Proof.
  intros A B C Hout.
  assert_diffs.
  assert(HD := perp_exists B A B).
  destruct HD as [D]; auto.
  assert_diffs.
  exists A.
  exists B.
  exists D.
  split; Perp.
  split.
  apply l11_31_1; auto.
  intro.
  assert(HNCol : ~ Col A B D) by (apply per_not_col; Perp).
  apply HNCol.
  apply col_permutation_4.
  apply out_col.
  apply (l11_21_a A B C); auto.
Qed.
bet__obtuse
Proof.
  intros A B C HBet HAB HBC.
  assert(HD := perp_exists B A B).
  destruct HD as [D]; auto.
  assert_diffs.
  exists A.
  exists B.
  exists D.
  split; Perp.
  split.
  apply l11_31_2; auto.
  intro.
  assert(HNCol : ~ Col A B D) by (apply per_not_col; Perp).
  apply HNCol.
  apply bet_col.
  apply (bet_conga_bet A B C); try (apply conga_sym); auto.
Qed.
lea_in_angle
Proof.
    intros.
    assert(H1 := H0).
    clear H0.
    assert(H0 : CongA A B P A B P).
    { assert(~ Col A B P) by (apply (one_side_not_col123 _ _ _ C); Side).
      assert_diffs.
      apply conga_refl; auto.
    }
    unfold LeA in H.
    ex_and H T.
    eapply conga_preserves_in_angle.
      3: apply H.
      apply conga_refl.
        assert(HH0:=H0).
        unfold CongA in HH0.
        spliter.
        clear H6.
        repeat split; auto.
      intro.
      subst C.
      unfold OS in H1.
      ex_and H1 X.
      unfold TS in H1.
      spliter.
      apply H1.
      Col.
      eapply conga_trans; apply conga_sym.
        apply H2.
      apply H0.
    apply one_side_symmetry.
    assumption.
Qed.
bet_acute__obtuse
Proof.
  intros A B C A' HBet HA'B Hacute.
  assert(Hd := acute_distincts A B C Hacute).
  destruct Hd.
  elim(Col_dec A B C).
  { intro.
    elim(bet_dec A B C).
    - intro.
      exfalso.
      assert(Hlta : LtA A B C A B C) by (apply acute_obtuse__lta; auto; apply bet__obtuse; auto).
      destruct Hlta as [_ HNConga].
      apply HNConga.
      apply conga_refl; auto.

    - intro.
      apply bet__obtuse; auto.
      apply between_symmetry.
      apply (l6_2 A); auto.
      apply not_bet_out; auto.
  }
  intro HNCol1.
  assert(HD := l10_15 A B B C).
  destruct HD as [D []]; Col.
  assert_diffs.
  assert(HNCol2 : ~ Col C B D).
  { intro.
    assert(Hlta : LtA A B C A B C).
    2: destruct Hlta as [_ HNConga]; apply HNConga; apply conga_refl; auto.
    apply acute_per__lta; auto.
    apply (per_col _ _ D); Perp; Col.
  }
  assert(OS B A' C D) by (apply (col_one_side _ A); Side; Col).
  exists A.
  exists B.
  exists D.
  split; Perp.
  split.
  - exists D.
    split.
    2: apply conga_comm; apply l11_18_1; Perp.
    apply os2__inangle; auto.
    exists A.
    split.
    { repeat split; Col.
      intro; apply HNCol1; ColR.
      exists B; Col; Between.
    }
    apply invert_two_sides.
    apply in_angle_two_sides; Col.
    apply l11_24.
    apply lea_in_angle; try (apply conga_refl); Side.
    apply lta__lea.
    apply acute_per__lta; Perp.

  - intro.
    apply HNCol2.
    assert(HUn := conga__or_out_ts A' B D C).
    destruct HUn.
    2: assert_cols; Col.
    2: exfalso; assert(~ TS A' B D C); auto; apply l9_9_bis; Side.
    apply (conga_trans _ _ _ A B D); auto.
    apply l11_16; auto; apply (l8_3 A); Perp; Col.
Qed.
bet_obtuse__acute
Proof.
  intros A B C A' HBet HA'B Hobtuse.
  assert(Hd := obtuse_distincts A B C Hobtuse).
  destruct Hd.
  elim(Col_dec A B C).
  { intro.
    elim(bet_dec A B C).
    - intro.
      apply out__acute.
      apply (l6_2 _ _ A); Between.

    - intro.
      exfalso.
      assert(Hlta : LtA A B C A B C).
      2: destruct Hlta as [_ HNConga]; apply HNConga; apply conga_refl; auto.
      apply acute_obtuse__lta; auto.
      apply out__acute.
      apply not_bet_out; auto.
  }
  intro HNCol1.
  assert(HD := l10_15 A B B C).
  destruct HD as [D []]; Col.
  assert_diffs.
  assert(HNCol2 : ~ Col C B D).
  { intro.
    assert(Hlta : LtA A B C A B C).
    2: destruct Hlta as [_ HNConga]; apply HNConga; apply conga_refl; auto.
    apply obtuse_per__lta; auto.
    apply (per_col _ _ D); Perp; Col.
  }
  assert(OS B A' C D) by (apply (col_one_side _ A); Side; Col).
  assert(~ Col A B D) by (apply per_not_col; Perp).
  exists A'.
  exists B.
  exists D.
  split.
  apply (l8_3 A); Perp; Col.
  split.
  - exists C.
    split; try (apply conga_refl); auto.
    apply os2__inangle; Side.
    exists A.
    split.
    { repeat split; auto.
      apply (one_side_not_col123 _ _ _ C); Side.
      exists B; Col; Between.
    }
    apply invert_two_sides.
    apply in_angle_two_sides; Col.
    apply l11_24.
    apply lea_in_angle; try (apply conga_refl); auto.
    apply lta__lea.
    apply obtuse_per__lta; Perp.

  - intro Habs.
    apply HNCol2.
    assert(HUn := conga__or_out_ts A' B C D Habs).
    destruct HUn.
    assert_cols; Col.
    exfalso; assert(~ TS A' B C D); auto; apply l9_9_bis; Side.
Qed.
inangle_dec
Proof.
  intros A B C P.
  elim(eq_dec_points A B).
    intro; subst; right; unfold InAngle; intro; spliter; auto.
  intro.
  elim(eq_dec_points C B).
    intro; subst; right; unfold InAngle; intro; spliter; auto.
  intro.
  elim(eq_dec_points P B).
    intro; subst; right; unfold InAngle; intro; spliter; auto.
  intro.
  elim(Col_dec A B C).
  { intro HColB.
    elim(bet_dec A B C).
    { intro HBBet.
      left.
      repeat split; auto.
      exists B.
      split; auto.
    }
    intro HBNBet.
    elim(out_dec B A P).
    { left.
      repeat split; auto.
      exists A; Between.
    }
    right.
    intro Habs.
    destruct Habs as [_ [_ [_ [X [HXBet HUn]]]]].
    destruct HUn as [|HoutBXP].
      subst; auto.
    assert(HInter := out2_bet_out A B C X P); auto.
    destruct HInter; auto.
    apply not_bet_out; auto.
  }
  intro HNColB.
  assert(HP' := symmetric_point_construction P B).
  destruct HP' as [P'].
  assert_diffs.
  elim(two_sides_dec B P A C).
  { intro.
    assert(HUn := two_sides_in_angle A B C P P').
    destruct HUn as [HInAngle|HInAngle]; Between.
    - destruct HInAngle as [_ [_ [_ [X [HXBet HUn]]]]].
      destruct HUn as [HXB|HBout].
        left; repeat split; auto; exists X; split; auto.
      right.
      intro Habs.
      destruct Habs as [_ [_ [_ [X' [HX'Bet HUn]]]]].
      assert(Col B X' P) by (destruct HUn; subst; assert_cols; Col).
      assert(X = X') by (apply (l6_21 A C B P); Col; ColR).
      subst X'.
      assert_diffs.
      destruct HUn as [|HBout']; auto.
      assert(Col P B P' /\ ~ Bet P B P'); spliter; Between.
      apply l6_4_1.
      apply (l6_7 _ _ X); auto.
      apply l6_6; auto.
  }
  intro HNts.
  elim(Col_dec B A P).
  { intro.
    elim(out_dec B A P).
    { intro.
      left.
      repeat split; auto.
      exists A; Between.
    }
    intro.
    right.
    intro Habs.
    destruct Habs as [_ [_ [_ [X [HXBet HUn]]]]].
    assert(Col B X P) by (destruct HUn; subst; assert_cols; Col).
    assert(X = A) by (apply (l6_21 A C B P); Col; ColR).
    subst X.
    destruct HUn; auto.
  }
  intro.
  elim(Col_dec B C P).
  { intro.
    elim(out_dec B C P).
    { intro.
      left.
      repeat split; auto.
      exists C; Between.
    }
    intro.
    right.
    intro Habs.
    destruct Habs as [_ [_ [_ [X [HXBet HUn]]]]].
    assert(Col B X P) by (destruct HUn; subst; assert_cols; Col).
    assert(X = C) by (apply (l6_21 A C B P); Col; ColR).
    subst X.
    destruct HUn; auto.
  }
  intro.
  right.
  intro.
  apply HNts.
  apply invert_two_sides.
  apply in_angle_two_sides; auto.
Qed.
lea_dec
Proof.
  intros A B C D E F.
  elim(eq_dec_points A B).
    intro; right; intro Hlea; apply lea_distincts in Hlea; spliter; auto.
  intro.
  elim(eq_dec_points B C).
    intro; right; intro Hlea; apply lea_distincts in Hlea; spliter; auto.
  intro.
  elim(eq_dec_points D E).
    intro; right; intro Hlea; apply lea_distincts in Hlea; spliter; auto.
  intro.
  elim(eq_dec_points E F).
    intro; right; intro Hlea; apply lea_distincts in Hlea; spliter; auto.
  intro.
  elim(Col_dec A B C).
  { intro.
    elim(out_dec B A C).
      intro; left; apply l11_31_1; auto.
    intro.
    elim(bet_dec D E F).
      intro; left; apply l11_31_2; auto.
    intro HENBet.
    right.
    intro.
    apply HENBet.
    apply (bet_lea__bet A B C); auto.
    apply not_out_bet; auto.
  }
  intro HNColB.
  elim(Col_dec D E F).
  { intro.
    elim(bet_dec D E F).
      intro; left; apply l11_31_2; auto.
    intro.
    right.
    intro.
    apply HNColB.
    apply col_permutation_4.
    apply out_col.
    apply (out_lea__out _ _ _ D E F); auto.
    apply not_bet_out; auto.
  }
  intro.
  assert(HP := angle_construction_1 A B C D E F).
  destruct HP as [P []]; Col.
  elim(inangle_dec D E F P).
    intro; left; exists P; auto.
  intro HNInAngle.
  right.
  intro.
  apply HNInAngle.
  apply lea_in_angle; try (apply conga_sym); Side.
  apply (l11_30 A B C D E F); auto; apply conga_refl; auto.
Qed.
gea_dec
Proof.
  intros A B C D E F.
  unfold GeA.
  elim(lea_dec D E F A B C); auto.
Qed.
lta_dec
Proof.
  intros A B C D E F.
  elim(conga_dec A B C D E F).
  { intro.
    right.
    unfold LtA.
    intro.
    spliter.
    auto.
  }
  intro.
  elim(lea_dec A B C D E F).
  { intro.
    left.
    split; auto.
  }
  intro.
  right.
  unfold LtA.
  intro.
  spliter.
  auto.
Qed.
gta_dec
Proof.
  intros A B C D E F.
  unfold GtA.
  elim(lta_dec D E F A B C); auto.
Qed.
lea_total
Proof.
  intros A B C D E F HAB HBC HDE HEF.
  elim(Col_dec A B C).
  { intro.
    elim(out_dec B A C).
    - intro; left; apply l11_31_1; auto.
    - intro; right; apply l11_31_2; auto; apply not_out_bet; auto.
  }
  intro.
  elim(Col_dec D E F).
  { intro.
    elim(out_dec E D F).
    - intro; right; apply l11_31_1; auto.
    - intro; left; apply l11_31_2; auto; apply not_out_bet; auto.
  }
  intro.
  elim(lea_dec A B C D E F).
    intro; left; auto.
  intro HNlea.
  right.
  assert(HP := angle_construction_1 D E F A B C).
  destruct HP as [P []]; Col.
  exists P.
  split; auto.
  apply os2__inangle; Side.
  apply not_two_sides_one_side; Col.
  - intro.
    apply HNlea.
    apply conga__lea.
    apply (out_conga A B P D E F); try (apply out_trivial); try (apply conga_sym); auto.
    apply (col_one_side_out _ A); Col; Side.

  - intro.
    apply HNlea.
    apply (l11_30 A B C A B P); try (apply conga_refl); try (apply conga_sym); auto.
    exists C.
    split; try (apply conga_refl); auto.
    apply os_ts__inangle; Side.
Qed.
gea_total
Proof.
  intros A B C D E F HAB HBC HDE HEF.
  elim(lea_total A B C D E F); auto.
Qed.
or_lta_conga_gta
Proof.
    intros.
    assert(HH:=lea_total A B C D E F).
    induction HH; auto.
      induction(conga_dec A B C D E F).
        right; right.
        assumption.
      left.
      unfold LtA.
      split; assumption.
    induction(conga_dec A B C D E F).
      right; right.
      assumption.
    right; left.
    unfold GtA.
    unfold LtA.
    split.
      assumption.
    intro.
    apply H4.
    apply conga_sym.
    assumption.
Qed.
angle_partition
Proof.
  intros A B C HAB HBC.
  assert(Hl := lower_dim_ex).
  destruct Hl as [A' [B' [D']]].
  assert(~ Col A' B' D') by (unfold Col; auto).
  assert(HC' := l10_15 A' B' B' D').
  destruct HC' as [C' [HC'Right _]]; Col.
  assert_diffs.
  destruct (or_lta_conga_gta A B C A' B' C') as [|[|]]; auto.
  - left.
    exists A', B', C'.
    repeat (split; Perp).
  - right; right.
    exists A', B', C'.
    repeat (split; Perp).
  - right; left.
    apply (l11_17 A' B' C'); try (apply conga_sym); Perp.
Qed.
acute_chara
Proof.
  intros A B C A' HBet HBA'.
  split.
  - intro Hacute.
    assert(Hdiff := acute_distincts A B C Hacute).
    spliter.
    apply acute_obtuse__lta; auto.
    apply (bet_acute__obtuse A); auto.

  - intro Hlta.
    apply lta_diff in Hlta.
    spliter.
    elim(angle_partition A B C); auto.
    intro Habs.
    exfalso.
    assert(Hlta : LtA A B C A B C).
    2: destruct Hlta as [_ HNConga]; apply HNConga; apply conga_refl; auto.
    destruct Habs.
    { apply (conga_preserves_lta A B C A' B C); try (apply conga_refl); auto.
      apply conga_sym.
      apply conga_comm.
      apply l11_18_1; Perp.
    }
    apply (lta_trans _ _ _ A' B C); auto.
    apply acute_obtuse__lta; auto.
    apply (bet_obtuse__acute A); auto.
Qed.
obtuse_chara
Proof.
  intros A B C A' HBet HBA'.
  split.
  - intro Hobtuse.
    assert(Hdiff := obtuse_distincts A B C Hobtuse).
    spliter.
    apply acute_obtuse__lta; auto.
    apply (bet_obtuse__acute A); auto.

  - intro Hlta.
    apply lta_diff in Hlta.
    spliter.
    elim(angle_partition A B C); auto.
    { intro.
      exfalso.
      assert(Hlta : LtA A B C A B C).
      2: destruct Hlta as [_ HNConga]; apply HNConga; apply conga_refl; auto.
      apply (lta_trans _ _ _ A' B C); auto.
      apply acute_obtuse__lta; auto.
      apply (bet_acute__obtuse A); auto.
    }
    intro HUn.
    destruct HUn; auto.
    exfalso.
    assert(Hlta : LtA A B C A B C).
    2: destruct Hlta as [_ HNConga]; apply HNConga; apply conga_refl; auto.
    apply (conga_preserves_lta A' B C A B C); try (apply conga_refl); auto.
    apply conga_sym.
    apply conga_comm.
    apply l11_18_1; Between; Perp.
Qed.
conga__acute
Proof.
  intros A B C HCongA.
  destruct (Col_dec A B C).
  { apply out__acute, not_bet_out; trivial.
    intro.
    absurd (B = C).
      apply conga_distinct in HCongA; spliter; auto.
    apply between_equality with A; apply between_symmetry; trivial.
    apply (bet_conga_bet A B C); assumption.
  }
  destruct (segment_construction C B C B) as [C' []].
  apply conga_distinct in HCongA; spliter.
  assert_diffs.
  apply acute_sym, acute_chara with C'; auto.
  destruct (l11_41 B C A C'); Col.
  apply (conga_preserves_lta B C A A B C'); trivial.
    apply conga_comm, conga_sym; assumption.
    apply conga_pseudo_refl; auto.
Qed.
cong__acute
Proof.
  intros A B C HAB HBC HCong.
  apply conga__acute.
  assert_diffs.
  destruct (l11_51 A B C A C B) as [_ []]; Cong.
Qed.
nlta
Proof.
  intros A B C.
  intro.
  apply (not_and_lta A B C A B C).
  split; assumption.
Qed.
lea__nlta
Proof.
  intros.
  intro Hlta.
  destruct Hlta as [Hlea HNConga].
  apply HNConga.
  apply lea_asym; assumption.
Qed.
lta__nlea
Proof.
  intros A B C D E F Hlta.
  destruct Hlta as [Hlea HNConga].
  intro.
  apply HNConga.
  apply lea_asym; assumption.
Qed.
nlta__lea
Proof.
  intros A B C D E F HNlta.
  intros.
  elim(conga_dec D E F A B C).
    apply conga__lea.
  intro.
  elim(lea_total D E F A B C); auto.
  intro.
  exfalso.
  apply HNlta.
  split; auto.
  apply not_conga_sym; assumption.
Qed.
nlea__lta
Proof.
  intros A B C D E F HNlea.
  intros.
  split.
  - elim(lea_total D E F A B C); auto.
    intro; exfalso; auto.
  - intro.
    apply HNlea.
    apply conga__lea.
    apply conga_sym; assumption.
Qed.
triangle_strict_inequality
Proof.
  intros A B C D HBet HCong HNBet.
  elim(Col_dec A B C).
  { intro.
    assert(A <> B) by (intro; Between).
    assert(B <> C) by (intro; Between).
    apply not_bet_out in HNBet; Col.
    destruct HNBet as [_ [_ [HBAC|HBCA]]].
    - split.
      { apply (le_transitivity _ _ B C).
        apply le_comm; exists A; split; Between; Cong.
        apply (l5_6 D B D A); Cong; exists B; split; Between; Cong.
      }
      intro.
      assert(A = B); auto.
      apply between_symmetry in HBAC.
      apply (l7_17 C D); split; Cong.
        apply (outer_transitivity_between _ _ B); auto.
        apply (outer_transitivity_between2 _ A); auto.

    - assert(Bet A C D) by (apply (between_exchange4 _ _ B); Between).
      split.
        exists C; split; Cong.
      intro.
      assert(C = D) by (apply (between_cong A); auto).
      subst D.
      assert(B = C); auto.
      apply (between_equality _ _ A); Between.
  }
  intro HNCol.
  assert_diffs.
  assert(A <> D) by (intro; treat_equalities; auto).
  assert(~ Col A C D) by (intro; apply HNCol; ColR).
  assert_diffs.
  apply between_symmetry in HBet.
  apply l11_44_2; Col.
  assert(CongA C D A D C B).
  { apply (out_conga C D B D C B); try (apply out_trivial); auto.
    2: apply bet_out; auto.
    apply conga_comm.
    apply l11_44_1; Cong.
    intro; apply HNCol; ColR.
  }
  split.
  - apply lea_comm.
    exists B.
    repeat (split; auto).
    exists B.
    split; auto.
    right; apply out_trivial; auto.

  - intro.
    assert(Habs := conga__or_out_ts D C A B).
    destruct Habs as [Hout|Hts].
      apply (conga_trans _ _ _ C D A); auto; apply conga_sym; apply conga_comm; auto.
    apply HNCol; Col.
    assert(~ TS D C A B); auto.
    apply l9_9_bis.
    apply out_one_side; Col.
    apply l6_6; apply bet_out; auto.
Qed.
triangle_inequality
Proof.
  intros A B C D HCong HBet.
  elim(bet_dec A B C).
  - intro.
    elim(eq_dec_points A B).
      intro; subst; Le.
    intro.
    assert(C = D).
    apply (construction_uniqueness A B B D); Cong.
    subst; Le.

  - intro.
    assert(Hlt := triangle_strict_inequality A B C D).
    destruct Hlt; auto.
Qed.
triangle_strict_inequality_2
Proof.
  intros A B C A' B' C' HBet HCongA HCongB HNBet.
  destruct (segment_construction A B B C) as [D [HBetD HCongD]].
  apply (cong2_lt__lt A C A D); Cong.
    apply (triangle_strict_inequality _ B); Cong.
  apply (l2_11 _ B _ _ B'); Cong.
  apply cong_transitivity with B C; trivial.
Qed.
triangle_inequality_2
Proof.
  intros A B C A' B' C' HBet HCongA HCongB.
  destruct (segment_construction A B B C) as [D [HBetD HCongD]].
  apply (l5_6 A C A D); Cong.
    apply (triangle_inequality _ B); Cong.
  apply (l2_11 _ B _ _ B'); Cong.
  apply cong_transitivity with B C; trivial.
Qed.
triangle_strict_reverse_inequality
Proof.
  intros A B C D HABD HCong HNout.
  elim(Col_dec A B C).
  { intro.
    assert_diffs.
    apply not_out_bet in HNout; Col.
    assert(Bet D A C) by (apply (l6_2 B); auto).
    assert(C <> D) by (intro; treat_equalities; auto).
    split.
    2: intro; assert(A = B); auto; apply (l7_17 D C); split; Cong; apply l7_20_bis; auto; ColR.
    destruct HABD as [_ [_ [HABD|HADB]]].
    - apply (le_transitivity _ _ A D).
        apply le_comm; exists B; split; Between; Cong.
      apply (l5_6 C A C B); Cong.
      exists A; split; Between; Cong.

    - exists D.
      split; Cong.
      apply (outer_transitivity_between _ _ A); Between.
  }
  intro HNCol.
  assert_diffs.
  elim(eq_dec_points B D).
  { intro.
    subst.
    split; Le.
    intro; treat_equalities; auto.
  }
  intro.
  assert(HNCol2 : ~ Col B C D) by (intro; apply HNCol; ColR).
  assert(HNCol3 : ~ Col A C D) by (intro; apply HNCol; ColR).
  assert_diffs.
  apply l11_44_2; Col.
  assert(CongA A C D A D C) by (apply l11_44_1; Cong; Col).
  destruct HABD as [_ [_ [HABD|HADB]]].
  - apply between_symmetry in HABD.
    apply (conga_preserves_lta D C B D C A).
      apply conga_pseudo_refl; auto.
      apply (out_conga D C A A D C); try (apply out_trivial); try (apply conga_left_comm); auto; apply l6_6; apply bet_out; auto.
    split.
    { exists B.
      split; try (apply conga_refl); auto.
      repeat split; auto.
      exists B.
      split; auto.
      right; finish.
    }
    intro.
    assert(~ TS D C B A).
    { apply l9_9_bis.
      apply out_one_side; Col.
      apply bet_out; auto.
    }
    assert(Habs := conga__or_out_ts D C B A).
    destruct Habs as [Hout|Hts]; auto.
    apply HNCol; Col.

  - assert(HE := symmetric_point_construction B C).
    destruct HE as [E []].
    assert_diffs.
    apply (bet2_lta__lta A _ _ E); Between.
    assert (OS D C A E).
    { exists B.
        repeat split; Col.
        exists D; Col.
        intro; apply HNCol2; ColR.
        exists C; split; finish.
    }
    apply (conga_preserves_lta A C D E C D); try (apply conga_refl); auto.
    split.
    { apply lea_comm.
      exists A.
      split.
      2: apply conga_refl; auto.
      apply os2__inangle; Side.
      apply (col_one_side _ B); Col.
      apply invert_one_side.
      apply out_one_side; Col.
      apply bet_out; Between.
    }
    intro.
    assert(Habs := conga__or_out_ts D C A E).
    destruct Habs as [Hout|Hts]; try (apply conga_comm); auto.
      apply HNCol; ColR.
      assert(~ TS D C A E); try (apply l9_9_bis); auto.
Qed.
triangle_reverse_inequality
Proof.
  intros A B C D HABD HCong.
  elim(out_dec A B C).
  2: apply triangle_strict_reverse_inequality; auto.
  intro.
  assert_diffs.
  assert(C = D) by (apply (l6_11_uniqueness A A C B); Cong; apply l6_6; auto).
  subst; Le.
Qed.
os3__lta
Proof.
  intros A B C D HosC HosA HosB.
  assert(HE : InAngle D A B C) by (apply os2__inangle; Side).
  destruct HE as [_ [_ [_ [E [HEBet HUn]]]]].
  assert(HNCol : ~ Col A B C) by (apply (one_side_not_col123 _ _ _ D); auto).
  assert_ncols.
  destruct HUn as [|HBout].
    exfalso; subst; Col.
  assert(A <> E) by (intro; subst; assert_cols; Col).
  assert(C <> E) by (intro; subst; assert_cols; Col).
  assert_diffs.
  apply (lta_trans _ _ _ B E C).
  - destruct (l11_41 E A B C); auto.
      intro; apply HNCol; ColR.
    apply (conga_preserves_lta E A B B E C); try (apply conga_refl); auto.
    apply (out_conga E A B B A E); try (apply out_trivial); try (apply conga_pseudo_refl); auto.
    apply bet_out; auto.

  - assert(Out E D B).
      apply (col_one_side_out _ A); Col; apply invert_one_side; apply (col_one_side _ C); Col; Side.
    assert_diffs.
    destruct (l11_41 D E C B); auto.
      intro; apply HNCol; ColR.
      apply out2__bet; auto.
    apply (conga_preserves_lta D E C C D B); try (apply conga_pseudo_refl); auto.
    apply (out_conga D E C D E C); try (apply out_trivial); try (apply conga_refl); auto.
Qed.
bet_le__lt
Proof.
  intros A B C D HBet HAD HBD Hle.
  assert(HAB : B <> A) by (intro; treat_equalities; auto).
  apply lt_comm.
  elim(Col_dec A B C).
  { intro.
    elim(bet_dec C D B).
    { intro.
      split.
      exists D; Cong.
      intro.
      apply HBD.
      apply (between_cong C); auto.
    }
    intro HNBet.
    apply not_bet_out in HNBet; try ColR.
    assert_diffs.
    assert(Bet C D A) by (apply (l6_2 B); try (apply l6_6); Between).
    assert(A <> C) by (intro; treat_equalities; auto).
    assert(Hout : Out A C B) by (apply (l6_7 _ _ D); [apply l6_6|]; apply bet_out; Between).
    assert(~ Bet A B C).
    { intro.
      apply HAB.
      apply (between_cong C); Between.
      apply le_anti_symmetry; Le.
    }
    destruct Hout as [_ [_ [HACB|]]].
    2: exfalso; auto.
    assert(B <> C) by (intro; subst; Between).
    assert(HC' := symmetric_point_construction A C).
    destruct HC' as [C'].
    assert_diffs.
    assert(Bet C C' B).
    { apply l6_13_1.
      apply (l6_2 _ _ A); Between.
      apply (l5_6 A C B C); Cong.
    }
    apply (le3456_lt__lt _ _ C A).
    2: exists C'; split;auto with cong.
    split.
    exists D; auto with cong.
    intro.
    apply HAD.
    symmetry.
    apply (between_cong C); Between.
  }
  intro HNCol.
  assert_diffs.
  apply l11_44_2.
    intro; apply HNCol; ColR.
  apply (lea123456_lta__lta _ _ _ C A B).
  - apply (l11_30 C B A C A B); try apply (conga_refl); auto.
    2: apply (out_conga C B D C B D); try apply (out_trivial); try (apply conga_refl); auto; apply bet_out; Between.
    elim (Cong_dec A C B C).
      intro; apply conga__lea; apply l11_44_1; Col; Cong.
      intro; apply lta__lea; apply l11_44_2; Col; apply lt_comm; split; auto.

  - assert(~ Col D A C) by (intro; apply HNCol; ColR).
    assert_diffs.
    assert(HInter := l11_41 D A C B).
    destruct HInter; auto.
    apply (conga_preserves_lta D A C C D B); try (apply conga_refl); auto.
    apply (out_conga D A C C A D); try (apply out_trivial); try (apply conga_pseudo_refl); auto.
    apply bet_out; auto.
Qed.
t18_18_aux
Proof.
  intros A B C D E F HCongAB HCongAC Hlta HNCol1 HNCol2 Hle.
  assert(H:=A).
  apply lta_diff in Hlta.
  destruct Hlta as [Hlta].
  spliter.
  assert(HG0 := angle_construction_1 C A B F D E).
  destruct HG0 as [G0 []]; Col.
  assert(~ Col F D G0) by (apply (one_side_not_col123 _ _ _ E); auto).
  assert_diffs.
  assert(HG := segment_construction_3 D G0 A B).
  destruct HG as [G []]; auto.
  assert(CongA C A B F D G) by (apply (out_conga C A B F D G0); try (apply out_trivial); auto).
  assert(OS F D G E).
  { apply (one_side_transitivity _ _ _ G0); auto.
    apply invert_one_side.
    apply out_one_side; Col.
    apply l6_6; auto.
  }
  assert(HNCol3 : ~ Col F D G) by (apply (one_side_not_col123 _ _ _ E); auto).
  clear dependent G0.

  assert_diffs.
  assert(HSAS := l11_49 C A B F D G).
  destruct HSAS as [HCongBC _]; Cong.
  apply (cong2_lt__lt F E F G); Cong.
  apply (conga_preserves_lta _ _ _ _ _ _ F D E F D G) in Hlta; try (apply conga_refl); auto.
  assert(Cong D G D E) by (apply (cong_transitivity _ _ A B); auto).
  clear dependent A.
  clear dependent B.

  assert(~ Col E F G).
  { intro.
    destruct Hlta as [Hlea HNConga].
    apply HNConga.
    assert (HSSA := l11_52 E F D G F D).
    destruct HSSA as [_[]]; Cong; Le.
    apply (out_conga G F D G F D); try (apply out_trivial); try (apply conga_refl); auto.
    apply (col_one_side_out _ D); Col.
  }
  assert(~ Col D E G).
  { intro.
    destruct Hlta as [Hlea HNConga].
    apply HNConga.
    apply (out_conga F D G F D G); try (apply out_trivial); try (apply conga_refl); auto.
    apply (col_one_side_out _ F); Col; Side.
  }
  apply l11_44_2; Col.
  assert(HInAngle : InAngle E F D G) by (apply lea_in_angle; destruct Hlta; auto).
  clear H.
  destruct HInAngle as [_ [_ [_ [H [HH HUn]]]]].
  destruct HUn.
    exfalso; subst; Col.
  assert(H <> F) by (intro; subst; assert_cols; Col).
  assert(H <> G) by (intro; subst; assert_cols; Col).
  assert(Hlt : Lt D H D E).
  { apply (cong2_lt__lt H D G D); Cong.
    apply (bet_le__lt F); auto.
    apply (l5_6 D F D E); Cong.
  }
  destruct Hlt.
  assert(H <> E) by (intro; subst; Cong).
  assert(Bet D H E) by (apply l6_13_1; Le).
  assert_diffs.
  assert(~ TS E G F D).
  { apply l9_9_bis.
    apply (one_side_transitivity _ _ _ H);
    [apply invert_one_side; apply one_side_symmetry|];
    apply out_one_side; Col;
    apply bet_out; Between.
  }
  apply (lta_trans _ _ _ D E G).
  - apply(conga_preserves_lta F G E D G E); try (apply conga_refl); auto.
      apply l11_44_1; Col.
    split.
    { apply lea_comm.
      exists F.
      split; try (apply conga_refl); auto.
      repeat split; auto.
      exists H.
      split; Between.
      right; apply bet_out; Between.
    }
    intro HConga.
    apply conga_comm in HConga.
    assert(Habs := conga__or_out_ts E G F D HConga).
    destruct Habs as [Hout|Hts]; assert_cols; Col.

  - apply lta_comm.
    split.
    { exists D.
      split; try (apply conga_refl); auto.
      repeat split; auto.
      exists H.
      split; Between.
      right; apply bet_out; Between.
    }
    intro HConga.
    assert(Habs := conga__or_out_ts G E D F HConga).
    destruct Habs as [Hout|Hts]; assert_cols; Col; Side.
Qed.
t18_18
Proof.
  intros A B C D E F HCongAB HCongAC Hlta.
  apply lta_diff in Hlta.
  destruct Hlta as [Hlta].
  spliter.
  elim(Col_dec A B C).
  { intro.
    elim(bet_dec B A C).
    - intro.
      assert(HC' := segment_construction E D A C).
      destruct HC' as [C' []].
      apply (cong2_lt__lt E F E C'); Cong.
      2: apply (l2_11 _ D _ _ A); Cong.
      apply (triangle_strict_inequality _ D); auto.
      apply (cong_transitivity _ _ A C); Cong.
      intro.
      destruct Hlta as [_ HNConga].
      apply HNConga.
      apply conga_line; Between.

    - intro.
      exfalso.
      apply (nlta C A B).
      apply (lea123456_lta__lta _ _ _ F D E); auto.
      apply l11_31_1; auto.
      apply not_bet_out; Col; Between.
  }
  intro.
  elim(Col_dec D E F).
  { intro.
    elim(bet_dec F D E).
    - intro.
      exfalso.
      apply (nlta F D E).
      apply (lea456789_lta__lta _ _ _ C A B); auto.
      apply l11_31_2; auto.

    - intro HNBet.
      apply not_bet_out in HNBet; Col.
      assert(HF' := segment_construction_3 A B A C).
      destruct HF' as [F' []]; auto.
      apply (cong2_lt__lt B F' B C); Cong.
      { apply (triangle_strict_reverse_inequality A); Cong.
        intro.
        destruct Hlta as [_ HNConga].
        apply HNConga.
        apply l11_21_b; auto.
        apply l6_6; auto.
      }
      apply (out_cong_cong A _ _ D); auto.
      apply l6_6; auto.
      apply (cong_transitivity _ _ A C); auto.
  }
  intro.
  elim(le_cases D F D E); intro; [|apply lt_comm; apply lta_comm in Hlta];
  apply (t18_18_aux A _ _ D); Cong; Col.
Qed.
t18_19
Proof.
  intros A B C D E F HAB HAC HCongAB HCongAC Hlt.
  assert_diffs.
  apply nlea__lta; auto.
  intro Hlea.
  elim(conga_dec C A B F D E).
  - intro.
    exfalso.
    destruct Hlt as [Hle HNCong].
    apply HNCong.
    assert(HSAS := l11_49 C A B F D E).
    destruct HSAS; Cong.

  - intro.
    apply (not_and_lt E F B C).
    split; auto.
    apply (t18_18 D _ _ A); Cong.
    split; auto.
Qed.
acute_trivial
Proof.
    intros.
    assert(HH:= not_col_exists A B H).
    ex_and HH P.
    assert(exists C : Tpoint, Per C B A /\ Cong C B A B /\ OS A B C P).
      apply(ex_per_cong A B B P A B H H); Col; exists A.
    ex_and H1 C.
    assert_diffs.
    unfold Acute.
    exists A.
    exists B.
    exists C.
    split.
      apply l8_2.
      auto.
    unfold LtA.
    split.
      unfold LeA.
      exists A.
      split.
        apply in_angle_trivial_1; auto.
      apply conga_refl; auto.
    intro.
    assert(Out B A C).
      apply(out_conga_out A B A A B C).
        apply out_trivial; auto.
      auto.
    assert(Perp C B B A).
      apply per_perp_in in H1; auto.
      apply perp_in_perp_bis in H1.
      induction H1.
        apply perp_not_eq_1 in H1.
        tauto.
      auto.
    apply perp_comm in H8.
    apply perp_not_col in H8.
    apply out_col in H7.
    Col.
Qed.
acute_not_per
Proof.
    intros.
    unfold Acute in H.
    ex_and H A'.
    ex_and H0 B'.
    ex_and H C'.
    unfold LtA in H0.
    spliter.
    intro.
    apply H1.
    assert(A <> B /\ C <> B /\ A' <> B' /\ C' <> B').
      unfold LeA in H0.
      ex_and H0 X.
      apply conga_distinct in H3.
      spliter.
      repeat split; auto.
      unfold InAngle in H0.
      spliter; auto.
    spliter.
    apply(l11_16 A B C A' B' C'); auto.
Qed.
angle_bisector
Proof.
  intros A B C HAB HCB.
  elim (Col_dec A B C).
  { intro HCol.
    elim (bet_dec A B C).
    - intro HBet; destruct (not_col_exists A B) as [Q HNCol]; trivial.
      destruct (l10_15 A B B Q) as [P [HPerp HOS]]; Col.
      assert_diffs; exists P; split.
        apply in_angle_line; auto.
      apply l11_18_1; Perp.
    - intro HOut; apply not_bet_out in HOut; trivial; assert_diffs.
      exists C; split.
        repeat split; auto.
       exists C; split; Between.
        right; apply out_trivial; auto.
      apply l11_21_b.
        apply l6_6; trivial.
      apply out_trivial; auto.
  }
  intro HNCol.
  assert_diffs.
  destruct (l6_11_existence B B A C) as [C0 [HOut HCong]]; auto.
  destruct (midpoint_existence A C0) as [P HP].
  exists P.
  assert_diffs.
  assert (HNCol1 : ~ Col A B C0) by (intro; apply HNCol; ColR).
  assert_diffs.
  assert (P <> B) by (intro; subst P; apply HNCol1; Col).
  split.
    apply (l11_25 P A B C0); try (apply out_trivial); auto; [|apply l6_6; trivial].
    repeat split; auto.
    exists P; split; Between.
    right; apply out_trivial; auto.
  destruct (l11_51 B P A B P C0); auto with cong.
  apply (out_conga P B A P B C0); try (apply out_trivial); auto.
Qed.
reflectl__conga
Proof.
  intros A B P P' HAB HBP HRefl.
  destruct HRefl as [[A' [HMid HCol]] [HPerp|Heq]]; [|subst; apply conga_refl; auto].
  assert_diffs.
  destruct (eq_dec_points A' B).
    subst A'.
    assert_diffs.
    apply l11_16; auto; apply perp_per_1;
    [apply perp_col1 with P'|apply perp_col1 with P]; Col; Perp.
  destruct HMid as [HBet HCong].
  destruct (l11_49 B A' P B A' P') as [HCong1 [HConga1 HConga2]]; Cong.
    apply l11_16; auto;
    apply perp_per_1, perp_left_comm, perp_col with A; Col;
    [apply perp_col1 with P'|apply perp_col1 with P]; Col; Perp.
  destruct (bet_dec A' B A) as [HBBet|HBOut].
    apply l11_13 with A' A'; assumption.
  apply not_bet_out in HBOut; Col.
  apply out_conga with A' P A' P'; trivial; apply out_trivial; assert_diffs; auto.
Qed.
out_conga_reflect__out
Proof.
  intros A B C P T T' HNOut HConga HOut HRefl.
  apply conga_distinct in HConga; spliter; clean.
  assert_diffs.
  assert (HConga1 : CongA P B T P B T') by (apply reflectl__conga; auto; apply is_image_spec_rev, HRefl).
  apply is_image_is_image_spec in HRefl; auto.
  apply conga_distinct in HConga1; spliter; clean.
  destruct (conga__or_out_ts P B C T'); trivial.
    apply conga_trans with P B A.
    apply conga_sym; assumption.
    apply l6_6 in HOut; apply out_conga with P T P T'; try (apply out_trivial); auto.
  exfalso.
  apply (l9_9_bis P B C T'); trivial.
  exists A; split; apply l9_2.
    destruct (conga__or_out_ts P B A C); trivial; contradiction.
  apply out_two_sides_two_sides with T B; Col.
  apply invert_two_sides, l10_14; auto.
  intro; subst T'.
  apply HNOut.
  assert (Col T B P) by (apply l10_8, HRefl).
  assert (Col P B A) by ColR.
  assert (Col P B C) by (apply (col_conga_col P B A); assumption).
  apply not_bet_out; try ColR.
  intro HBet.
  apply (per_not_col P B A); auto.
  apply l11_18_2 with C; assumption.
Qed.
col_conga_reflectl__col
Proof.
  intros A B C P T T' HNOut HConga HCol HRefl.
  destruct (eq_dec_points B T).
    subst; assert (T = T'); subst; Col.
    apply (l10_6_uniqueness_spec T P T); trivial; apply col__refl; Col.
  destruct (out_dec B A T).
    apply out_col, out_conga_reflect__out with A P T; assumption.
  destruct (segment_construction A B A B) as [A' [HA'1 HA'2]].
  destruct (segment_construction C B C B) as [C' [HC'1 HC'2]].
  assert (Out B C' T'); try ColR.
  apply conga_distinct in HConga; spliter; assert_diffs.
  apply out_conga_reflect__out with A' P T; trivial.
  - intro; apply HNOut.
    apply l6_2 with A'; auto.
    apply between_symmetry, l6_2 with C'; try (apply l6_6); Between.
  - apply conga_comm, l11_13 with A C; auto; apply conga_comm; assumption.
  - apply l6_2 with A; try (apply between_symmetry); auto.
    apply not_out_bet; Col.
Qed.
conga2__col
Proof.
  intros A B C P P' HNOut HP HP'.
  apply conga_distinct in HP; apply conga_distinct in HP'; spliter; clean.
  destruct (l6_11_existence B B A C) as [C' [HC'1 HC'2]]; auto.
  destruct (l11_49 P B A P B C'); Cong.
    apply out_conga with P A P C; try (apply out_trivial); try (apply l6_6); auto.
  destruct (l11_49 P' B A P' B C'); Cong.
    apply out_conga with P' A P' C; try (apply out_trivial); try (apply l6_6); auto.
  apply upper_dim with A C'; Cong.
  intro; subst; auto.
Qed.
col_conga__conga
Proof.
  intros A B C P P' HConga HCol HBP'.
  destruct (bet_dec P B P') as [HBet|HNBet].
    apply l11_13 with P P; auto.
  apply not_bet_out in HNBet; Col.
  apply conga_distinct in HConga; spliter.
  apply out_conga with P A P C; try (apply out_trivial); auto.
Qed.
inangle__ex_col_inangle
Proof.
  intros A B C P Q HNOut HIn.
  assert (h := inangle_distincts A B C P HIn); spliter.
  assert (A <> C) by (intro; subst; apply HNOut, out_trivial; auto).
  destruct (eq_dec_points P Q).
  { subst Q.
    destruct (eq_dec_points A P).
      subst P; exists C; split; Col.
      apply inangle3123; auto.
    exists A; split; Col; apply inangle1123; auto.
  }
  destruct (Col_dec B P Q) as [HCol|HNCol1].
  { destruct (segment_construction B P B P) as [R [HR1 HR2]].
    exists R.
    assert_diffs; split; [|split; ColR].
    apply l11_25 with P A C; try (apply out_trivial); auto.
    apply l6_6, bet_out; auto.
  }
  assert_diffs.
  destruct (Col_dec A B C) as [HCol|HNCol2].
    exists Q; split; Col.
    apply in_angle_line; auto.
    apply not_out_bet; assumption.
  destruct (Col_dec B C P) as [HCol|HNCol3].
  - assert (HNCol3 : ~ Col B A P) by (intro; apply HNCol2; ColR).
    destruct (not_par_same_side B P Q P P A) as [Q0 [HCol1 HOS]]; Col.
    assert (Hd := os_distincts B P A Q0 HOS); spliter; clean.
    destruct (one_side_dec B A P Q0).
    { assert (HIn' : InAngle Q0 A B P) by (apply os2__inangle; assumption).
      exists Q0; split; Col.
      apply in_angle_trans with P; trivial.
    }
    assert (HR : exists R, Bet P R Q0 /\ Col P Q R /\ Col B A R).
    { destruct (Col_dec B A Q0).
        exists Q0; split; Between; Col.
      assert_diffs.
      destruct (not_one_side_two_sides B A P Q0) as [_ [_ [R [HCol' HBet]]]]; Col.
      exists R; split; trivial; split; ColR.
    }
    destruct HR as [R [HR1 [HR2 HR3]]].
    assert (P <> R) by (intro; subst; apply HNCol3, HR3).
    exists R; split; auto.
    apply out321__inangle; auto.
    apply col_one_side_out with P; trivial.
    apply one_side_transitivity with Q0; trivial.
    apply one_side_not_col124 in HOS.
    apply invert_one_side, out_one_side; Col.
    apply l6_6, bet_out; auto.
  - destruct (not_par_same_side B P Q P P C) as [Q0 [HCol1 HOS]]; Col.
    assert (Hd := os_distincts B P C Q0 HOS); spliter; clean.
    destruct (one_side_dec B C P Q0).
    { assert (HIn' : InAngle Q0 C B P) by (apply os2__inangle; assumption).
      exists Q0; split; Col.
      apply l11_24, in_angle_trans with P; trivial.
      apply l11_24, HIn.
    }
    assert (HR : exists R, Bet P R Q0 /\ Col P Q R /\ Col B C R).
    { destruct (Col_dec B C Q0).
        exists Q0; split; Between; Col.
      assert_diffs.
      destruct (not_one_side_two_sides B C P Q0) as [_ [_ [R [HCol' HBet]]]]; Col.
      exists R; split; trivial; split; ColR.
    }
    destruct HR as [R [HR1 [HR2 HR3]]].
    assert (P <> R) by (intro; subst; apply HNCol3, HR3).
    exists R; split; auto.
    apply l11_24, out321__inangle; auto.
    apply col_one_side_out with P; trivial.
    apply one_side_transitivity with Q0; trivial.
    apply one_side_not_col124 in HOS.
    apply invert_one_side, out_one_side; Col.
    apply l6_6, bet_out; auto.
Qed.
col_inangle2__out
Proof.
  intros A B C P Q HNBet HP HQ HCol.
  assert (Hd := inangle_distincts A B C P HP);
  assert (Hd' := inangle_distincts A B C Q HQ);
  spliter; clean.
  destruct (Col_dec A B C).
    assert (Out B A C) by (apply not_bet_out; assumption).
    apply l6_7 with A; [apply l6_6|]; apply out_in_angle_out with C; auto.
  destruct (Col_dec B A P) as [HCol1|HNCol1].
    apply l6_7 with A; [apply l6_6|]; apply col_in_angle_out with C; ColR.
  apply col_one_side_out with A; trivial.
  apply one_side_transitivity with C; [|apply one_side_symmetry];
    apply invert_one_side, in_angle_one_side; Col.
  intro; apply HNCol1; ColR.
Qed.
inangle2__lea
Proof.
  intros A B C P Q HP HQ.
  assert (HP' := l11_24 P A B C HP).
  assert (HQ' := l11_24 Q A B C HQ).
  assert (Hd := inangle_distincts A B C P HP);
  assert (Hd' := inangle_distincts A B C Q HQ);
  spliter; clean.
  destruct (Col_dec A B C) as [HCol|HNCol].
  { destruct (bet_dec A B C).
      apply l11_31_2; auto.
    apply l11_31_1; auto.
    assert (Out B A C) by (apply not_bet_out; assumption).
    apply l6_7 with A; [apply l6_6|]; apply out_in_angle_out with C; auto.
  }
  destruct (Col_dec B P Q) as [HCol1|HNCol1].
    apply l11_31_1; auto; apply col_inangle2__out with A C; auto.
    intro; apply HNCol; Col.
  destruct (Col_dec B A P) as [HCol2|HNCol2].
  { assert (Out B A P) by (apply col_in_angle_out with C; auto; intro; apply HNCol; Col).
    exists Q; split; trivial.
    apply out_conga with A Q A Q; try (apply out_trivial); auto.
    apply conga_refl; auto.
  }
  destruct (Col_dec B C P) as [HCol3|HNCol3].
  { assert (Out B C P).
      apply col_in_angle_out with A; auto; intro; apply HNCol; Col.
    apply lea_right_comm.
    exists Q; split; trivial.
    apply out_conga with C Q C Q; try (apply out_trivial); auto.
    apply conga_refl; auto.
  }
  destruct (Col_dec B A Q) as [HCol4|HNCol4].
  { assert (Out B A Q) by (apply col_in_angle_out with C; auto; intro; apply HNCol; Col).
    apply lea_left_comm.
    exists P; split; trivial.
    apply out_conga with A P A P; try (apply out_trivial); auto.
    apply conga_refl; auto.
  }
  destruct (Col_dec B C Q) as [HCol5|HNCol5].
  { assert (Out B C Q).
      apply col_in_angle_out with A; auto; intro; apply HNCol; Col.
    apply lea_comm.
    exists P; split; trivial.
    apply out_conga with C P C P; try (apply out_trivial); auto.
    apply conga_refl; auto.
  }
  destruct (one_or_two_sides B P A Q) as [HOS|HTS]; Col.
  - apply lea_trans with P B C; [|apply lea_comm]; apply inangle__lea; trivial.
    apply os2__inangle; apply invert_one_side.
      exists A; split; Side; apply in_angle_two_sides; Col.
    apply one_side_transitivity with A; [|apply one_side_symmetry];
    apply in_angle_one_side; Col.
  - apply lea_trans with A B P; [apply lea_right_comm|]; apply inangle__lea; trivial.
    apply os2__inangle; trivial.
    apply invert_one_side, one_side_transitivity with C; [|apply one_side_symmetry];
    apply in_angle_one_side; Col.
Qed.
conga_inangle_per__acute
Proof.
  intros A B C P HPer HP1 HP2.
  assert (Hd := inangle_distincts A B C P HP1); spliter; clean.
  assert (HNCol : ~ Col A B C) by (apply per_not_col; auto).
  exists A, B, C; split; trivial.
  split.
    apply inangle__lea, HP1.
  intro Habs.
  assert (Per A B P) by (apply l11_17 with A B C, conga_sym; trivial).
  apply HNCol, col_permutation_1, per_per_col with P; auto.
  apply l11_17 with A B P; trivial.
  apply conga_comm, HP2.
Qed.
conga_inangle2_per__acute
Proof.
  intros A B C P Q HPer HP1 HP2 HQ.
  assert (HP' := l11_24 P A B C HP1).
  assert (HQ' := l11_24 Q A B C HQ).
  assert (Hd := inangle_distincts A B C P HP1);
  assert (Hd' := inangle_distincts A B C Q HQ);
  spliter; clean.
  assert (HNCol : ~ Col A B C) by (apply per_not_col; auto).
  assert (HAcute : Acute A B P) by (apply conga_inangle_per__acute with C; assumption).
  assert (HNCol1 : ~ Col P B A).
    intro.
    assert (Col P B C) by (apply (col_conga_col P B A); assumption).
    apply HNCol; ColR.
  assert (HNCol2 : ~ Col P B C) by (apply (ncol_conga_ncol P B A); assumption).
  assert (~ Bet A B C) by (intro; apply HNCol; Col).
  destruct (Col_dec B A Q).
    assert (Out B A Q) by (apply col_in_angle_out with C; Col).
    apply (acute_conga__acute A B P); trivial.
    apply out_conga with A P P A; try (apply out_trivial); auto.
    apply conga_pseudo_refl; auto.
  destruct (Col_dec B C Q).
    assert (Out B C Q) by (apply col_in_angle_out with A; Between; Col).
    apply (acute_conga__acute A B P); trivial.
    apply out_conga with A P P C; try (apply out_trivial); auto.
    apply conga_left_comm, HP2.
  destruct (Col_dec B P Q).
    apply out__acute, col_inangle2__out with A C; assumption.
  destruct (one_or_two_sides B P A Q) as [HOS|HTS]; Col.
  - apply acute_lea_acute with P B C.
      apply (acute_conga__acute A B P); try (apply conga_left_comm); assumption.
    exists Q; split; [|apply conga_refl; auto].
    apply os2__inangle; apply invert_one_side.
      exists A; split; Side; apply in_angle_two_sides; Col.
    apply one_side_transitivity with A; [|apply one_side_symmetry];
    apply in_angle_one_side; Col.
    - apply acute_lea_acute with A B P; trivial.
      apply lea_comm.
      exists Q; split; [|apply conga_pseudo_refl; auto].
      apply os2__inangle; trivial.
      apply invert_one_side, one_side_transitivity with C; [|apply one_side_symmetry];
      apply in_angle_one_side; Col.
Qed.
lta_os__ts
Proof.
intros.
unfold LtA in *.
spliter.
unfold LeA in *.
ex_and H0 P'.
assert(~Col A O B).
{
  unfold OS in H1.
  ex_and H1 R.
  unfold TS in H1.
  spliter; Col.
}
unfold TS.
repeat split; Col.
intro.
induction H5.
assert(TS O A B P).
{
  repeat split; Col.
  exists O.
  split; Col.
}
apply l9_9 in H6.
contradiction.
apply H2.
assert_diffs.
apply(out_conga A O B A O B A P A B);
try(apply out_trivial; auto).
apply conga_refl; auto.
repeat split; auto.
induction H5.
right; Between.
left; auto.
Between.
unfold InAngle in *.
spliter.
ex_and H7 T.
exists T.
split; auto.
induction H8.
treat_equalities; Col.

assert(HH:= conga__or_out_ts A O P P' H3).
induction HH.
assert(Out O P T) by (apply (l6_7) with P'; finish).
Col.
exfalso.
assert(A <> T).
{
  intro.
  treat_equalities.
  unfold TS in H9.
  spliter.
  apply H9.
  Col.
}
assert(OS O A T P').
{
  apply out_one_side.
  left.
  intro.
  apply H4.
  ColR.
  auto.
}
assert(OS A O B T).
{
  apply out_one_side.
  left; Col.
  repeat split; auto.
  intro.
  treat_equalities.
  apply H4; Col.
}
assert(OS O A B P').
{
  apply (one_side_transitivity _ _ _  T); finish.
}
assert(TS O A B P) by (apply(l9_8_2 _ _ P');finish).
apply l9_9 in H14.
contradiction.
Qed.
conga_os__out
Proof.
intros.
assert(HH:= conga__or_out_ts A O B C H).
induction HH; auto.
apply invert_two_sides in H1.
apply l9_9 in H1.
contradiction.
Qed.
acute_one_side_aux
Proof.
intros P A O B HOS.
intros.
unfold Acute in H.
ex_and H A'.
ex_and H1 B'.
ex_and H C'.

assert(Per A O B).
{
  apply perp_perp_in in H0.
  apply perp_in_comm in H0.
  apply perp_in_per in H0.
  assumption.
}
assert(CongA A' B' C' A O B).
{
  assert_diffs.
  apply l11_16; auto.
}
assert(LtA A O P A O B).
{
  apply(conga_preserves_lta A O P A' B' C' A O P A O B); auto.
  assert_diffs.
  apply conga_refl; auto.
}

assert(~Col P O B).
{
  intro.
  assert(Per A O P).
  {
    assert_diffs.
    apply (per_col A O B P); Col.
  }
  unfold LtA in H4.
  spliter.
  apply H7.
  assert_diffs.
  apply(l11_16); auto.
}

assert(NC:~Col A O P).
{
  unfold OS in HOS.
  ex_and HOS R.
  unfold TS in H6.
  spliter.
  Col.
}

assert(TS O B A P \/ OS O B A P).
{
  apply(one_or_two_sides O B A P); auto.
  apply perp_not_col in H0; Col.
}
induction H6.
unfold TS in H6.
spliter.
ex_and H8 T.

assert(O <> T).
{
  intro.
  treat_equalities.
  assert(LeA A O B A O P).
  {
    assert_diffs.
    apply(l11_31_2 A O B A O P); auto.
  }
  assert(~LtA A O P A O B).
  {
    apply lea__nlta.
    assumption.
  }
  contradiction.
}

assert(InAngle T A O P).
{
  unfold InAngle.
  assert_diffs.
  repeat split; auto.
  exists T.
  split; auto.
  right.
  finish.
}


assert(OS O A T P).
{
  apply invert_one_side.
  apply out_one_side.
  right; Col.
  assert_diffs.
  repeat split; auto.
  apply perp_not_col in H0.
  intro;  treat_equalities.
  apply H0; Col.
}

assert(OS O A T B).
{
  apply (one_side_transitivity _ _ _ P); auto.
}

destruct(l9_19 O A T B O); Col.
intro.
treat_equalities.
apply H6; Col.
apply H14 in H13.
spliter.
assert(InAngle B A O P).
{
  assert_diffs.
  apply(l11_25 T A O P A P B H11); auto;
  try(apply out_trivial; auto).
  apply l6_6; auto.
}

apply inangle__lea in H17.

apply lea__nlta in H17.
contradiction.
assumption.
Qed.
acute_one_side_aux0
Proof.
intros.
assert(LtA A O P A O B).
{
  assert_diffs.
  apply(acute_per__lta A O P A O B H0); auto.
  apply perp_perp_in in H1.
  apply perp_in_comm in H1.
  apply perp_in_per in H1.
  assumption.
}

assert(Out O A P).
{
  assert_diffs.
  induction H.
  assert(LeA A O B A O P).
  {
    apply l11_31_2; auto.
  }
  apply lea__nlta in H3.
  contradiction.
  repeat split; auto.
  induction H.
  right; Between.
  left; Between.
}
  
apply(out_one_side O B A P); auto.
left.
apply perp_not_col in H1.
Col.
Qed.
acute_one_side
Proof.
intros.
induction(Col_dec A O P).
apply(acute_one_side_aux0); auto.
assert(~Col A O B).
{
  apply perp_not_col in H0.
  Col.
}
assert(TS O A P B \/ OS O A P B).
{
  apply(one_or_two_sides O A P B); Col.
}

induction H3.
assert(HC:=symmetric_point_construction B O).
ex_and HC Bs.
unfold Midpoint in *.
spliter.
assert(TS O A Bs B).
{
  repeat split; Col.
  intro.  
  apply H2.
  ColR.
  exists O.
  split; Between.
}
assert(OS O A P Bs).
{
  apply(l9_8_1 _ _ _ _ B); auto.
}
assert(Perp O A Bs O ).
{
  apply perp_sym.
  apply perp_comm.
  apply (perp_col _ B); Perp.
  intro.
  treat_equalities.
  apply H2; Col.
  Col.
}
assert(OS O Bs A P).
{
  apply(acute_one_side_aux P A O Bs); auto.
}
apply(col_one_side _ Bs); Col.
intro.
treat_equalities.
apply H2; Col.

apply(acute_one_side_aux P A O B); auto.
Qed.
par_reflexivity
Proof.
    intros.
    unfold Par.
    unfold Par_strict.
    right.
    repeat split.
      assumption.
      assumption.
      apply col_trivial_1.
    apply col_trivial_3.
Qed.
par_strict_irreflexivity
Proof.
    intros.
    intro.
    unfold Par_strict in H.
    spliter.
    apply H2.
    exists A.
    split; apply col_trivial_1.
Qed.
not_par_strict_id
Proof.
    intros.
    intro.
    unfold Par_strict in H.
    spliter.
    apply H2.
    exists A.
    split; Col.
Qed.
par_id
Proof.
    intros.
    unfold Par in H.
    induction H.
      unfold Par_strict in H.
      spliter.
      apply False_ind.
      apply H2.
      exists A.
      Col.
    spliter;Col.
Qed.
par_strict_not_col_1
Proof.
    intros.
    unfold Par_strict in *.
    spliter.
    intro.
    apply H2.
    exists C.
    split;Col.
Qed.
par_strict_not_col_2
Proof.
    intros.
    unfold Par_strict in *.
    spliter.
    intro.
    apply H2.
    exists B.
    split;Col.
Qed.
par_strict_not_col_3
Proof.
    intros.
    unfold Par_strict in *.
    spliter.
    intro.
    apply H2.
    exists A.
    split;Col.
Qed.
par_strict_not_col_4
Proof.
    intros.
    unfold Par_strict in *.
    spliter.
    intro.
    apply H2.
    exists D.
    split;Col.
Qed.
par_id_1
Proof.
    intros.
    assert (H1 := par_id A B C H).
    Col.
Qed.
par_id_2
Proof.
    intros.
    assert (H1 := par_id A B C H).
    Col.
Qed.
par_id_3
Proof.
    intros.
    assert (H1 := par_id A B C H).
    Col.
Qed.
par_id_4
Proof.
    intros.
    assert (H1 := par_id A B C H).
    Col.
Qed.
par_id_5
Proof.
    intros.
    assert (H1 := par_id A B C H).
    Col.
Qed.
par_strict_symmetry
Proof.
    unfold Par_strict.
    intros.
    spliter.
    repeat split.
      assumption.
      assumption.
      apply coplanar_perm_16;assumption.
    intro.
    apply H2.
    ex_and H3 X.
    exists X.
    split; assumption.
Qed.
par_symmetry
Proof.
    unfold Par.
    intros.
    induction H.
      left.
      apply par_strict_symmetry.
      assumption.
    spliter.
    right.
    repeat split;try assumption.
      eapply (col_transitivity_1 _ D);Col.
    eapply (col_transitivity_1 _ C);Col.
Qed.
par_left_comm
Proof.
    unfold Par.
    intros.
    induction H.
      left.
      unfold Par_strict in *.
      spliter.
      repeat split.
        auto.
        assumption.
        apply coplanar_perm_6;assumption.
      intro.
      apply H2.
      ex_and H3 X.
      exists X.
      Col5.
    right.
    spliter.
    Col5.
Qed.
par_right_comm
Proof.
    intros.
    apply par_symmetry in H.
    apply par_symmetry.
    apply par_left_comm.
    assumption.
Qed.
par_comm
Proof.
    intros.
    apply par_left_comm.
    apply par_right_comm.
    assumption.
Qed.
par_strict_left_comm
Proof.
    unfold Par_strict.
    intros.
    decompose [and] H;clear H.
    repeat split.
      intuition.
      assumption.
      apply coplanar_perm_6;assumption.
    intro.
    apply H4.
    destruct H as [X [HCol1 HCol2]].
    exists X; Col.
Qed.
par_strict_right_comm
Proof.
    unfold Par_strict.
    intros.
    decompose [and] H;clear H.
    repeat split.
      assumption.
      intuition.
      apply coplanar_perm_1;assumption.
    intro.
    apply H4.
    destruct H as [X [HCol1 HCol2]].
    exists X; Col.
Qed.
par_strict_comm
Proof.
    intros.
    apply par_strict_left_comm in H.
    apply par_strict_right_comm.
    assumption.
Qed.
par_strict_neq1
Proof. unfold Par_strict; intros; spliter; auto. Qed.
par_strict_neq2
Proof. unfold Par_strict; intros; spliter; auto. Qed.
par_neq1
Proof. unfold Par, Par_strict; intros; induction H; spliter; auto. Qed.
par_neq2
Proof. unfold Par, Par_strict; intros; induction H; spliter; auto. Qed.
Par_cases
Proof.
    intros.
    decompose [or]  H;Par.
Qed.
Par_perm
Proof.
    intros.
    do 7 (split; Par).
Qed.
Par_strict_cases
Proof.
    intros.
    decompose [or]  H; eauto with par.
Qed.
Par_strict_perm
Proof.
    intros.
    do 7 (split; Par).
Qed.
l12_6
Proof.
    intros.
    unfold Par_strict in H.
    spliter.
    assert(HH:= not_two_sides_one_side A B C D H).
    apply HH.
      intro.
      apply H2.
      exists C;Col.
      intro.
      apply H2.
      exists D;Col.
    intro.
    apply H2.
    unfold TS in H3.
    spliter.
    ex_and H5 T.
    exists T.
    eauto using bet_col with col.
Qed.
pars__os3412
Proof.
    intros.
    apply l12_6.
    apply par_strict_symmetry.
    assumption.
Qed.
Perp_dec
Proof.
    intros.
    induction (Col_dec A B C).
      induction (Perp_in_dec C A B C D).
        left.
        apply l8_14_2_1a with C;auto.
      right.
      intro.
      apply H0. clear H0.
      apply perp_in_right_comm.
      apply (l8_15_1 A B D C).
        apply perp_distinct in H1.
        intuition.
        assumption.
      apply perp_right_comm;assumption.
    elim (l8_18_existence A B C H); intros P HP.
    spliter.
    induction (eq_dec_points C D).
      subst.
      right.
      intro.
      assert (A <> B /\ D <> D) by (apply perp_distinct;assumption).
      intuition.
    induction (Col_dec P C D).
      left.
      assert (A <> B /\ C <> P) by (apply perp_distinct;assumption).
      spliter.
      apply perp_col1 with P;Col.
    right.
    intro.
    apply H3.
    apply col_permutation_2;apply perp_perp_col with A B;apply perp_sym;assumption.
Qed.
perp_perp_col_col
Proof.
    intros.
    assert(HH0:= H).
    assert(HH1:= H0).
    unfold Perp in HH0.
    unfold Perp in HH1.
    ex_and HH0 X0.
    ex_and HH1 Y0.
    induction(eq_dec_points X1 Y2).
      subst Y2.
      assert(Perp Y1 X1 A B).
        eapply perp_col.
          intro.
          treat_equalities.
          apply perp_distinct in H0.
          intuition.
          apply H0.
        Col.
      apply col_permutation_1.
      eapply perp_perp_col.
        apply H.
      apply perp_left_comm.
      assumption.
    assert(Perp Y2 X1 A B).
      eapply perp_col.
        auto.
        apply perp_left_comm.
        apply H0.
      Col.
    assert(Perp X1 Y2 A B).
      eapply perp_left_comm.
      assumption.
    induction(eq_dec_points X1 Y1).
      subst Y1.
      apply col_permutation_2.
      eapply perp_perp_col.
        apply H6.
      assumption.
    assert(Perp X1 Y1 A B).
      eauto using perp_left_comm, perp_col with col.
    induction (eq_dec_points X2 Y1).
      subst Y1.
      apply col_trivial_1.
    assert(Perp X2 Y1 A B).
      eauto using perp_col, perp_left_comm, perp_perp_col with col.
    (***************)
    induction (eq_dec_points X2 Y2).
      treat_equalities.
      Col.
    assert (Perp Y2 X2 A B) by (eauto using perp_col, perp_perp_col with col).
    eauto using perp_left_comm, perp_perp_col.
Qed.
l12_9
Proof.
    intros A1 A2 B1 B2 C1 C2.
    assert(H := all_coplanar A1 A2 B1 B2).
    intros.
    unfold Par.
    unfold Par_strict.
    assert(A1 <> A2 /\ C1 <> C2) by (apply perp_distinct;assumption).
    assert(B1 <> B2 /\ C1 <> C2) by (apply perp_distinct;assumption).
    spliter.
    induction(Col_dec A1 B1 B2).
      right.
      eauto using perp_perp_col_col.
    (***********************************)
    left.
    repeat split.
      assumption.
      assumption.
      apply all_coplanar.
    intro.
    ex_and H7 AB.
    apply H6.
    induction(eq_dec_points AB A1).
      subst AB.
      assumption.
    assert(Perp A1 AB C1 C2) by (eauto using perp_col with col).
    eauto using perp_perp_col_col, perp_left_comm.
Qed.
parallel_existence
Proof.
    intros.
    induction(Col_dec A B P).
      exists A.
      exists B.
      repeat split.
        assumption.
        Par.
      Col.
    assert(exists P', Col A B P' /\ Perp A B P P').
      eapply l8_18_existence.
      assumption.
    ex_and H1 P'.
    assert(P <> P').
      intro.
      subst P'.
      contradiction.
    induction(eq_dec_points P' A).
      subst P'.
      assert(exists Q, Per Q P A /\ Cong Q P A B /\ OS A P Q B).
        eapply ex_per_cong.
          auto.
          assumption.
          apply col_trivial_2.
        intro.
        apply H0.
        Col.
      ex_and H4 Q.
      exists P.
      exists Q.
      assert(P <> Q).
        intro.
        treat_equalities.
        intuition.
      repeat split.
        assumption.
        apply l12_9 with P A.
          apply H2.
        apply per_perp_in in H4.
          apply perp_in_perp_bis in H4.
          induction H4.
            apply perp_distinct in H4.
            spliter.
            absurde.
          apply perp_left_comm.
          assumption.
          auto.
        assumption.
      Col.
    assert(exists Q, Per Q P P' /\ Cong Q P A B /\ OS P' P Q A).
      eapply ex_per_cong.
        auto.
        assumption.
        Col.
      intro.
      apply H0.
      eapply (col_transitivity_1 _ P').
        auto.
        Col.
      Col.
    ex_and H5 Q.
    exists P.
    exists Q.
    assert(P <> Q).
      intro.
      treat_equalities.
      intuition.
    repeat split.
      assumption.
      apply l12_9 with P P'.
        apply H2.
      apply per_perp_in in H5.
        apply perp_in_perp_bis in H5.
        induction H5.
          apply perp_distinct in H5.
          spliter.
          absurde.
        apply perp_left_comm.
        assumption.
        auto.
      assumption.
    Col.
Qed.
par_col_par
Proof.
    intros.
    unfold Par in *.
    induction H0.
      left.
      unfold Par_strict in *.
      spliter.
      repeat split.
        assumption.
        assumption.
        apply all_coplanar.
      intro.
      apply H4.
      ex_and H5 P.
      exists P.
      split.
        assumption.
      apply col_permutation_2.
      eapply col_transitivity_1.
        apply H.
        Col.
      Col.
    right.
    spliter.
    repeat split.
      assumption.
      assumption.
      apply col_permutation_2.
      eapply col_transitivity_1.
        apply H2.
        assumption.
      Col.
    apply col_permutation_2.
    eapply col_transitivity_1.
      apply H2.
      assumption.
    Col.
Qed.
parallel_existence1
Proof.
    intros.
    assert (T:= parallel_existence A B P H).
    decompose [and ex] T;clear T.
    elim (eq_dec_points x P);intro.
      subst.
      exists x0.
      intuition.
    exists x.
    apply par_right_comm.
    apply par_col_par with x0; Par.
    Col.
Qed.
par_not_col
Proof.
    intros.
    unfold Par_strict in H.
    intro.
    spliter.
    apply H4.
    exists X; Col.
Qed.
not_strict_par1
Proof.
    intros.
    unfold Par in H.
    induction H.
      unfold Par_strict in H.
      spliter.
      assert(exists X, Col X A B /\ Col X C D).
        exists X.
        split; Col.
      contradiction.
    spliter.
    apply col_permutation_1.
    eapply col_transitivity_1.
      apply H2.
      Col.
    Col.
Qed.
not_strict_par2
Proof.
    intros.
    eapply not_strict_par1.
      apply par_right_comm.
      apply H.
      apply H0.
    Col.
Qed.
not_strict_par
Proof.
    intros.
    split.
      eapply not_strict_par1.
        apply H.
        apply H0.
      assumption.
    eapply not_strict_par2.
      apply H.
      apply H0.
    assumption.
Qed.
not_par_not_col
Proof.
    intros.
    intro.
    apply H1.
    unfold Par.
    right.
    repeat split.
      assumption.
      assumption.
      apply col_trivial_1.
    Col.
Qed.
not_par_inter_uniqueness
Proof.
    intros.
    induction(eq_dec_points C Y).
      subst Y.
      induction (eq_dec_points C X).
        subst X.
        reflexivity.
      eapply l6_21.
        2: apply H.
        2: apply H3.
        intro.
        apply H1.
        unfold Par.
        right.
        repeat split; assumption || ColR.
        assumption.
        assumption.
        assumption.
    eapply l6_21.
      2: apply H0.
      2: apply H2.
      intro.
      apply H1.
      unfold Par.
      right.
      repeat split; ColR || assumption.
      assumption.
      assumption.
      assumption.
Qed.
inter_uniqueness_not_par
Proof.
    intros.
    intro.
    unfold Par in H2.
    induction H2.
      unfold Par_strict in H2.
      spliter.
      apply H5.
      exists P.
      Col5.
    spliter.
    apply H.
    ColR.
Qed.
col_not_col_not_par
Proof.
    intros.
    ex_and H P.
    ex_and H0 Q.
    intro.
    unfold Par in H3.
    induction H3.
      unfold Par_strict in H3.
      spliter.
      apply H6.
      exists P.
      Col5.
    spliter.
    apply H2.
    eapply col3.
      apply H4.
      Col.
      Col.
    Col.
Qed.
par_distincts
Proof.
    intros.
    split.
      assumption.
    unfold Par in H.
    induction H.
      unfold Par_strict in H.
      spliter.
      split; assumption.
    spliter.
    split; assumption.
Qed.
par_not_col_strict
Proof.
    intros.
    apply par_symmetry in H.
    unfold Par in H.
    induction H.
      apply par_strict_symmetry.
      assumption.
    spliter.
    unfold Par_strict.
    repeat split; try assumption; try apply all_coplanar.
    intro.
    ex_and H5 X.
    apply H1.
    assert(Col A C D).
      eapply (col_transitivity_1 _ B).
        assumption.
        Col.
      Col.
    assert(Col B C D).
      eapply (col_transitivity_1 _ A).
        auto.
        Col.
      Col.
    eapply col3.
      apply H.
      Col.
      Col.
    Col.
Qed.
all_one_side_par_strict
Proof.
    intros.
    unfold Par_strict.
    repeat split.
      assert(HH:=H0 D (col_trivial_2 _ _)).
      unfold OS in HH.
      ex_and HH C0.
      unfold TS in H1.
      spliter.
        intro.
        subst B.
        Col.
      assumption.
      apply all_coplanar.
    intro.
    ex_and H1 X.
    assert(HH:= H0 X (col_permutation_1 _ _ _ H2) ).
    unfold OS in HH.
    ex_and HH M.
    unfold TS in H4.
    spliter.
    contradiction.
Qed.
par_col_par_2
Proof.
    intros.
    unfold Par in *.
    induction H1.
      left.
      unfold Par_strict in *.
      spliter.
      repeat split; auto; try apply all_coplanar.
      intro.
      ex_and H5 X.
      apply H4.
      exists X.
      split.
        ColR.
      Col.
    right.
    spliter.
    repeat split;auto.
    assert(Col A B D).
      ColR.
    assert(Col A B C).
      ColR.
    eapply col3.
      apply H1.
      Col.
      Col.
    Col.
Qed.
par_col2_par
Proof.
    intros.
    induction (eq_dec_points C E).
      subst E.
      eapply par_col_par.
        assumption.
        apply H0.
      assumption.
    eapply par_col_par.
      assumption.
      apply par_right_comm.
      eapply par_col_par.
        apply H3.
        apply H0.
      assumption.
    apply col_permutation_2.
    eapply col_transitivity_1.
      apply par_distincts in H0.
      spliter.
      apply H5.
      assumption.
    assumption.
Qed.
par_col2_par_bis
Proof.
intros.
apply par_col2_par with C D; Col; ColR.
Qed.
par_strict_col_par_strict
Proof.
    intros.
    assert(Par C E A B).
      eapply par_col_par_2.
        auto.
        apply H1.
      apply par_symmetry.
      left.
      assumption.
    induction H2.
      apply par_strict_symmetry.
      assumption.
    unfold Par_strict in H0.
    spliter.
    apply False_ind.
    apply H8.
    exists C.
    split; Col.
Qed.
par_strict_col2_par_strict
Proof.
    intros.
    unfold Par_strict in *.
    spliter.
    repeat split.
      assumption.
      assumption.
      apply all_coplanar.
    intro.
    apply H5.
    ex_and H6 X.
    exists X.
    split.
      assumption.
    assert(Col C E F).
      eapply col_transitivity_1.
        apply H3.
        assumption.
      assumption.
    assert(Col D E F).
      eapply (col_transitivity_1 _ C).
        auto.
        Col.
      Col.
    eapply col3.
      apply H.
      Col.
      Col.
    Col.
Qed.
line_dec
Proof.
    intros.
    induction (Col_dec C1 B1 B2); induction (Col_dec C2 B1 B2);tauto.
Qed.
par_distinct
Proof.
    intros.
    induction H.
      unfold Par_strict in H; intuition.
    intuition.
Qed.
par_col4__par
Proof.
    intros A B C D E F G H.
    intros.
    apply (par_col2_par _ _ C D); auto.
    apply par_symmetry.
    apply (par_col2_par _ _ A B); auto.
    apply par_symmetry; auto.
Qed.
par_strict_col4__par_strict
Proof.
    intros A B C D E F G H.
    intros.
    apply (par_strict_col2_par_strict _ _ C D); auto.
    apply par_strict_symmetry.
    apply (par_strict_col2_par_strict _ _ A B); auto.
    apply par_strict_symmetry; auto.
Qed.
par_strict_one_side
Proof.
  intros A B C D P HPar HCol.
  destruct (eq_dec_points C P).
    subst P; apply par_strict_not_col_1 in HPar; apply one_side_reflexivity; Col.
  apply l12_6, par_strict_col_par_strict with D; trivial.
Qed.
par_strict_all_one_side
Proof.
    intros.
    eapply par_strict_one_side.
      apply H.
    assumption.
Qed.
inter_trivial
Proof.
    intros.
    unfold Inter.
    split.
      exists B.
      split.
        Col.
      intro.
      apply H.
      Col.
    split; Col.
Qed.
inter_sym
Proof.
    intros.
    unfold Inter in *.
    spliter.
    ex_and H0 P.
    assert(A <> B).
      intro.
      subst B.
      apply H3.
      Col.
    split.
      induction(eq_dec_points A X).
        treat_equalities.
        exists B.
        split.
          Col.
        intro.
        apply H3.
        eapply col3.
          apply H.
          Col.
          Col.
        Col.
      exists A.
      split.
        Col.
      intro.
      apply H3.
      assert(Col A P X).
        eapply col3.
          apply H.
          Col.
          Col.
        Col.
      ColR.
    Col.
Qed.
inter_left_comm
Proof.
    intros.
    unfold Inter in *.
    spliter.
    ex_and H P.
    split.
      exists P.
      split.
        assumption.
      intro.
      apply H2.
      Col.
    split; Col.
Qed.
inter_right_comm
Proof.
    intros.
    unfold Inter in *.
    spliter.
    ex_and H P.
    split.
      exists P.
      split.
        Col.
      assumption.
    split; Col.
Qed.
inter_comm
Proof.
    intros.
    apply inter_left_comm.
    apply inter_right_comm.
    assumption.
Qed.
l12_17
Proof.
    intros.
    induction(Col_dec A B P).
      unfold Par.
      right.
      induction(eq_dec_points A P).
        subst P.
        apply is_midpoint_id in H0.
        subst C.
        repeat split.
          assumption.
          intro.
          treat_equalities.
          apply l7_2 in H1.
          apply is_midpoint_id in H1.
          contradiction.
          apply col_trivial_1.
        unfold Midpoint in H1.
        spliter.
        apply bet_col.
        assumption.
      induction(eq_dec_points B P).
        subst P.
        apply is_midpoint_id in H1.
        subst D.
        repeat split.
          assumption.
          intro.
          subst C.
          apply l7_2 in H0.
          apply is_midpoint_id in H0.
          auto.
          unfold Midpoint in H0.
          spliter.
          apply bet_col in H0 .
          Col.
        apply col_trivial_3.
      assert(HH0 := H0).
      assert(HH1:= H1).
      unfold Midpoint in H0.
      unfold Midpoint in H1.
      spliter.
      apply bet_col in H1.
      apply bet_col in H0.
      assert(Col B C P).
        eapply col_permutation_1.
        eapply (col_transitivity_1 _ A).
          auto.
          Col.
        Col.
      assert(Col B C D).
        eapply (col_transitivity_1 _ P).
          assumption.
          Col.
        Col.
      repeat split.
        assumption.
        intro.
        treat_equalities.
        intuition.
        induction(eq_dec_points A D).
          subst D.
          apply col_trivial_3.
        assert(Col C D P).
          eapply (col_transitivity_1 _ B).
            intro.
            subst C.
            assert(A = D).
              eapply symmetric_point_uniqueness.
                eapply l7_2.
                apply HH0.
              assumption.
            contradiction.
            Col.
          Col.
        induction(eq_dec_points C P).
          treat_equalities.
          intuition.
        apply col_permutation_2.
        eapply (col_transitivity_1 _ P).
          assumption.
          Col.
        Col.
      assumption.
    (* cas non degenere *)
    assert(exists E, Col A B E /\ Perp A B P E).
      eapply l8_18_existence.
      assumption.
    ex_and H3 E.
    assert(A <> P).
      intro.
      treat_equalities.
      apply H2.
      apply col_trivial_3.
    induction(eq_dec_points A E).
      treat_equalities.
      assert(Per P A B).
        eapply perp_in_per.
        apply perp_in_comm.
        eapply perp_perp_in.
        apply perp_sym.
        apply perp_comm.
        assumption.
      prolong B A B' B A.
      prolong B' P D' B' P.
      assert(Midpoint C D D').
        eapply symmetry_preserves_midpoint.
          apply H1.
          apply H0.
          split.
            apply H8.
          Cong.
        split.
          assumption.
        Cong.
      assert(Per P A B').
        eapply per_col.
          apply H.
          assumption.
        apply bet_col in H6.
        Col.
      ex_and H3 B''.
      assert(B' = B'').
        eapply symmetric_point_uniqueness.
          split.
            apply H6.
          Cong.
        assumption.
      subst B''.
      assert(Cong P D P D').
        apply  (cong_transitivity _ _ B P).
          unfold Midpoint in H1.
          spliter.
          Cong.
        apply  (cong_transitivity _ _ B' P).
          Cong.
        Cong.
      assert(Per P C D).
        unfold Per.
        exists D'.
        split; assumption.
      apply per_perp_in in H14.
        apply perp_in_perp_bis in H14.
        induction H14.
          apply perp_distinct in H14.
          intuition.
        eapply l12_9 with P A.
          apply H4.
        apply perp_sym.
        eapply perp_col.
          auto.
          apply H14.
        unfold Midpoint in H0.
        spliter.
        apply bet_col in H0.
        Col.
        intro.
        treat_equalities.
        apply l7_2 in H0.
        eapply is_midpoint_id in H0.
        auto.
      intro.
      subst D.
      assert(C = D').
        apply is_midpoint_id.
        assumption.
      subst D'.
      assert(A = B).
        eapply symmetric_point_uniqueness.
          apply l7_2.
          apply H0.
        apply l7_2.
        assumption.
      auto.
    prolong E P F E P.
    assert(Col C D F).
      eapply mid_preserves_col.
        2: apply H0.
        2:apply H1.
        apply H3.
      split.
        assumption.
      Cong.
    prolong A E A' A E.
    prolong A' P C' A' P.
    assert(Midpoint F C C').
      eapply symmetry_preserves_midpoint.
        apply H0.
        split.
          apply H7.
        Cong.
        split.
          apply H12.
        Cong.
      split.
        assumption.
      Cong.
    assert(Per P E A).
      eapply perp_in_per.
      apply perp_in_comm.
      apply perp_perp_in.
      apply perp_sym.
      eapply perp_col.
        assumption.
        apply perp_right_comm.
        apply H4.
      Col.
    assert(Cong P C P C').
      eapply (cong_transitivity _ _ P A).
        unfold Midpoint in H0.
        spliter.
        Cong.
      eapply (cong_transitivity _ _ P A').
        unfold Per in H15.
        ex_and H15 A''.
        assert( A' = A'').
          eapply symmetric_point_uniqueness.
            split.
              apply H10.
            Cong.
          assumption.
        subst A''.
        assumption.
      Cong.
    assert(Per P F C).
      unfold Per.
      exists C'.
      split.
        assumption.
      assumption.
    apply per_perp_in in H17.
      apply perp_in_comm in H17.
      apply perp_in_perp_bis in H17.
      induction H17.
        apply l12_9 with P E.
          apply H4.
        eapply perp_col.
          intro.
          subst D.
          assert (A = B).
            eapply symmetric_point_uniqueness.
              apply l7_2.
              apply H0.
            apply l7_2.
            assumption.
          auto.
          apply perp_sym.
          eapply perp_col.
            intro.
            treat_equalities.
            apply perp_distinct in H17.
            spliter.
            auto.
            apply perp_left_comm.
            apply H17.
          apply bet_col in H7.
          Col.
        Col.
      apply perp_distinct in H17.
      spliter.
      tauto.
      intro.
      treat_equalities.
      apply perp_distinct in H4.
      spliter.
      tauto.
    intro.
    subst C.
    assert(F = C').
      apply is_midpoint_id .
      assumption.
    treat_equalities.
    assert(A = E).
      eapply symmetric_point_uniqueness.
        apply l7_2.
        apply H0.
      split.
        apply between_symmetry.
        assumption.
      Cong.
    tauto.
Qed.
l12_18_a
Proof.
    intros.
    assert(Midpoint P A C /\ Midpoint P B D) by (apply l7_21; assumption).
    spliter.
    eapply l12_17.
      intro.
      subst B.
      apply H1.
      apply col_trivial_1.
      apply H5.
    apply H6.
Qed.
l12_18_b
Proof.
    intros.
    assert(Midpoint P A C /\ Midpoint P B D) by (apply l7_21; assumption).
    eapply l12_18_a.
      assumption.
      Cong.
      intro.
      apply H1.
      assert(Col B C P).
        eapply col_transitivity_1.
          apply H2.
          Col.
        Col.
      apply col_permutation_1.
      eapply (col_transitivity_1 _ P).
        intro.
        subst P.
        spliter.
        apply l7_2 in H5.
        apply is_midpoint_id in H5.
        subst C.
        apply H1.
        apply col_trivial_3.
        Col.
      Col.
      intro.
      subst C.
      apply H1.
      apply col_trivial_3.
      apply H4.
    Col.
Qed.
l12_18_c
Proof.
    intros.
    assert(Midpoint P A C /\ Midpoint P B D) by (apply l7_21; assumption).
    unfold TS.
    repeat split.
      intro.
      apply H1.
      assert(Col A B P).
        apply col_permutation_2.
        eapply (col_transitivity_1 _ D).
          assumption.
          Col.
        Col.
      eapply (col_transitivity_1 _ P).
        intro.
        subst P.
        spliter.
        apply is_midpoint_id in H5.
        subst C.
        apply H1.
        apply col_trivial_3.
        Col.
      Col.
      intro.
      apply H1.
      assert(Col B P C).
        eapply (col_transitivity_1 _ D).
          assumption.
          Col.
        Col.
      apply col_permutation_1.
      eapply (col_transitivity_1 _ P).
        intro.
        subst P.
        spliter.
        apply l7_2 in H5.
        apply is_midpoint_id in H5.
        subst C.
        apply H1.
        apply col_trivial_3.
        Col.
      Col.
    exists P.
    split.
      Col.
    spliter.
    unfold Midpoint in H5.
    tauto.
Qed.
l12_18_d
Proof.
    intros.
    assert(Midpoint P A C /\ Midpoint P B D) by (apply l7_21; assumption).
    eapply (l12_18_c _ _ _ _ P).
      Cong.
      Cong.
      intro.
      apply H1.
      assert(Col A B P).
        eapply col_permutation_2.
        eapply col_transitivity_1.
          apply H2.
          Col.
        Col.
      eapply (col_transitivity_1 _ P).
        intro.
        subst P.
        spliter.
        apply is_midpoint_id in H5.
        subst C.
        contradiction.
        Col.
      Col.
      intro.
      subst C.
      apply H1.
      apply col_trivial_3.
      Col.
    Col.
Qed.
l12_18
Proof.
    intros.
    split.
      apply (l12_18_a _ _ _ _ P); assumption.
    split.
      apply (l12_18_b _ _ _ _ P); assumption.
    split.
      apply (l12_18_c _ _ _ _ P); assumption.
    apply (l12_18_d _ _ _ _ P); assumption.
Qed.
par_two_sides_two_sides
Proof.
    intros.
    apply par_distincts in H.
    spliter.
    unfold Par in H.
    induction H.
      assert(A <> C).
        intro.
        subst C.
        unfold Par_strict in H.
        spliter.
        apply H5.
        exists A.
        split; apply col_trivial_1.
      unfold TS in *.
      assert (~ Col A B D).
        spliter.
        assumption.
      spliter.
      ex_and H6 T.
      repeat split.
        intro.
        assert(Col T B C).
          apply col_permutation_1.
          eapply (col_transitivity_1 _ A).
            auto.
            apply bet_col in H7.
            Col.
          Col.
        apply H5.
        apply col_permutation_2.
        eapply (col_transitivity_1 _ T).
          intro.
          treat_equalities.
          unfold Par_strict in H.
          spliter.
          apply H9.
          exists C.
          split.
            Col.
          apply col_trivial_1.
          Col.
        Col.
        intro.
        assert(Col T C D).
          apply col_permutation_2.
          apply (col_transitivity_1 _ A).
            auto.
            Col.
          apply bet_col in H7.
          Col.
        apply H5.
        apply col_permutation_1.
        apply (col_transitivity_1 _ T).
          intro.
          treat_equalities.
          unfold Par_strict in H.
          spliter.
          apply H9.
          exists A.
          split.
            apply col_trivial_1.
          Col.
          Col.
        Col.
      exists T.
      split.
        apply bet_col in H7.
        Col.
      unfold Col in H6.
      induction H6.
        assert(HH:= outer_pasch C D T A B (between_symmetry _ _ _ H7) (between_symmetry _ _ _ H6)).
        ex_and HH X.
        unfold Par_strict in H.
        spliter.
        apply False_ind.
        apply H12.
        exists X.
        apply bet_col in H8.
        apply bet_col in H9.
        split; Col.
      induction H6.
        assert(HH:= outer_pasch A B T C D H7 H6).
        ex_and HH X.
        apply False_ind.
        unfold Par_strict in H.
        spliter.
        apply H12.
        exists X.
        apply bet_col in H8.
        apply bet_col in H9.
        split; Col.
      apply between_symmetry.
      assumption.
    unfold TS in H0.
    spliter.
    apply False_ind.
    apply H3.
    apply col_permutation_1.
    eapply (col_transitivity_1 _ C).
      auto.
      Col.
    Col.
Qed.
par_one_or_two_sides
Proof.
    intros.
    induction(two_sides_dec A C B D).
      left.
      split.
        assumption.
      apply par_two_sides_two_sides.
        apply par_comm.
        unfold Par.
        left.
        assumption.
      assumption.
    right.
    assert(HH:=H).
    unfold Par_strict in H.
    spliter.
    assert(A <> C).
      intro.
      subst C.
      apply H3.
      exists A.
      split; Col.
    assert(B <> D).
      intro.
      subst D.
      apply H3.
      exists B.
      split; Col.
    split.
      apply not_two_sides_one_side.
        assumption.
        intro.
        apply H3.
        exists C.
        split; Col.
        intro.
        apply H3.
        exists A.
        split; Col.
      assumption.
    apply not_two_sides_one_side.
      assumption.
      intro.
      apply H3.
      exists D.
      split; Col.
      intro.
      apply H3.
      exists B.
      split; Col.
    intro.
    apply H0.
    apply par_two_sides_two_sides.
      left.
      assumption.
    assumption.
Qed.
l12_21_b
Proof.
    intros.
    apply conga_distinct in H0.
    spliter.
    assert(~Col A B C).
      intro.
      unfold TS in H.
      spliter.
      apply col_permutation_4 in H5.
      assert(Col D C A).
        eapply col_conga_col.
          apply H5.
        assumption.
      contradiction.
    assert(A <> B /\ C <> D).
      auto.
    spliter.
    assert(HH:=segment_construction_3 C D A B H7 H6).
    ex_and HH D'.
    assert(CongA B A C D' C A).
      eapply l11_10.
        apply H0.
        apply out_trivial.
        assumption.
        apply out_trivial.
        assumption.
        apply l6_6.
        assumption.
      apply out_trivial.
      assumption.
    assert(Cong D' A B C).
      eapply cong2_conga_cong.
        apply conga_sym.
        apply H10.
        Cong.
      Cong.
    assert(TS A C D' B).
      eapply l9_5.
        apply l9_2.
        apply H.
        apply col_trivial_3.
      assumption.
    unfold TS in H12.
    spliter.
    ex_and H14 M.
    assert(B <> D').
      intro.
      treat_equalities.
      contradiction.
    assert(Midpoint M A C /\ Midpoint M B D').
      apply l7_21.
        assumption.
        assumption.
        Cong.
        Cong.
        Col.
      apply bet_col in H15.
      Col.
    spliter.
    assert(Par A B C D').
      eapply l12_17.
        assumption.
        apply H17.
      assumption.
    eapply par_col_par.
      auto.
      apply H19.
    apply out_col in H8.
    Col.
Qed.
l12_22_aux
Proof.
    intros.
    assert (P<>C) by (intro; Between).
    prolong B A B' B A .
    spliter.
    assert(CongA P A B C A B').
      apply l11_14.
        assumption.
        assumption.
        auto.
        assumption.
        unfold CongA in H3.
        spliter.
        auto.
        intro.
        treat_equalities.
        unfold CongA in H3.
        tauto.
    assert(CongA D C A D C P).
      eapply l11_10.
        apply conga_refl.
          3: apply out_trivial.
          unfold CongA in H3.
          tauto.
        5:apply out_trivial.
        auto.
        unfold CongA in H3.
        tauto.
        apply between_symmetry in H1.
        apply bet_out in H1.
          assumption.
          auto.
          auto.
        apply out_trivial.
        unfold CongA in H3.
        tauto.
      auto.
    assert(Par A B' C D).
      eapply l12_21_b.
        assert(~Col B P A).
          unfold OS in H2.
          ex_and H2 T.
          unfold TS in H2.
          tauto.
        assert(TS P A B B').
          unfold TS.
          repeat split.
            assumption.
            intro.
            apply H9.
            apply col_permutation_1.
            eapply (col_transitivity_1 _ B').
              intro.
              treat_equalities.
              unfold CongA in H3.
              tauto.
              apply bet_col in H1.
              Col.
            Col.
          exists A.
          split.
            Col.
          assumption.
        apply l9_2.
        eapply l9_8_2.
          eapply col_two_sides.
            3:apply invert_two_sides.
            3: apply H10.
            apply bet_col in H1.
            Col.
          assumption.
        eapply col_one_side.
          3: apply invert_one_side.
          3: apply H2.
          apply bet_col in H1.
          Col.
        assumption.
      eapply conga_trans.
        apply conga_sym.
        apply conga_comm.
        apply H7.
      eapply conga_trans.
        apply H3.
      apply conga_sym.
      assumption.
    apply par_symmetry.
    eapply par_col_par.
      2: apply par_symmetry.
      2:apply H9.
      unfold CongA in H3.
      spliter.
      auto.
    apply bet_col in H1.
    Col.
Qed.
l12_22_b
Proof.
    intros.
    induction(eq_dec_points A C).
      subst C.
      unfold Par.
      right.
      repeat split.
        unfold CongA in H1.
        spliter.
        auto.
        unfold CongA in H1.
        spliter.
        auto.
        Col.
      apply conga_comm in H1.
      apply conga__or_out_ts in H1.
      induction H1.
        apply out_col in H1.
        Col.
      apply l9_9 in H1.
      contradiction.
    unfold Out in H.
    spliter.
    induction H4.
      eapply l12_22_aux.
        3:apply H4.
        auto.
        assumption.
        assumption.
      assumption.
    apply par_symmetry.
    eapply l12_22_aux.
      3:apply H4.
      auto.
      auto.
      eapply (col_one_side _ A).
        apply bet_col in H4.
        Col.
        auto.
      apply one_side_symmetry.
      assumption.
    apply conga_sym.
    assumption.
Qed.
par_strict_par
Proof.
    intros.
    unfold Par.
    tauto.
Qed.
par_strict_distinct
Proof.
    intros.
    apply par_strict_par in H.
    apply par_distincts.
    assumption.
Qed.
col_par
Proof.
    intros.
    unfold Par.
    right.
    intuition Col.
Qed.
acute_col_perp__out
Proof.
  intros A B C A' HacuteB HBCA' HPerp.
  assert(HUn := perp_not_col2 B C A A' HPerp).
  destruct HUn as [HNCol1|]; [|contradiction].
  assert(HB' := l10_15 B C B A).
  destruct HB' as [B' []]; Col.
  assert_diffs.
  assert(HNCol2 : ~ Col B' B C ) by (apply per_not_col; Perp).
  assert(HNCol3 : ~ Col B B' A).
  { intro.
    apply (nlta A B C).
    apply acute_per__lta; auto.
    apply (l8_3 B'); Col; Perp.
  }
  assert(HPars : Par_strict B B' A A').
    apply (par_not_col_strict _ _ _ _ A); Col; apply (l12_9 _ _ _ _ B C); Perp.
  assert(HNCol4 := par_strict_not_col_4 B B' A A' HPars).
  apply (col_one_side_out _ B'); Col.
  apply (one_side_transitivity _ _ _ A).
    apply l12_6; Par.
  apply invert_one_side.
  apply in_angle_one_side; Col.
  apply l11_24.
  apply lea_in_angle; Side.
  apply lta_comm.
  apply acute_per__lta; Perp.
Qed.
acute_col_perp__out_1
Proof.
  intros A B C A' HAcute HCol HPerp.
  destruct (segment_construction A B A B) as [A0 [HA1 HA2]].
  destruct (segment_construction C B C B) as [C0 [HC1 HC2]].
  assert_diffs.
  assert (HNCol : ~ Col B A A') by (apply per_not_col; Perp).
  assert_diffs.
  apply l6_2 with C0; auto.
  apply not_out_bet.
    ColR.
  intro.
  apply (not_bet_and_out A B A0); split; trivial.
  apply acute_col_perp__out with A'; Col.
    apply acute_sym, (acute_conga__acute A B C); auto.
    apply l11_14; auto.
    apply between_symmetry, l6_2 with C0; Between.
    apply l6_6; assumption.
  apply perp_col with A; Col; Perp.
Qed.
conga_inangle_per2__inangle
Proof.
  intros A B C P T HPer HInangle HConga HPerP.
  destruct (eq_dec_points P T).
    subst; apply HInangle.
  assert_diffs.
  destruct (angle_bisector A B C) as [P' [HInangle' HConga']]; auto.
  assert_diffs.
  assert (HAcute : Acute P' B A).
    apply acute_sym, conga_inangle_per__acute with C; trivial.
  apply l11_25 with P' A C; try (apply out_trivial); auto.
  assert (HNCol1 : ~ Col A B C) by (apply per_not_col; auto).
  assert (HCol : Col B P P').
    apply conga2__col with A C; trivial; intro; apply HNCol1; Col.
  apply (acute_col_perp__out T); Col.
  { apply acute_lea_acute with P' B A; trivial.
    assert (HNCol2 : ~ Col P' B A).
      intro.
      assert (Col P' B C) by (apply (col_conga_col P' B A); assumption).
      apply HNCol1; ColR.
    destruct (Col_dec T B P'); [|assert_diffs; destruct (one_or_two_sides B P' A T); Col].
    - apply l11_31_1; auto.
      apply col_one_side_out with A; Col.
      apply invert_one_side, inangle_one_side with C; Col.
      assert (~ Col B P T) by (apply per_not_col; auto).
      intro; assert_diffs; apply HNCol2; ColR.
    - apply (l11_30 P' B T P' B C); CongA.
      exists T; split; CongA.
      apply l11_24 in HInangle; apply l11_24 in HInangle'.
      destruct (Col_dec B C T).
        apply out341__inangle; auto.
        apply col_in_angle_out with A; Col.
        intro; apply HNCol1; Col.
      assert (HNCol3 : ~ Col P' B C) by (apply (ncol_conga_ncol P' B A); assumption).
      apply os2__inangle.
        exists A; split; Side.
        apply invert_two_sides, in_angle_two_sides; Col.
      apply invert_one_side, inangle_one_side with A; Col.
    - exists T; split; CongA.
      destruct (Col_dec B A T).
        apply out341__inangle; auto.
        apply col_in_angle_out with C; Col.
        intro; apply HNCol1; Col.
      apply os2__inangle; trivial.
      apply invert_one_side, inangle_one_side with C; Col.
  }
  apply perp_col with P; Col.
  apply perp_right_comm, per_perp; auto.
Qed.
perp_not_par
Proof.
    intros.
    assert(HH:=H).
    unfold Perp in HH.
    ex_and HH P.
    intro.
    induction H1.
      apply H1.
      exists P.
      apply perp_in_col in H0.
      spliter.
      split; Col.
    spliter.
    induction(eq_dec_points A Y).
      subst Y.
      assert(P = A).
        eapply (l8_14_2_1b P A B X A); Col.
      subst P.
      apply perp_in_comm in H0.
      apply perp_in_per in H0.
      assert(~ Col B A X).
        eapply(per_not_col).
          auto.
          auto.
        assumption.
      apply H5.
      Col.
    apply(l8_16_1 A B X A Y); Col.
      ColR.
    ColR.
Qed.
cong_conga_perp
Proof.
    intros.
    assert(HH:=H).
    unfold TS in HH.
    assert (~ Col A B P).
      spliter.
      assumption.
    spliter.
    ex_and H5 T.
    assert(B <> P).
      intro.
      subst P.
      apply H3.
      Col.
    assert(A <> B).
      intro.
      subst B.
      apply H3.
      Col.
    assert(C <> B).
      intro.
      subst C.
      apply H4.
      Col.
    assert(A <> C).
      intro.
      subst C.
      assert(OS B P A A).
        apply one_side_reflexivity.
        assumption.
      apply l9_9 in H.
      contradiction.
    induction (bet_dec A B C).
      assert(Per P B A).
        apply(l11_18_2 P B A C); auto.
        apply conga_comm.
        assumption.
      eapply (col_per_perp _ _ _ C) in H12; auto.
        apply perp_right_comm.
        assumption.
      apply bet_col in H11.
      Col.
    assert(B <> T).
      intro.
      subst T.
      contradiction.
    assert(CongA T B A T B C).
      induction H5.
        eapply (l11_13 P _ _ P); Between.
        apply conga_comm.
        apply H1.
      assert(Out B P T).
        repeat split; auto.
        induction H5.
          left.
          Between.
        right.
        Between.
      apply conga_comm.
      eapply (out_conga A _ P C _ P); auto.
        apply out_trivial.
        auto.
      apply out_trivial.
      auto.
    assert(Cong T A T C).
      apply (cong2_conga_cong T B A T B C); Cong.
    assert(Midpoint T A C).
      split; Cong.
    assert(Per B T A).
      unfold Per.
      exists C.
      split; Cong.
    eapply (col_per_perp _ _ _ C) in H16; auto.
      apply perp_sym.
      apply (perp_col _ T); Col.
      Perp.
      intro.
      subst T.
      apply is_midpoint_id in H15.
      contradiction.
      intro.
      subst T.
      apply l7_2 in H15.
      apply is_midpoint_id in H15.
      apply H10.
      auto.
    apply bet_col in H6.
    Col.
Qed.
perp_inter_exists
Proof.
    intros A B C D HPerp.
    destruct HPerp as [P [_ [_ [HCol1 [HCol2]]]]].
    exists P; split; Col.
Qed.
perp_inter_perp_in
Proof.
    intros.
    assert(HH:=perp_inter_exists A B C D H).
    ex_and HH P.
    exists P.
    split.
      Col.
    split.
      Col.
    apply l8_14_2_1b_bis; Col.
Qed.
tarski_s_euclid
Proof.
unfold tarski_s_parallel_postulate.
apply euclid.
Qed.
inter_dec
Proof.
apply strong_parallel_postulate_implies_inter_dec.
apply strong_parallel_postulate_SPP.
cut tarski_s_parallel_postulate.
apply equivalent_postulates_without_decidability_of_intersection_of_lines_bis; simpl; tauto.
apply tarski_s_euclid.
Qed.
not_par_inter_exists
Proof.
    intros.
induction (eq_dec_points A1 B1).
subst; exists A2; Col.
induction (eq_dec_points A2 B2).
subst; exists A1; Col.
induction (inter_dec A1 B1 A2 B2).

  assumption.

  exfalso.
  apply H.
  unfold Par.
  left.
  unfold Par_strict.
  repeat split; try apply all_coplanar; assumption.
Qed.
parallel_uniqueness
Proof.
    intros.
    apply tarski_s_euclid_implies_playfair with A1 A2 P; try assumption.
    apply tarski_s_euclid.
Qed.
par_trans
Proof.
    intros.
    apply playfair_implies_par_trans with B1 B2; try assumption.
    unfold playfair_s_postulate.
    apply parallel_uniqueness.
Qed.
l12_16
Proof.
    intros.
    assert(HH:= H).
    unfold Par in H.
    induction H.
      unfold Inter in H0.
      spliter.
      ex_and H0 P.
      assert(HNCol : ~Col B1 B2 X) by (intro; unfold Par_strict in H; spliter; apply H7; exists X; Col).
      assert(HH1 := l8_18_existence B1 B2 X HNCol).
      ex_and HH1 X0.
      assert(HPar : ~Par B1 B2 C1 C2).
        intro.
        assert(Par A1 A2 C1 C2) by (apply par_trans with B1 B2; assumption).
        assert(~Par A1 A2 C1 C2).
          apply col_not_col_not_par.
            exists X; Col.
          exists P; Col.
        contradiction.
      apply not_par_inter_exists in HPar.
      ex_and HPar Y.
      exists Y.
      split; try Col.
      exists X.
      split.
        Col.
      intro.
      apply HNCol; Col.
    unfold Inter in H0.
    spliter.
    ex_and H0 P.
    exists X.
    split.
      exists P.
      split.
        Col.
      intro.
      apply H6.
      apply (col3 B1 B2); Col.
    split; try Col.
    apply par_symmetry in HH.
    unfold Par in HH.
    induction HH.
      unfold Par_strict in H7.
      spliter.
      apply False_ind.
      apply H10.
      exists A1.
      split; try Col.
    spliter.
    apply (col3 A1 A2); Col.
Qed.
Par_dec
Proof. exact (par_trans__par_dec par_trans). Qed.
par_not_par
Proof.
intros A B C D P Q HPar HNPar.
intro HNPar'.
apply HNPar.
apply par_trans with C D; Par.
Qed.
par_inter
Proof.
    intros A B C D P Q X HPar HNPar HCol1 HCol2.
    elim (eq_dec_points P Q); intro HDiff; treat_equalities.

      {
      exists C; Col.
      }

      {
      elim (Col_dec A B P); intro HNC1; elim (Col_dec A B Q); intro HNC2.

        {
        apply par_distincts in HPar; spliter.
        exfalso; apply HNPar; right; repeat (split; Col; try ColR).
        }

        {
        assert (HY : exists Y : Tpoint, Col X Q Y /\ Col C D Y).
          {
          assert (~ Par A B X Q)
            by (apply col_not_col_not_par; [exists P; Col | exists Q; Col]).
          assert(~ Par C D X Q) by (apply par_not_par with A B; Par).
          destruct (not_par_inter_exists X Q C D) as [Y HY]; Par.
          exists Y; spliter; Col.
          }
        show_distinct Q X; Col.
        destruct HY as [Y [HCol3 HCol4]]; exists Y; split; ColR.
        }

        {
        assert (HY : exists Y : Tpoint, Col X P Y /\ Col C D Y).
          {
          assert (~ Par A B X P)
            by (apply col_not_col_not_par; [exists Q; Col | exists P; Col]).
          assert(~ Par C D X P) by (apply par_not_par with A B; Par).
          destruct (not_par_inter_exists X P C D) as [Y HY]; Par.
          exists Y; spliter; Col.
          }
        show_distinct P X; Col.
        destruct HY as [Y [HCol3 HCol4]]; exists Y; split; ColR.
        }

        {
        assert (HY : exists Y : Tpoint, Col X Q Y /\ Col C D Y).
          {
          assert (~ Par A B X Q)
            by (apply col_not_col_not_par; [exists X; Col | exists Q; Col]).
          assert(~ Par C D X Q) by (apply par_not_par with A B; Par).
          destruct (not_par_inter_exists X Q C D) as [Y HY]; Par.
          exists Y; spliter; Col.
          }
        show_distinct Q X; Col.
        destruct HY as [Y [HCol3 HCol4]]; exists Y; split; ColR.
        }
      }
Qed.
l12_19
Proof.
    intros.
    assert(exists P, Midpoint P A C) by (eapply midpoint_existence).
    ex_and H2 P.
    double B P D'.
    assert(Cong C D' A B).
      apply (l7_13 P); assumption.
    assert(Cong B C D' A).
      apply (l7_13 P); Midpoint.
    assert(Par A B C D').
      assert_diffs; apply l12_17 with P; auto.
    assert(Par C D C D').
      eapply par_trans.
        apply par_symmetry.
        apply H0.
      apply H6.
    assert(Col C D D').
      apply par_id.
      assumption.
    assert(Par B C D' A).
      assert_diffs; apply l12_17 with P; Midpoint.
    assert(Par D A D' A).
      eapply par_trans.
        apply par_symmetry.
        apply H1.
      assumption.
    assert(Col A D D').
      apply par_id.
      Par.
    assert(D = D').
      assert_diffs; apply (l6_21 A D C D); Col.
        intro.
        apply H.
        assert(Col P C D).
          apply col_permutation_2.
          apply (col_transitivity_1 _ A); Col.
        assert(Col P C D').
          apply col_permutation_2.
          apply (col_transitivity_1 _ D); Col.
        assert(Col P A D').
          apply (col_transitivity_1 _ C); Col.
        apply (col3 P D'); Col.
        intro; treat_equalities; assert_cols; Col.
    subst D'.
    split.
      Cong.
    split.
      Cong.
    assert(B <> D).
      intro; treat_equalities; assert_cols; Col.
    split.
      apply l12_18_c with P; Cong; Col.
    apply l12_18_d with P; Cong; Col.
Qed.
l12_20_bis
Proof.
    intros.
    assert(B <> C) by (assert_diffs; auto).
    assert(A <> D) by (assert_diffs; auto).
    assert(~ Col A B C).
      intro.
      assert(Col A B D).
        apply not_strict_par1 with C C; Col; Par.
      unfold TS in H1.
      spliter.
      contradiction.
    assert(exists P, Midpoint P A C) by (apply midpoint_existence).
    ex_and H5 P.
    double B P D'.
    assert(Par B C D' A).
      eapply l12_17.
        assumption.
        apply H5.
      apply l7_2.
      assumption.
    assert(Par A B C D').
      assert_diffs; apply l12_17 with P; auto.
    assert(Cong C D' A B).
      apply (l7_13 P); assumption.
    assert(Cong B C D' A).
      apply (l7_13 P); Midpoint.
    assert(Par C D C D').
      eapply par_trans.
        apply par_symmetry.
        apply H.
      assumption.
    assert(Col C D D').
      apply par_id; assumption.
    assert(Cong C D C D').
      apply (cong_transitivity _ _ A B); Cong.
    assert(D = D' \/ Midpoint C D D').
      apply l7_20; Col.
    induction H14.
    { subst D'.
      assert(Par B C D A) by Par.
      split.
        assumption.
      assert(HH:=l12_19 A B C D H4 H H14).
      spliter.
      split; assumption.
    }
    (************)
    exfalso.
    assert(TS A C B D).
      apply par_two_sides_two_sides; assumption.
    assert(~ Col A C D).
      apply (par_not_col A B C D A); Col.
      apply par_not_col_strict with C; Col.
    assert(~ Col D' A C).
      intro.
      apply H16.
      ColR.
    assert(TS A C B D').
      repeat split; Col.
      exists P.
      split.
        Col.
      Between.
    assert (TS A C D D').
      repeat split; Col.
      exists C.
      split.
        Col.
      Between.
    apply (l9_9 A C B D).
      assumption.
    apply l9_8_1 with D'; assumption.
Qed.
l12_20
Proof.
    intros.
    assert(TS B D A C).
      apply par_two_sides_two_sides.
        apply par_comm.
        assumption.
      assumption.
    assert(HH:=l12_20_bis A B C D H H0 H2).
    spliter.
    split.
      assumption.
    split.
      assumption.
    assumption.
Qed.
l12_21_a
Proof.
    assert (aia : alternate_interior_angles_postulate).
    { cut tarski_s_parallel_postulate.
        apply stronger_postulates; simpl; tauto.
      apply tarski_s_euclid.
    }
    apply aia.
Qed.
l12_21
Proof.
    intros.
    split.
      intro.
      apply l12_21_b ; assumption.
    intro.
    apply l12_21_a; assumption.
Qed.
l12_22_a
Proof.
    cut (forall A B C D P,
         A <> P -> Bet P A C -> OS P A B D -> Par A B C D ->
         CongA B A P D C P).
    { intros Haux A B C D P HOut HOS HPar.
      destruct HOut as [HAP [HCP [|]]].
        apply Haux; trivial.
      apply conga_sym, Haux; Par.
      apply col_one_side with A; Col; Side.
    }
    intros A B C D P HAP HBet HOS HPar.
    destruct (eq_dec_points A C).
    { subst C.
      apply out2__conga; [|apply out_trivial; auto].
      apply col_one_side_out with P; Side.
      apply par_id; Par.
    }
    destruct (segment_construction B A B A) as [B' []].
    assert_diffs.
    apply conga_trans with B' A C.
      apply l11_14; auto.
    apply l11_10 with B' C D A; try (apply out_trivial); auto; [|apply l6_6, bet_out; Between].
    apply l12_21_a; [|apply par_col_par_2 with B; Col].
    apply l9_2, l9_8_2 with B; [|apply col_one_side with P; Side; Col].
    assert (HNCol : ~ Col P A B) by (apply one_side_not_col123 with D, HOS).
    assert (HNCol1 : ~ Col B A C) by (intro; apply HNCol; ColR).
    repeat split; trivial.
      intro; apply HNCol1; ColR.
    exists A; Col.
Qed.
l12_22
Proof.
    intros.
    split; intro.
      eapply (l12_22_b _ _ _ _ P); assumption.
    apply l12_22_a; assumption.
Qed.
l12_23
Proof.
    intros.
    assert(exists B0, Midpoint B0 A B) by (apply midpoint_existence).
    assert(exists C0, Midpoint C0 A C) by (apply midpoint_existence).
    ex_and H0 B0.
    ex_and H1 C0.
    prolong B C0 B' B C0.
    prolong C B0 C' C B0.
    exists B'.
    exists C'.
    assert(TS A C B B').
      apply mid_two_sides with C0; Col.
      split.
        assumption.
      Cong.
    assert(TS A B C C').
      eapply mid_two_sides with B0; Col.
      split.
        assumption.
      Cong.
    split.
      assumption.
    split.
      assumption.
    assert(Par A B' C B).
      eapply l12_17.
        intro.
        treat_equalities.
        assert(C0 = B0).
          eapply l7_17.
            2: apply H2.
          split.
            apply between_symmetry.
            assumption.
          Cong.
        treat_equalities.
        Col.
        apply H0.
      split.
        apply between_symmetry.
        assumption.
      Cong.
    assert(Par A C' B C).
      eapply l12_17.
        intro.
        treat_equalities.
        assert(C0 = B0).
          eapply l7_17.
            apply H0.
          split.
            apply between_symmetry.
            assumption.
          Cong.
        treat_equalities.
        Col.
        apply H2.
      split.
        apply between_symmetry.
        assumption.
      Cong.
    assert(Par A B' A C').
      eapply par_trans.
        apply H8.
      apply par_symmetry.
      apply par_right_comm.
      assumption.
    apply par_id in H10.
    assert(OS A C B0 C').
      eapply out_one_side_1.
        intro.
        apply H.
        assert_diffs.
        eapply (col_transitivity_1 _ B0); Col.
        apply col_trivial_2.
      apply bet_out.
        intro.
        treat_equalities.
        assert_diffs; auto.
      assumption.
    assert(OS A C B0 B).
      eapply out_one_side_1.
        intro.
        apply H.
        eapply (col_transitivity_1 _ B0); Col.
          intro.
          treat_equalities.
          Col.
        apply col_trivial_3.
      assert_diffs; apply bet_out; Between.
    assert(OS A C B C').
      eapply one_side_transitivity.
        2:apply H11.
      apply one_side_symmetry.
      assumption.
    assert(TS A C B' C').
      apply l9_2.
      eapply l9_8_2.
        apply H6.
      assumption.
    split.
      apply col_two_sides_bet with C; assumption.
    split.
      apply l9_2 in H7.
      assert(HH:= l12_21_a A C' B C H7 H9); CongA.
    apply par_symmetry in H8.
    apply invert_two_sides in H6.
    assert(HH:= l12_21_a C B A B' H6 H8); CongA.
Qed.
not_par_strict_inter_exists
Proof.
    intros.
    induction (eq_dec_points A1 B1).
      subst.
      exists A2.
      Col.
    induction (eq_dec_points A2 B2).
      subst.
      exists A1.
      Col.
    induction (inter_dec A1 B1 A2 B2).
      assumption.
    unfold Par_strict in H.
    exfalso.
    apply H.
    repeat split; try assumption; try apply all_coplanar.
Qed.
not_par_inter
Proof.
    intros.
    induction(Par_dec A B X Y).
      assert(~ Par A' B' X Y).
        intro.
        apply H.
        apply(par_trans _ _ X Y); Par.
      assert(HH:=not_par_inter_exists A' B' X Y H1).
      ex_and HH P.
      exists P.
      split.
        Col.
      right.
      Col.
    assert(HH:=not_par_inter_exists A B X Y H0).
    ex_and HH P.
    exists P.
    split.
      Col.
    left.
    Col.
Qed.
not_par_one_not_par
Proof.
    intros.
    assert(HH:=not_par_inter A B A' B' X Y H).
    ex_and HH P.
    induction(Par_dec A B X Y).
      right.
      intro.
      apply H.
      apply(par_trans _ _ X Y); Par.
    left.
    auto.
Qed.
col_par_par_col
Proof.
    intros.
    apply par_distincts in H0.
    apply par_distincts in H1.
    spliter.
    assert(Par A B B C).
      right.
      repeat split; Col.
    assert(Par A' B' B' C').
      apply (par_trans _ _ A' B').
        Par.
      apply (par_trans _ _ B C).
        apply (par_trans _ _ A B); Par.
      Par.
    induction H7.
      apply False_ind.
      apply H7.
      exists B'.
      split; Col.
    spliter.
    Col.
Qed.
trisuma__bet
Proof.
    apply alternate_interior__triangle.
    unfold alternate_interior_angles_postulate.
    apply l12_21_a.
Qed.
bet__trisuma
Proof.
    intros A B C D E F HBet; intros.
    destruct (ex_trisuma A B C) as [P [Q [R HTri]]]; auto.
    apply conga_trisuma__trisuma with P Q R; trivial.
    assert (Hd := HTri).
    apply trisuma_distincts in Hd; spliter.
    apply conga_line; auto.
    apply (trisuma__bet A B C); trivial.
Qed.
not_obtuse
Proof.
    apply not_oah.
    right.
    assert (Hr : postulate_of_right_saccheri_quadrilaterals); [|apply Hr].
    cut alternate_interior_angles_postulate.
      apply stronger_postulates_bis; simpl; tauto.
    unfold alternate_interior_angles_postulate; apply l12_21_a.
Qed.
suma__sams
Proof. exact (t22_20 not_obtuse). Qed.
per2_col_eq
Proof.
intros.
induction(eq_dec_points P B).
subst B.
assert( A = P' \/ P = P').
apply(l8_9 A P' P H2); Col.
induction H4.
contradiction.
assumption.
induction(eq_dec_points P' B).
subst B.
assert(A = P \/ P' = P).
apply(l8_9 A P P' H1); Col.
induction H5; auto.
contradiction.

apply per_perp_in in H1; auto.
apply per_perp_in in H2; auto.

apply perp_in_comm in H1.
apply perp_in_comm in H2.
apply perp_in_perp_bis in H1.
apply perp_in_perp_bis in H2.
induction H1; induction H2.
apply(l8_18_uniqueness P A B P P'); Col.
apply perp_not_col; auto.
apply perp_left_comm.
apply(perp_col A P' B P' P); Perp.
Col.
apply perp_distinct in H2.
tauto.
apply perp_distinct in H1.
tauto.
apply perp_distinct in H1.
tauto.
Qed.
per_distinct
Proof.
intros.
intro.
subst C.
apply H0.
apply (l8_8).
assumption.
Qed.
per2_preserves_diff
Proof.
intros.
intro.
subst B.
apply H4.
apply(per2_col_eq O A' B' A);Col.
Qed.
per23_preserves_bet
Proof.
intros.
assert(HC:Col A B C).
apply bet_col in H; Col.

induction(eq_dec_points B B').
subst B'.

assert(Col A C' C).
ColR.

assert(A = C' \/ C = C').
apply l8_9; auto.
induction H6.
contradiction.
subst C'.
assumption.

assert(A <> C).
intro.
subst C.
apply l8_8 in H4.
contradiction.

assert(C <> C').
intro.
subst C'.

assert(Col A B' B).
ColR.

assert(A = B' \/ B = B').
apply l8_9; auto.
induction H8; contradiction.

assert(Perp A B' B' B).
apply per_perp_in in H3; auto.
apply perp_in_comm in H3.
apply perp_in_perp_bis in H3.
induction H3; Perp.
apply perp_distinct in H3.
tauto.

assert(Perp A C' C' C).
apply per_perp_in in H4; auto.
apply perp_in_comm in H4.
apply perp_in_perp_bis in H4.
induction H4; Perp.
apply perp_distinct in H4.
tauto.

assert(Par B B' C C').
apply(l12_9 B B' C C' A B');Perp.
apply perp_sym.
apply(perp_col _ C'); Perp.
ColR.

induction(eq_dec_points B C).
subst C.
assert(B' = C').
apply(per2_col_eq A B' C' B); Perp.
Col.
subst C'.
Between.

assert(~Col A B' B).
apply per_not_col in H3; auto.

assert(~Col A C' C).
apply per_not_col in H4; auto.

assert(B' <> C').
intro.
subst C'.
clean_trivial_hyps.

assert(Col B C B').
apply(per_per_col B C A B'); Perp.
apply H13; ColR.

induction H10.
apply l12_6 in H10.

assert(TS B B' A C).
repeat split;auto.
intro.
assert(A = B' \/ B = B').
apply l8_9; Col.
induction H12; tauto.
intro.
apply H13; ColR.
exists B.
split; Col.

assert(TS B B' A C').
apply l9_2.
apply(l9_8_2 B B' C C' A); auto.
apply l9_2.
assumption.
unfold TS in H16.
spliter.
ex_and H18 T.
assert(T = B').
apply bet_col in H19.
apply (l6_21 B B' A B'); Col.
ColR.
subst T.
assumption.
spliter.
apply False_ind.
apply H12.
ColR.
Qed.
per23_preserves_bet_inv
Proof.
intros.

induction(eq_dec_points B B').
subst B'.
assert(Col A C' C).
apply bet_col in H.
ColR.
assert(A = C' \/ C = C').
apply(l8_9 A C' C); auto.
induction H5.
subst C'.
apply between_identity in H.
contradiction.
subst C'.
assumption.

assert(Perp A B' B' B).
apply per_perp_in in H2.
apply perp_in_comm in H2.
apply perp_in_perp_bis in H2.
induction H2.
Perp.
apply perp_distinct in H2.
tauto.
auto.
auto.


assert(Perp A C' C' C).
apply per_perp_in in H3.
apply perp_in_comm in H3.
apply perp_in_perp_bis in H3.
induction H3.
Perp.
apply perp_distinct in H3.
tauto.
intro.
subst C'.
apply between_identity in H.
contradiction.
intro.
subst C'.
induction(eq_dec_points A C).
subst C.
apply between_identity in H.
contradiction.
assert(Col A B' B).
apply bet_col in H.
ColR.
assert(A = B' \/ B = B').
apply(l8_9 A B' B); auto.
induction H8;contradiction.

assert(Perp A B' C' C).
apply bet_col in H.
apply(perp_col _ C'); Col.

assert( Par B' B C' C).
apply(l12_9 B' B C' C A B').
Perp.
Perp.

induction(eq_dec_points B C).
subst C.
Between.

induction H8.
assert(B' <> C').
intro.
subst C'.
apply H8.
exists B'.
split; Col.


assert(HH:=l12_6 B' B C' C H8).

assert(TS B' B A C').
repeat split; auto.
intro.
assert(A = B' \/ B = B').
apply(l8_9 A B' B); auto.
induction H12;contradiction.
intro.
assert(Col A B' B).
assert_cols.
ColR.
assert(A = B' \/ B = B').
apply(l8_9 A B' B); auto.
induction H13;contradiction.
exists B'.
split; Col.

assert(TS B' B C A).
apply(l9_8_2 B' B C' C A); auto.
apply l9_2.
assumption.
unfold TS in H12.
spliter.
ex_and H14 T.

assert(A <> C).
intro.
subst C.
apply between_identity in H15.
subst T.
contradiction.

assert (T = B).
assert_cols.
apply (l6_21 A C B' B); Col.
intro.
assert(Col A B' B).
ColR.
assert(A = B' \/ B = B').
apply(l8_9 A B' B); auto.
induction H21;contradiction.
subst T.
Between.


spliter.
assert_cols.
assert(Col A B' B).
ColR.
assert(A = B' \/ B = B').
apply(l8_9 A B' B); auto.
induction H15;contradiction.
Qed.
per13_preserves_bet
Proof.
intros.
assert(Col A B C).
apply bet_col in H.
Col.

induction(eq_dec_points A A').
subst A'.
assert(Col B C' C).
ColR.

assert(B = C' \/ C = C').
apply l8_9; auto.
induction H7.
contradiction.
subst C'.
assumption.

assert(C <> C').
intro.
subst C'.
assert(Col A A' B).
ColR.
assert(B = A' \/ A = A').
apply l8_9; Col.
induction H8; tauto.

assert(Perp B A' A' A).
apply per_perp_in in H3; auto.
apply perp_in_comm in H3.
apply perp_in_perp_bis in H3.
induction H3.
Perp.
apply perp_distinct in H3.
tauto.

assert(Perp B C' C' C).
apply per_perp_in in H4; auto.
apply perp_in_comm in H4.
apply perp_in_perp_bis in H4.
induction H4.
Perp.
apply perp_distinct in H4.
tauto.

assert(Par A A' C C').
apply(l12_9 A A' C C' B A');Perp.
apply perp_sym.
apply(perp_col _ C'); Perp.
ColR.

induction H10.
assert(HH:=par_strict_symmetry A A' C C' H10).
apply l12_6 in H10.
apply l12_6 in HH.

assert(~Col A A' B).
apply per_not_col in H3; auto.
intro.
apply H3.
Col.

assert(~Col C C' B).
apply per_not_col in H4; auto.
intro.
apply H4.
Col.

assert(OS A A' B C).
apply out_one_side.
left; auto.
repeat split.
intro.
subst A.
unfold OS in H10.
ex_and H10 X.
unfold TS in H13.
spliter.
apply H13.
Col.
intro.
subst C.
unfold OS in H10.
ex_and H10 X.
unfold TS in H10.
spliter.
apply H10.
Col.
left.
assumption.

assert(OS C C' B A).
apply out_one_side.
left; auto.
repeat split.
intro.
subst C.
apply H12.
Col.
intro.
subst C.
unfold OS in H10.
ex_and H10 X.
unfold TS in H10.
spliter.
apply H10.
Col.
left.
Between.

assert(OS A A' B C').
apply(one_side_transitivity _ _ _ C); auto.
assert(OS C C' B A').
apply(one_side_transitivity _ _ _ A); auto.

apply invert_one_side in H15.
apply invert_one_side in H16.
assert(HP:= col_one_side_out A' A B C' H2 H15).
assert(Out C' B A').
apply(col_one_side_out C' C B A'); Col.

unfold Out in *.
spliter.

induction H19.
Between.
induction H22.
Between.
apply False_ind.
apply H18.
apply (between_equality _ _ B); Between.
spliter.

induction(eq_dec_points A C).
subst C.
apply between_identity in H.
subst B.
clean_duplicated_hyps.
clean_trivial_hyps.
apply l8_8 in H4.
contradiction.
assert(Col B C' C).
ColR.
apply per_not_col in H4; auto.
contradiction.
Qed.
per13_preserves_bet_inv
Proof.
intros.
assert(Col A' B C').
apply bet_col in H.
Col.

induction(eq_dec_points A A').
subst A'.
assert(Col B C' C).
ColR.
assert(HH:=l8_9 B C' C H4 H6 ).
induction HH.
contradiction.
subst C'.
assumption.

assert(C <> C').
intro.
subst C'.
assert(Col B A' A).
ColR.
assert(HH:=l8_9 B A' A H3 H7).
induction HH;
contradiction.

assert(Perp B A' A' A).
apply per_perp_in in H3; auto.
apply perp_in_comm in H3.
apply perp_in_perp_bis in H3.
induction H3.
Perp.
apply perp_distinct in H3.
tauto.

assert(Perp B C' C' C).
apply per_perp_in in H4; auto.
apply perp_in_comm in H4.
apply perp_in_perp_bis in H4.
induction H4.
Perp.
apply perp_distinct in H4.
tauto.

assert(Par A A' C C').
apply(l12_9 A A' C C' B A');Perp.
apply perp_sym.
apply(perp_col _ C'); Perp.
ColR.

induction H10.
assert(HH:=par_strict_symmetry A A' C C' H10).
apply l12_6 in H10.
apply l12_6 in HH.

assert(~Col A' A B).
apply per_not_col in H3; auto.
intro.
apply H3.
Col.

assert(~Col C' C B).
apply per_not_col in H4; auto.
intro.
apply H4.
Col.

assert(OS A' A B C').
apply out_one_side.
left; auto.
repeat split.
intro.
subst A'.
apply H11.
Col.
intro.
subst C'.
apply one_side_symmetry in H10.
unfold OS in H10.
ex_and H10 X.
unfold TS in H10.
spliter.
apply H10.
Col.
left.
assumption.

assert(OS C' C B A').
apply out_one_side.
left; auto.
repeat split.
intro.
subst C'.
apply H12.
Col.
intro.
subst C'.
apply one_side_symmetry in H10.
unfold OS in H10.
ex_and H10 X.
unfold TS in H10.
spliter.
apply H10.
Col.
left.
Between.

assert(OS A' A B C).
apply(one_side_transitivity _ _ _ C'); auto.
apply invert_one_side.
apply one_side_symmetry.
assumption.

assert(OS C C' B A).
apply(one_side_transitivity _ _ _ A'); auto.
apply invert_one_side.
assumption.
apply one_side_symmetry.
assumption.

apply invert_one_side in H15.

assert(HP:= col_one_side_out A A' B C H2 H15).

assert(Out C B A).
apply(col_one_side_out C C' B A); Col.

unfold Out in *.
spliter.

induction H19.
Between.
induction H22.
Between.
apply False_ind.
apply H18.
apply (between_equality _ _ B); Between.

(****************************)

spliter.
assert(Perp A' C' A A').
apply (perp_col _ B); Perp.
intro.
subst C'.
apply between_identity in H.
subst A'.
apply perp_distinct in H9.
tauto.
apply perp_not_col in H14.

apply False_ind.
apply H14.
ColR.
Qed.
per3_preserves_bet1
Proof.
intros O A B C A' B' C'.
intro HC.
intros.

induction(eq_dec_points A B).
subst B.
assert(A' = B').
apply(per2_col_eq O A' B' A H0 H1 H3 H4); Col.
subst B'.
Between.

induction (eq_dec_points A A').
subst A'.
induction(eq_dec_points B B').
subst B'.
assert(Col O C C').
apply bet_col in H.
ColR.

assert(C = C').
apply bet_col in H.
assert(O = C' \/ C = C').
apply(l8_9 O C' C H5); Col.
induction H10.
contradiction.
assumption.
subst C'.
assumption.

induction(eq_dec_points A B').
subst B'.
Between.

assert(A <> C).
intro.
subst C.
apply between_identity in H.
contradiction.

assert( ~ Col O B' B).
apply(per_not_col O B' B H1); auto.

assert(C <> C').
intro.
subst C'.
clean_trivial_hyps.
apply H12.
apply bet_col in H.
ColR.

assert(Perp B B' O A).

apply per_perp_in in H4; auto.
apply perp_in_perp_bis in H4.
induction H4.
apply perp_distinct in H4.
tauto.
apply perp_sym.
apply perp_right_comm.
apply(perp_col O B' B' B A); auto.
Col.

assert(Perp C C' O A).

apply per_perp_in in H5; auto.
apply perp_in_perp_bis in H5.
induction H5.
apply perp_distinct in H5.
tauto.
apply perp_sym.
apply perp_right_comm.
apply(perp_col O C' C' C A); auto.
apply bet_col in H.
ColR.

assert(Par B B' C C').
apply(l12_9 B B' C C' O A);auto.
induction H16.

assert(HH:=l12_6 B B' C C' H16).

assert(TS B B' A C).
unfold TS.
repeat split; Col.
assert(~Col B' A B).
apply(perp_not_col).
apply perp_left_comm.
apply(perp_col A O B B' B'); Col.
finish.
intro.
apply H17.
Col.
intro.
apply H16.
exists C.
split; Col.
exists B.
split; Col.
assert(TS B B' C' A).
apply(l9_8_2 B B' C C' A).

apply l9_2.
assumption.
assumption.
unfold TS in H18.
spliter.
ex_and H20 T.
assert(B'=T).
apply (l6_21 B B' A C'); Col.
intro.
subst C'.
apply between_identity in H21.
subst T.
contradiction.
subst T.
apply between_symmetry.
assumption.
spliter.

assert(Per O C' B).
apply(per_col O C' C B); Col.
assert(B'=C').
apply(per2_col_eq O B' C' B); Col.
ColR.
subst C'.
Between.

(*-------------------------------*)

induction(eq_dec_points A' B').
subst B'.
Between.

induction(eq_dec_points B C).
subst C.
assert(B' = C').
apply(per2_col_eq O B' C' B); auto.
ColR.
subst C'.
Between.

induction(eq_dec_points B B').
subst B'.
induction(eq_dec_points A' B).
subst B.
Between.

assert(C <> C').
intro.
subst C'.

assert( ~ Col O A' A).
apply(per_not_col O A' A ); auto.
apply H13.
apply bet_col in H.
ColR.

assert(Perp A A' O A').
apply per_perp_in in H3; auto.
apply perp_in_comm in H3.
apply perp_in_perp_bis in H3.
induction H3.
finish.
apply perp_distinct in H3.
tauto.

assert(Perp C C' O A').
apply per_perp_in in H5; auto.
apply perp_in_comm in H5.
apply perp_in_perp_bis in H5.
induction H5.
apply perp_sym.
apply (perp_col _ C'); auto.
finish.
ColR.
apply perp_distinct in H5.
tauto.

assert(Par A A' C C').
apply(l12_9 A A' C C' O A');auto.
induction H16.


assert(HH:=l12_6 A A' C C' H16).

(*--------------------------------*)
assert(OS C C' A A').
apply(l12_6 C C' A A').
finish.
assert(OS C C' A B).
apply(out_one_side C C' A B).
left.
intro.
apply H16.
exists A.
split; Col.
unfold Out.
repeat split; auto.
intro.
subst C.
apply between_identity in H.
contradiction.
right.
Between.

assert(OS C C' A' B).
apply(one_side_transitivity C C' A' A); auto.
apply one_side_symmetry.
assumption.

assert(Out C' B A').
induction H6.
unfold Out.
repeat split.
intro.
subst C'.
clean_trivial_hyps.
unfold OS in H17.
ex_and H17 T.
unfold TS in H4.
spliter.
apply H4.
Col.
intro.
subst C'.
apply H16.
exists A'.
split; Col.
left.
Between.

induction H6.

assert(TS C C' B A').
unfold TS.
repeat split.
intro.
unfold OS in H18.
ex_and H18 T.
unfold TS in H21.
spliter.
contradiction.
intro.
apply H16.
exists A'.
split; Col.
exists C'.
split; Col.
apply one_side_symmetry in H19.
apply l9_9_bis in H19.
contradiction.

unfold Out.
repeat split.
intro.
subst C'.
apply H16.
exists A.
apply bet_col in H.
split; Col.
intro.
subst C'.
apply H16.
exists A'.
split; Col.
right; auto.

(*****************************)

assert(Out A' B C').
induction H6.
unfold Out.
repeat split.
intro.
subst A'.
clean_trivial_hyps.
apply H16.
exists C.
apply bet_col in H.
split; Col.
intro.
subst C'.
unfold Out in H20.
tauto.
left.
auto.

induction H6.
unfold Out in H20.
spliter.
unfold Out.
repeat split.
intro.
subst A'.
apply H16.
exists C.
apply bet_col in H.
split; Col.
auto.
induction H22.
left.
Between.

apply False_ind.
apply H21.
apply (between_equality _ _ B); Between.

(***************************)

assert(OS A A' B C).
apply(out_one_side A A' B C).
right.
intro.
apply H16.
exists C.
split; Col.
unfold Out.
repeat split; auto.
intro.
subst C.
apply between_identity in H.
contradiction.

assert(OS A A' C' B).
apply(one_side_transitivity A A' C' C);
apply one_side_symmetry; auto.


(***********************)
assert(TS A A' B C').
unfold TS.
repeat split.
intro.
unfold OS in H21.
ex_and H21 T.
unfold TS in H21.
spliter.
contradiction.
intro.
apply H16.
exists C'.
split; Col.
exists A'.
split; Col.
Between.
apply one_side_symmetry in H22.
apply l9_9_bis in H22.
contradiction.

unfold Out in *.
spliter.
clean_duplicated_hyps.

induction H25; induction H23.
assumption.
apply False_ind.
apply H20.
apply(between_equality _ _ A'); Between.
apply False_ind.
apply H10.
apply(between_equality _ _ C'); Between.
apply False_ind.
apply H24.
apply(between_equality _ _ B); Between.
spliter.


assert(~Col O C' C).
apply(per_not_col); auto.
apply False_ind.
apply H20.

assert(A<>C).
intro.
subst C.
apply between_identity in H.
subst B.
tauto.
apply bet_col in H.
ColR.

(********************************)

assert(Perp A A' O A').
apply per_perp_in in H3; auto.
apply perp_in_comm in H3.
apply perp_in_perp_bis in H3.
induction H3.
finish.
apply perp_distinct in H3.
tauto.

assert(Perp B B' O A').
apply per_perp_in in H4; auto.
apply perp_in_comm in H4.
apply perp_in_perp_bis in H4.
induction H4.
apply perp_sym.
apply (perp_col _ B'); Col.
finish.
apply perp_distinct in H4.
tauto.

assert(Par A A' B B').
apply(l12_9 A A' B B' O A');auto.

induction H15.
assert(HH:=l12_6 A A' B B' H15).



assert(TS B B' A C).
unfold TS.
repeat split; Col.
intro.
apply H15.
exists A.
split; Col.
intro.
apply H11.
apply (l6_21 B B' A C); Col.
intro.
apply H15.
exists A.
split; Col.
intro.
subst C.
apply between_identity in H.
subst B.
tauto.
exists B.
split; Col.

assert(OS B B' A A').
apply(l12_6 B B' A A').
finish.

assert(HP:= l9_8_2 B B' A A' C H16 H17).


induction(eq_dec_points C C').
subst C'.
unfold TS in HP.
spliter.
ex_and H20 T.

assert(T = B').
apply (l6_21 B B' A' C); Col.
intro.
subst A'.
apply between_identity in H21.
subst T.
contradiction.
subst T.
assumption.

assert(Perp C C' O A').
apply per_perp_in in H5; auto.
apply perp_in_comm in H5.
apply perp_in_perp_bis in H5.
induction H5.
apply perp_sym.
apply (perp_col _ C'); finish.
ColR.
apply perp_distinct in H5.
tauto.

assert(Par B B' C C').
apply(l12_9 B B' C C' O A');auto.
induction H20.

assert(HQ:=l12_6 B B' C C' H20).

assert(TS B B' C' A').
apply(l9_8_2 B B' C C' A'); auto.
apply l9_2.
assumption.
unfold TS in H21.
spliter.
ex_and H23 T.
assert(T = B').
apply (l6_21 B B' A' C'); Col.
intro.
subst C'.
apply between_identity in H24.
subst T.
contradiction.
subst T.
Between.
spliter.
unfold TS in HP.
spliter.
apply False_ind.
apply H25.
ColR.
spliter.

apply perp_left_comm in H13.
apply perp_not_col in H13.
apply False_ind.
apply H13.
ColR.
Qed.
per3_preserves_bet2_aux
Proof.
intros O A B C B' C'.
intro HX.
intros.
induction(eq_dec_points A B).
subst B.
Between.
induction(eq_dec_points B C).
subst C.
Between.

assert(Col O A B').
apply bet_col in H0.
ColR.
assert(Col O B' C').
apply bet_col in H0.
ColR.

induction(eq_dec_points B B').
subst B'.
assert(Col O C C').
apply bet_col in H0.
ColR.
assert(C = C').
apply(per_col_eq C C' O); finish.
subst C'.
assumption.
assert(C <> C').
intro.
subst C'.
apply per_not_col in H4; auto.
apply H4.
ColR.

assert(Perp O A C C').
apply per_perp_in in H5; auto.
apply perp_in_comm in H5.
apply perp_in_perp_bis in H5.
induction H5.
apply (perp_col _ C'); finish.
apply perp_distinct in H5.
tauto.

assert(Perp O A B B').
apply per_perp_in in H4; auto.
apply perp_in_comm in H4.
apply perp_in_perp_bis in H4.
induction H4.
apply (perp_col _ B'); finish.
apply perp_distinct in H4.
tauto.

assert(Par B B' C C').
apply(l12_9 B B' C C' O A);finish.

induction H16.
assert(HH:=l12_6 B B' C C' H16).
assert(TS B B' A C').
repeat split; finish.
intro.
assert(Per B B' A).
apply(per_col B B' O A); finish.
apply per_not_col in H18; auto.
apply H18.
Col.
intro.
subst B'.
clean_trivial_hyps.
apply H16.
exists C.
split; Col.
intro.
apply H16.
exists C'.
split; Col.
exists B'.
split; finish.

assert(TS B B' C A).
apply(l9_8_2 B B' C' C A).
apply l9_2; auto.
apply one_side_symmetry; auto.
unfold TS in H18.
spliter.
ex_and H20 T.
assert(B = T).
apply (l6_21 A C B' B); Col.
assert(A <> C).
intro.
subst C.
apply between_identity in H21.
subst T.
contradiction.
intro.
apply bet_col in H0.
apply H19.
ColR.
subst T.
Between.

spliter.

assert(B' <> C').
intro.
subst C'.
clean_trivial_hyps.
assert(Perp O B' C B').
apply(perp_col O A C B' B'); Col.
apply perp_left_comm in H0.
apply perp_not_col in H0.
apply H0.
ColR.

assert(Per C C' B').
apply(per_col C C' O B'); finish.
apply per_not_col in H21; auto.
apply False_ind.
apply H21.
Col.
Qed.
per3_preserves_bet2
Proof.
intros O A B C A' B' C'.
intro HX.
intros.
induction(eq_dec_points A A').
subst A'.
apply (per3_preserves_bet2_aux O A B C B' C');auto.
induction(eq_dec_points C C').
subst C'.
apply between_symmetry.
apply(per3_preserves_bet2_aux O C B A B' A'); finish.

assert(Perp O A' C C').
apply per_perp_in in H6; auto.
apply perp_in_comm in H6.
apply perp_in_perp_bis in H6.
induction H6.
apply (perp_col _ C'); finish.
apply perp_distinct in H6.
tauto.

assert(Perp O A' A A').
apply per_perp_in in H4; auto.
apply perp_in_comm in H4.
apply perp_in_perp_bis in H4.
induction H4.
finish.
apply perp_distinct in H4.
tauto.

assert(Par A A' C C').
apply(l12_9 A A' C C' O A');finish.

induction H13.
assert(HH:=l12_6 A A' C C' H13).
apply par_strict_symmetry in H13.
assert(HP:=l12_6 C C' A A' H13).

induction(eq_dec_points B B').
subst B'.

assert(OS A' A B C').
apply out_one_side.
right.
intro.
apply H13.
exists C'.
split; Col.
repeat split.
intro.
subst A'.
apply H13.
exists C.
split; Col.
auto.
left; auto.
apply invert_one_side in H14.
assert(OS A A' B C).
apply (one_side_transitivity _ _ _ C').
assumption.
apply one_side_symmetry.
assumption.

assert(Out A B C).
apply (col_one_side_out A A');auto.

assert(OS C' C B A').
apply out_one_side.
right.
intro.
apply H13.
exists A'.
split; Col.
repeat split.
intro.
subst C'.
apply H13.
exists A.
split; Col.
auto.
left; Between.
apply invert_one_side in H17.
assert(OS C C' B A).
apply (one_side_transitivity _ _ _ A').
assumption.
apply one_side_symmetry.
assumption.
apply one_side_symmetry in H18.

assert(Out C A B).
apply (col_one_side_out C C');Col.
unfold Out in *.
spliter.


induction H23; induction H21.
assumption.
assumption.
assert(A = C).
apply (between_equality A C B); auto.
subst C.
apply False_ind.
apply H13.
exists A.
split; Col.
assert(B = C).
apply (between_equality B C A); Between.
subst C.
Between.

(****************************************************************************************)

assert(Perp O A' B B').
apply per_perp_in in H5; auto.
apply perp_in_comm in H5.
apply perp_in_perp_bis in H5.
induction H5.
apply (perp_col _ B'); finish.
apply bet_col in H0.
ColR.
apply perp_distinct in H5.
tauto.

assert(Par B B' A A').
apply(l12_9 B B' A A' O A');finish.

induction H16.
assert(HQ:=l12_6 B B' A A' H16).

assert(Par B B' C C').
apply(l12_9 B B' C C' O A');finish.
induction H17.
assert(HR:=l12_6 B B' C C' H17).

assert(TS B B' A' C').
repeat split; auto.
intro.
apply H16.
exists A'.
split; Col.
intro.
apply H17.
exists C'.
split; Col.
exists B'.
split; finish.
apply one_side_symmetry in HQ.
assert(HH1:= l9_8_2 B B' A' A C' H18 HQ).
apply l9_2 in HH1.
apply one_side_symmetry in HR.
assert(HH2:= l9_8_2 B B' C' C A HH1 HR).
unfold TS in HH2.
spliter.
ex_and H21 T.
assert(B = T).
apply (l6_21 B B' A C); Col.
intro.
subst C.
apply H13.
exists A.
split; Col.
subst T.
Between.
spliter.

induction(eq_dec_points B C).
subst C.
Between.
assert(Col A C C').
ColR.
apply False_ind.
apply H13.
exists A.
split; Col.
spliter.

induction(eq_dec_points A B).
subst B.
Between.
assert(Col C A A').
ColR.
apply False_ind.
apply H13.
exists C.
split; Col.
spliter.

assert(A <> C).
intro.
subst C.
apply H.
apply(per2_col_eq O A' C' A); Col.

assert(Col O C C').
ColR.
apply False_ind.
apply per_not_col in H6; auto.
apply H6.
Col.
Qed.
symmetry_preserves_per
Proof.
intros.
assert(HS:=symmetric_point_construction A P).
ex_and HS C.
assert(HS:=symmetric_point_construction C B).
ex_and HS C'.

assert(HH:= symmetry_preserves_midpoint A P C A' P' C' B H0 H1 H3 H2).
unfold Per.
exists C'.
split.
assumption.
unfold Per in H.
ex_and H X.
assert(X = C).
apply(symmetric_point_uniqueness A P X C); auto.
subst X.
unfold Midpoint in *.
spliter.
apply (cong_transitivity _ _ B A).
Cong.
apply(cong_transitivity _ _ B C).
assumption.
Cong.
Qed.
l13_1
Proof.
intros A B C P Q R HC MBC MAC MAB.
assert(Q <> C).
intro.
subst Q.
unfold Midpoint in MAC.
spliter.
apply cong_identity in H0.
subst C.
apply HC.
Col.
assert(P <> C).
intro.
subst P.
unfold Midpoint in MBC.
spliter.
apply cong_identity in H1.
subst C.
apply HC.
Col.

assert(D1:Q<>R).
intro.
subst R.
assert(B=C).
apply(symmetric_point_uniqueness A Q); auto.
subst C.
apply l7_3 in MBC.
contradiction.

assert(D2:R <> B).
intro.
subst R.
unfold Midpoint in MAB.
spliter.
apply cong_identity in H2.
subst B.
apply HC.
Col.

assert(~Col P Q C).
intro.
apply HC.
unfold Midpoint in *.
spliter.
apply bet_col in H2.
apply bet_col in H4.
apply bet_col in H6.
ColR.

assert(HH:= l8_18_existence P Q C H1).
ex_and HH C'.

assert(HS1:=symmetric_point_construction C' Q).
ex_and HS1 A'.
assert(HS1:=symmetric_point_construction C' P).
ex_and HS1 B'.

assert(Cong C C' B B').
apply(l7_13 P C C' B B' MBC); finish.
assert(Cong C C' A A').
apply(l7_13 Q C C' A A'); finish.

assert(Per P B' B).
induction(eq_dec_points P C').
subst C'.
unfold Midpoint in H5.
spliter.
apply cong_symmetry in H8.
apply cong_identity in H8.
subst B'.
apply l8_2.
apply l8_5.

apply(symmetry_preserves_per C C' P B B'); finish.
apply perp_in_per.
apply perp_in_comm.
apply perp_perp_in.
apply perp_left_comm.
apply (perp_col _ Q); Col.

assert(Per Q A' A).
induction(eq_dec_points Q C').
subst C'.
unfold Midpoint in H4.
spliter.
apply cong_symmetry in H9.
apply cong_identity in H9.
subst A'.
apply l8_2.
apply l8_5.
apply(symmetry_preserves_per C C' Q A A'); finish.
apply perp_in_per.
apply perp_in_comm.
apply perp_perp_in.
apply perp_left_comm.
apply (perp_col _ P); Col.
finish.

assert(Cl1: Col A' C' Q).
unfold Midpoint in H4.
spliter.
apply bet_col in H4.
Col.

assert(Cl2: Col B' C' P).
unfold Midpoint in H5.
spliter.
apply bet_col in H5.
Col.

assert(NE0: P <> Q).
apply perp_distinct in H3; tauto.

assert(NE1 : A' <> B').
intro.
subst B'.
apply NE0.
apply (l7_17 C' A'); auto.

assert(Cl3: Col A' B' P).
induction(eq_dec_points P C').
subst P.
unfold Midpoint in  H5.
spliter.
apply cong_symmetry in H10.
apply cong_identity in H10.
subst C'.
Col.
induction(eq_dec_points Q C').
subst Q.
unfold Midpoint in  H4.
spliter.
apply cong_symmetry in H11.
apply cong_identity in H11.
subst C'.
Col.
ColR.

assert(Cl4: Col A' B' Q).
induction(eq_dec_points P C').
subst P.
unfold Midpoint in  H5.
spliter.
apply cong_symmetry in H10.
apply cong_identity in H10.
subst C'.
Col.
induction(eq_dec_points Q C').
subst Q.
unfold Midpoint in  H4.
spliter.
apply cong_symmetry in H11.
apply cong_identity in H11.
subst C'.
Col.
ColR.

assert(Cl5:Col A' B' C').
ColR.

assert(NE2 : C <> C').
apply perp_distinct in H3.
tauto.

assert(NE3: A <> A').
intro.
subst A'.
apply cong_identity in H7.
contradiction.

assert(NE4: B <> B').
intro.
subst B'.
apply cong_identity in H6.
contradiction.

assert(Per P A' A).
induction(eq_dec_points A' Q).
subst Q.
unfold Midpoint in H4.
spliter.
apply cong_identity in H10.
subst C'.
clean_trivial_hyps.
apply perp_left_comm in H3.
apply perp_perp_in in H3.
apply perp_in_comm in H3.
apply perp_in_per in H3.
unfold Midpoint in MAC.
spliter.
apply bet_col in H2.
apply (per_col P A' C A); Col.
apply l8_2.
apply (per_col A A' Q P); finish.
ColR.

assert(Per Q B' B).
induction(eq_dec_points B' P).
subst P.
unfold Midpoint in H5.
spliter.
apply cong_identity in H11.
subst C'.
clean_trivial_hyps.
apply perp_perp_in in H3.
apply perp_in_comm in H3.
apply perp_in_per in H3.
unfold Midpoint in MBC.
spliter.
apply bet_col in H2.
apply (per_col Q B' C B); Col.
apply l8_2.
apply (per_col B B' P Q); finish.
ColR.

assert(Per A' B' B).
apply l8_2.
induction(eq_dec_points B' P).
subst P.
unfold Midpoint in H5.
spliter.
apply cong_identity in H12.
subst C'.
clean_trivial_hyps.
apply(per_col B B' Q A'); finish.
apply(per_col B B' P A'); finish.

assert(Per B' A' A).
apply l8_2.
induction(eq_dec_points A' Q).
subst Q.
unfold Midpoint in H4.
spliter.
apply cong_identity in H13.
subst C'.
clean_trivial_hyps.
apply(per_col A A' P B'); finish.
apply(per_col A A' Q B'); finish.


assert(NC1 : ~Col A' B' A).
apply per_not_col in H13; auto.
intro.
apply H13.
Col.

assert(NC2 : ~Col A' B' B).
apply per_not_col in H12; auto.

(****************************************)

assert(HM:=midpoint_existence A' B').
ex_and HM X.

assert(HP:=perp_exists X A' B' NE1).
ex_and HP y.

assert(HH:=ex_sym X y A).
ex_and HH B''.

assert( X <> y).
apply perp_distinct in H15.
tauto.


assert(Reflect B'' A X y).
unfold Reflect.
left.
repeat split;auto.
ex_and H17 M.
exists M.
split; finish.

assert(Reflect A' B' X y).
unfold Reflect.
left.
split; auto.
repeat split.
exists X.
split; finish.
left.
finish.
apply l10_4 in H19.

assert(HH:= l10_10 X y B''  B' A A' H19 H20).

assert(Per A' B' B'').
unfold Reflect in *.
induction H19; induction H20.
spliter.

apply(image_preserves_per B' A' A A' B' B'' X y); auto.
apply l10_4_spec.
assumption.
spliter.
contradiction.
spliter.
contradiction.
spliter.
contradiction.

unfold Reflect in H20.
induction H20.
spliter.
unfold ReflectL in H22.


assert(OS A' B' A B'').
induction H16.
assert(Par A' B' A B'').
apply(l12_9 A' B' A B'' X y); finish.

induction H23.
apply( l12_6 A' B' A B'' H23).
spliter.

apply per_not_col in H21; auto.
apply False_ind.
apply H21.
ColR.
intro.
subst B''.
apply cong_symmetry in HH.
apply cong_identity in HH.
subst A'.
apply cong_identity in H7.
subst C'.
tauto.
subst B''.
apply one_side_reflexivity.
intro.
apply NC1.
Col.

assert(OS A' B' A B).
unfold OS.
exists C.
split.
unfold TS.
repeat split; Col.
intro.
apply H1.
ColR.
exists Q.
split; Col.
unfold Midpoint in MAC.
tauto.
unfold TS.
repeat split; Col.
intro.
apply H1.
ColR.
exists P.
split; Col.
unfold Midpoint in MBC.
tauto.

(*********************************)


assert( Col B B'' B').
apply(per_per_col B B'' A' B'); finish.

assert(Cong B B' A A').
apply cong_transitivity with C C'; Cong.

assert(B = B'' \/ Midpoint B' B B'').
apply( l7_20); Col.

apply cong_transitivity with A A'; Cong.
induction H27.
subst B''.

exists R.
exists X.

ex_and H17 M.
assert(R = M).
apply (l7_17 A B); auto.
subst M.

assert(A <> B).
intro.
subst B.
apply HC; Col.

assert(Col R A B).
unfold Midpoint in MAB.
spliter.
apply bet_col in H30.
Col.

assert(X <> R).
intro.
subst X.
assert(Par A B A' B').
apply(l12_9 A B A' B' R y);finish.
induction H16.
Perp.
contradiction.
induction H31.
apply H31.
exists R.

unfold Midpoint in H14.
spliter.
apply bet_col in H14.
split; Col.
spliter.
apply NC1.
Col.

split.

apply(l8_14_2_1b_bis R X A B R); Col.
induction H16.
apply perp_left_comm.
apply(perp_col _ y); auto.
contradiction.

apply perp_left_comm.
apply(perp_col _ y);auto.
apply perp_sym.
induction(eq_dec_points B' P).
subst P.
apply(perp_col _ A');auto.
Perp.
Col.
apply(perp_col _ B');auto.
apply perp_left_comm.

apply(perp_col _ A');auto.
Perp.
Col.
ColR.

assert(TS A' B' B B'').
unfold TS.
repeat split; auto.
intro.
apply NC2; Col.
intro.
apply per_not_col in H21; auto.
apply H21.
Col.
intro.
subst B''.
unfold Midpoint in H27.
spliter.
apply cong_identity in H29.
subst B'.
unfold OS in H23.
ex_and H23 T.
unfold TS in H29.
spliter.
apply H29.
Col.
exists B'.
split; Col.
unfold Midpoint in H27.
tauto.
assert(OS A' B' B B'').
apply (one_side_transitivity A' B' B A ).
apply one_side_symmetry.
assumption.
assumption.
apply l9_9 in H28.
contradiction.
spliter.
contradiction.
Qed.
per_lt
  Proof.
    intros.
    assert(Lt B A A C /\ Lt B C A C).
      apply( l11_46 A B C).
        apply per_not_col; auto.
      left.
      assumption.
    spliter.
    split; apply lt_left_comm; assumption.
  Qed.
cong_perp_conga
Proof.
    intros.
    assert(A <> C /\ B <> P).
      split.
        apply perp_not_eq_1 in H0.
        assumption.
      apply perp_not_eq_2 in H0.
      assumption.
    spliter.
    assert(A <> B).
      intro.
      subst B.
      apply cong_symmetry in H.
      apply cong_identity in H.
      apply H1.
      auto.
    assert(C <> B).
      intro.
      subst B.
      apply cong_identity in H.
      contradiction.
    induction(Col_dec A B C).
      assert(~ Col B A P).
        apply perp_not_col.
        apply perp_comm.
        apply (perp_col _ C); Col.
      assert(Per P B A).
        apply perp_in_per.
        apply perp_in_comm.
        apply perp_perp_in.
        apply perp_sym.
        eapply (perp_col _ C); Col.
      assert(Per P B C).
        apply perp_in_per.
        apply perp_in_comm.
        apply perp_perp_in.
        apply perp_sym.
        eapply (perp_col _ A); Col.
        Perp.
      apply l8_2 in H7.
      apply l8_2 in H8.
      split.
        apply l11_16; auto.
      assert( A = C \/ Midpoint B A C).
        eapply l7_20; Cong.
      induction H9.
        contradiction.
      unfold TS.
      repeat split.
        auto.
        intro.
        apply H6.
        Col.
        intro.
        apply H6.
        ColR.
      exists B.
      unfold Midpoint in H9.
      spliter.
      split; Between.
    assert(HH:= H0).
    unfold Perp in HH.
    ex_and HH T.
    apply perp_in_col in H6.
    spliter.
    assert(B <> T).
      intro.
      subst T.
      apply H5.
      Col.
    assert(Perp B T A C).
      apply (perp_col _ P); Perp.
    assert(A <> T).
      intro.
      subst T.
      apply perp_comm in H9.
      apply perp_perp_in in H9.
      apply perp_in_comm in H9.
      apply perp_in_per in H9.
      assert(Lt B A B C /\ Lt C A B C).
        apply( per_lt B A C); auto.
      spliter.
      unfold Lt in H10.
      spliter.
      apply H12.
      Cong.
    assert(C <> T).
      intro.
      subst T.
      apply perp_left_comm in H9.
      apply perp_perp_in in H9.
      apply perp_in_comm in H9.
      apply perp_in_per in H9.
      assert(Lt B C B A /\ Lt A C B A).
        apply( per_lt B C A); auto.
      spliter.
      unfold Lt in H11.
      spliter.
      apply H13.
      Cong.
    assert(Perp_at T B T T A).
      apply perp_in_comm.
      apply perp_perp_in.
      apply perp_sym.
      apply (perp_col _ C).
        assumption.
        apply perp_sym.
        apply perp_left_comm.
        apply (perp_col _ P); Perp.
      Col.
    assert(Perp_at T B T T C).
      apply perp_in_comm.
      apply perp_perp_in.
      apply perp_sym.
      apply (perp_col _ A).
        assumption.
        apply perp_sym.
        apply perp_left_comm.
        apply (perp_col _ P); Perp.
      Col.
    assert(Cong T A T C /\ CongA T A B T C B /\ CongA T B A T B C).
      apply( l11_52 A T B C T B); Cong.
        eapply l11_16; auto.
          apply perp_in_per.
          apply perp_in_comm.
          apply perp_in_sym.
          assumption.
        apply perp_in_per.
        apply perp_in_comm.
        apply perp_in_sym.
        assumption.
      assert(Lt B T B A /\ Lt A T B A).
        apply( per_lt B T A); auto.
        apply perp_in_per.
        assumption.
      spliter.
      apply le_comm.
      unfold Lt in H14.
      spliter.
      assumption.
    spliter.
    split.
      induction(bet_dec P B T).
        apply conga_comm.
        eapply l11_13; auto.
          apply H16.
          Between.
        Between.
      apply conga_comm.
      assert(Out B T P).
        unfold Out.
        repeat split; auto.
        induction H7.
          right.
          assumption.
        induction H7.
          left.
          Between.
        apply between_symmetry in H7.
        contradiction.
      eapply out_conga.
        apply H16.
        assumption.
        apply out_trivial.
        auto.
        assumption.
      apply out_trivial.
      auto.
    assert(A = C \/ Midpoint T A C).
      apply l7_20; Col.
    induction H17.
      contradiction.
    unfold TS.
    repeat split; Col.
      assert(~ Col T A B).
        apply perp_not_col.
        apply perp_in_perp_bis in H12.
        induction H12.
          apply perp_not_eq_1 in H12.
          tauto.
        Perp.
      intro.
      apply H18.
      ColR.
      assert(~ Col T C B).
        apply perp_not_col.
        apply perp_in_perp_bis in H13.
        induction H13.
          apply perp_not_eq_1 in H13.
          tauto.
        Perp.
      intro.
      apply H18.
      ColR.
    exists T.
    apply midpoint_bet in H17.
    split; Col.
Qed.
perp_per_bet
Proof.
intros.
assert( A <> C).
intro.
subst C.
apply H.
Col.
assert(Bet A P C /\ A <> P /\ C <> P).
apply(l11_47 A C B P); auto.
Perp.
tauto.
Qed.
ts_per_per_ts
Proof.
intros.
assert(HTS:= H).
    unfold TS in H.
    assert (~ Col C A B).
      spliter.
      assumption.
    spliter.
    clear H.
    assert (A <> B).
      intro.
      subst B.
      Col.
    ex_and H4 P.
    assert_diffs.
    show_distinct C D.
contradiction.

unfold TS.
repeat split; auto.
intro.
assert(A = P).
apply bet_col in H5.
apply (l6_21 A B C D); Col.
subst P.
apply H6.
apply(per2_col_eq A C D B); finish.
intro.
assert(B = P).
apply bet_col in H5.
apply (l6_21 A B C D); Col.
subst P.
apply H6.
apply(per2_col_eq B C D A); finish.
exists P.
split.
finish.

assert(exists X : Tpoint, Col A B X /\ Perp A B C X).
apply(l8_18_existence A B C); Col.
ex_and H7 C'.

assert(exists X : Tpoint, Col A B X /\ Perp A B D X).
apply(l8_18_existence A B D); Col.
ex_and H12 D'.

assert( A <> C').
intro.
subst C'.
apply perp_perp_in in H8.
apply perp_in_comm in H8.
apply perp_in_per in H8.
assert(A = C).
apply (l8_7 B); Perp.
subst C.
tauto.

assert( A <> D').
intro.
subst D'.
apply perp_perp_in in H14.
apply perp_in_comm in H14.
apply perp_in_per in H14.
assert(A = D).
apply (l8_7 B); Perp.
subst D.
tauto.


assert(Bet A C' B).
apply(perp_per_bet A C B C'); Col.
Perp.
assert(Perp A C' C' C).
apply(perp_col _ B); Col; Perp.
apply perp_in_sym.
apply perp_in_right_comm.
apply(l8_15_1 A B C C'); auto.

assert(Bet A D' B).
apply(perp_per_bet A D B D'); Col.
Perp.
assert(Perp A D' D' D).
apply(perp_col _ B); Col; Perp.
apply perp_in_sym.
apply perp_in_right_comm.
apply(l8_15_1 A B D D'); auto.

induction(eq_dec_points C' P).
subst C'.
assumption.

induction(eq_dec_points D' P).
subst D'.
assumption.

induction(eq_dec_points A P).
subst P.
Between.
induction(eq_dec_points B P).
subst P.
Between.

assert(Bet C' P D').
apply(per13_preserves_bet C P D C' D'); Col.
ColR.
assert(Perp P C' C' C).
apply(perp_col _ A);auto.
apply perp_left_comm.
apply(perp_col _ B);Perp.
Col.
ColR.
apply perp_comm in H24.
apply perp_perp_in in H24.
apply perp_in_comm in H24.
apply perp_in_per in H24.
assumption.

assert(Perp P D' D' D).
apply(perp_col _ A);auto.
apply perp_left_comm.
apply(perp_col _ B);Perp.
Col.
ColR.
apply perp_comm in H24.
apply perp_perp_in in H24.
apply perp_in_comm in H24.
apply perp_in_per in H24.
assumption.

assert(HH:= l5_3 A C' D' B H18 H19).
induction HH.
eBetween.
apply between_symmetry in H24.
eBetween.
Qed.
l13_2_1
Proof.
    intros.
    intros.
    assert(HH:= H).
    unfold TS in HH.
    assert (~ Col C A B).
      spliter.
      assumption.
    spliter.
    assert(A <> C /\ A <> B /\ A <> D).
      unfold CongA in H4.
      spliter.
      repeat split; auto.
    spliter.
    assert(Cong B C B D /\ Cong A C A D /\ CongA C B A D B A).
      apply(l11_50_2 B A C B A D).
        intro.
        apply H6.
        Col.
        eapply l11_16; auto.
          apply l8_2.
          auto.
          intro.
          subst C.
          apply H6.
          Col.
          apply l8_2.
          auto.
        intro.
        subst D.
        apply H7.
        Col.
        apply conga_comm.
        auto.
      Cong.
    spliter.
    assert(Perp C D A B).
      apply( cong_conga_perp C A D B); Cong.
    assert(Col A B E).
      eapply perp_perp_col.
        apply perp_sym.
        apply H15.
      auto.
    assert(TS C D A B).
      apply ts_per_per_ts; auto.
    unfold TS in H17.
    spliter.
    ex_and H19 T1.
    ex_and H8 T.
    assert(T = T1).
      apply bet_col in H20.
      apply bet_col in H21.
      assert_diffs.
      apply (l6_21 A B C D); Col.
    subst T1.
    assert(T = E).
      assert_diffs.
      apply (l6_21 A B C D); Col.
    subst T.
    split.
      apply conga_left_comm.
      eapply out_conga.
        apply H4.
        apply out_trivial; auto.
        apply out_trivial; auto.
        apply out_trivial; auto.
      unfold Out.
      repeat split; auto.
      intro.
      subst E.
      contradiction.
    split.
      apply conga_sym.
      apply conga_right_comm.
      eapply out_conga.
        apply H4.
        apply out_trivial; auto.
        unfold Out.
        repeat split; auto.
        intro.
        subst E.
        contradiction.
        apply out_trivial; auto.
      apply out_trivial; auto.
    assumption.
Qed.
triangle_mid_par
Proof.
  intros.
   assert(HM:= midpoint_existence A B).
   ex_and HM R.
   assert(HH:= l13_1 A B C P Q R H H0 H1 H2).
   ex_and HH X.
   ex_and H3 Y.
assert(HH:= perp_in_col X Y A B R H3).
spliter.
   apply perp_in_perp_bis in H3.
unfold Midpoint in H2.
spliter.
apply bet_col in H2.
assert(X <> Y).
apply perp_distinct in H4.
tauto.

   induction H3.
   assert(Perp Y X A B).
apply (perp_col _ R); Perp.
Col.
apply perp_left_comm in H9.
assert(Par A B P Q).
   apply(l12_9 A B P Q X Y);Perp.
induction H10.
finish.
spliter.
assert(Col A B P).
ColR.
assert(P = B).
apply (l6_21 A B C P); Col.
unfold Midpoint in H0.
spliter.
apply bet_col in H0.
Col.
intro.
subst P.
contradiction.
subst P.
unfold Midpoint in H0.
spliter.
apply cong_symmetry in H15.
apply cong_identity in H15.
subst C.
contradiction.

assert(Perp X Y A B).
apply (perp_col _ R); Perp.
Col.
assert(Par A B P Q).
   apply(l12_9 A B P Q X Y);Perp.
induction H10.
finish.
spliter.
assert(Col A B P).
ColR.
assert(P = B).
apply (l6_21 A B C P); Col.
unfold Midpoint in H0.
spliter.
apply bet_col in H0.
Col.
intro.
subst P.
contradiction.
subst P.
unfold Midpoint in H0.
spliter.
apply cong_symmetry in H15.
apply cong_identity in H15.
subst C.
contradiction.
Qed.
perp_in_perp_in_col
Proof.
intros.
assert(HP1:= H).
assert(HP2:=H0).
assert(Col A B P /\ Col X Y P).
apply perp_in_col in H.
spliter.
split; Col.
spliter.
unfold Perp_at in H.
unfold Perp_at in H0.
spliter.
induction(eq_dec_points A P);
induction(eq_dec_points P X).
subst A.
subst X.
assert(Per B P Y).
apply(H10 B Y); Col.
assert(Per A' P Y).
apply(H6 A' Y); Col.
apply col_permutation_2.
apply(per_per_col B A' Y P); auto.
subst A.
assert(Per B P X).
apply(H10 B X); Col.
assert(Per A' P X).
apply(H6 A' X); Col.
apply col_permutation_2.
apply(per_per_col B A' X P); auto.
subst X.
assert(Per A P Y).
apply(H10 A Y); Col.
induction(eq_dec_points P A').
subst A'.
assert(Per B' P Y).
apply(H6 B' Y); Col.
assert(Col A B' P).
apply(per_per_col A B' Y P); auto.
ColR.

assert(Per A' P Y).
apply(H6 A' Y); Col.
assert(Col A A' P).
apply(per_per_col A A' Y P); auto.
ColR.

assert(Per A P X).
apply(H10 A X); Col.
induction(eq_dec_points P A').
subst A'.
assert(Per B' P X).
apply(H6 B' X); Col.
assert(Col A B' P).
apply(per_per_col A B' X P); auto.
ColR.

assert(Per A' P X).
apply(H6 A' X); Col.
assert(Col A A' P).
apply(per_per_col A A' X P); auto.
ColR.
Qed.
l13_2
Proof.
    intros.
    assert(HH:= H).
    unfold TS in HH.
    assert(~ Col C A B).
      spliter.
      assumption.
    spliter.
    assert(C <> D).
      intro.
      subst D.
      assert(OS A B C C).
        apply one_side_reflexivity.
        assumption.
      apply l9_9 in H.
      contradiction.
    assert(exists C', CongA B A C D A C' /\ OS D A C' B).
      apply(angle_construction_1 B A C D A B).
        intro.
        apply H5.
        Col.
      intro.
      apply H6.
      Col.
    ex_and H9 E'.
    assert(A <> B /\ A <> C /\ A <> D).
      unfold CongA in H9.
      spliter; auto.
    spliter.
    assert(HH:=l11_22 C A E' B D A B E').
    assert(HH1:=ts_per_per_ts A B C D H H0 H1).
    unfold TS in HH1.
    assert (~ Col A C D).
      spliter.
      assumption.
    spliter.
    ex_and H7 T.
    ex_and H17 T2.
    assert(T = T2).
      apply (l6_21 A B C D); Col.
    subst T2.
    assert(InAngle B D A C).
      unfold InAngle.
      repeat split; auto.
      exists T.
      split.
        Between.
      right.
      unfold Out.
      repeat split.
        intro.
        subst T.
        assert(~ Col C D A /\ Per A E D).
          apply(l8_16_1 C D A D E H8 H2).
            Col.
            intro.
            subst E.
            apply H15.
            auto.
          apply perp_sym.
          assumption.
        spliter.
        apply H20.
        Col.
        auto.
      left.
      assumption.
    assert(LeA C A B C A D).
      unfold LeA.
      exists B.
      split.
        apply l11_24.
        assumption.
      apply conga_refl; auto.
    assert(InAngle E' D A C).
      eapply lea_in_angle.
        apply lea_comm.
        eapply l11_30.
        apply H21.
        apply conga_comm.
        assumption.
        apply conga_refl; auto.
      assert(HH1:=ts_per_per_ts A B C D H H0 H1).
      assert(OS D A C B).
        apply ts_ts_os.
          apply invert_two_sides.
          assumption.
        apply l9_2.
        assumption.
      eapply one_side_transitivity.
        apply H22.
      apply one_side_symmetry.
      assumption.
    unfold InAngle in H22.
    spliter.
    ex_and H25 E''.
    induction H26.
      subst E''.
      apply False_ind.
      apply H15.
      apply bet_col in H25.
      Col.
    assert(CongA B A C D A E'').
      eapply (out_conga B A C D A E').
        auto.
        apply out_trivial; auto.
        apply out_trivial; auto.
        apply out_trivial; auto.
      apply l6_6.
      auto.
    assert(A <> T).
      intro.
      subst T.
      apply H15.
      Col.
    induction(eq_dec_points E'' T).
      subst E''.
      apply l13_2_1; auto.
      eapply out_conga.
        apply conga_left_comm.
        apply H27.
        apply out_trivial; auto.
        apply out_trivial; auto.
        apply out_trivial; auto.
      unfold Out.
      repeat split; auto.
    assert(D <> E'').
      intro.
      subst E''.
      apply conga_sym in H27.
      apply eq_conga_out in H27.
      apply out_col in H27.
      apply H5.
      Col.
    assert(C <> E'').
      intro.
      subst E''.
      assert(Out A B D \/ TS C A B D).
        apply(conga__or_out_ts C A B D).
        apply conga_comm.
        assumption.
      induction H31.
        apply out_col in H31.
        apply H6.
        Col.
      assert(OS A C B D).
        apply ts_ts_os.
          assumption.
        apply ts_per_per_ts; auto.
      apply invert_one_side in H32.
      apply l9_9 in H31.
      contradiction.
    assert(A <> E'').
      intro.
      subst E''.
      unfold Out in H26.
      tauto.
    assert(~ Col E'' A B).
      intro.
      apply H29.
      apply bet_col in H25.
      apply (l6_21 A B C D); Col.
    assert(CongA C A E'' D A B).
      apply (l11_22 C A E'' B D A B E'').
      split.
        induction(one_side_dec A B C E'').
          right.
          split.
            auto.
          unfold OS.
          exists C.
          split.
            unfold TS.
            repeat split.
              auto.
              intro.
              apply H15.
              apply bet_col in H25.
              apply col_permutation_1.
              eapply (col_transitivity_1 _ E''); Col.
              intro.
              apply bet_col in H25.
              apply H15.
              apply col_permutation_2.
              eapply (col_transitivity_1 _ E''); Col.
            exists E''.
            split; Col.
          assert(TS A E'' T C).
            unfold TS.
            repeat split.
              auto.
              intro.
              apply H29.
              apply (l6_21 A B C D);Col.
              eapply (col_transitivity_1 _ T); Col.
              apply bet_col in H25.
              Col.
              intro.
              apply H15.
              ColR.
            exists E''.
            split.
              Col.
            assert(Bet C T E'' \/ Bet C E'' T).
              eapply l5_3.
                apply H18.
              Between.
            induction H35.
              assert(TS A B C E'').
                unfold TS.
                repeat split; auto.
                exists T.
                split.
                  Col.
                auto.
              apply l9_9 in H36.
              contradiction.
            Between.
          eapply (l9_5 _ _ T _ A); Col.
          unfold Out.
          repeat split; auto.
        left.
        apply not_one_side_two_sides in H34; auto.
        split.
          auto.
        assert(OS A B D E'').
          eapply l9_8_1.
            apply l9_2.
            apply H.
          apply l9_2.
          assumption.
        assert(TS A E'' T D).
          unfold TS.
          repeat split.
            auto.
            intro.
            apply H33.
            apply col_permutation_2.
            apply(col_transitivity_1 _ T); Col.
            intro.
            apply bet_col in H25.
            apply H15.
            apply col_permutation_1.
            eapply (col_transitivity_1 _ E''); Col.
          exists E''.
          split.
            Col.
          assert(Bet D T E'' \/ Bet D E'' T).
            eapply l5_3.
              apply between_symmetry.
              apply H18.
            assumption.
          induction H36.
            assert(TS A B D E'').
              unfold TS.
              repeat split; auto.
              exists T.
              split; Col.
            apply l9_9 in H37.
            contradiction.
          Between.
        apply l9_2.
        eapply (l9_5 _ _ T _ A).
          auto.
          Col.
        unfold Out.
        repeat split; auto.

      split.
        apply conga_left_comm.
        auto.
      apply conga_right_comm.
      apply conga_refl; auto.
    (***********************)
    prolong B C C' B C.
    prolong B D D' B D.
    assert(Cong_3 B A D D' A D).
      apply l8_2 in H1.
      unfold Per in H1.
      ex_and H1 D''.
      assert(Midpoint D B D').
        unfold Midpoint.
        split; Cong.
      assert(D' = D'').
        eapply symmetric_point_uniqueness.
          apply H40.
        auto.
      subst D''.
      repeat split; Cong.
    assert(CongA B A D D' A D).
      apply cong3_conga; auto.
    assert(Cong_3 B A C C' A C).
      apply l8_2 in H0.
      unfold Per in H0.
      ex_and H0 C''.
      assert(Midpoint C B C').
        unfold Midpoint.
        split; Cong.
      assert(C' = C'').
        eapply symmetric_point_uniqueness.
          apply H42.
        auto.
      subst C''.
      repeat split; Cong.
    assert(CongA B A C C' A C).
      apply cong3_conga; auto.
    assert(CongA E'' A C' D' A E'').
      apply l11_22 with C D.
      split.
        clear HH.
        (***************************************************)
        left.
        assert(OS C A D E'').
          eapply out_out_one_side.
            apply one_side_reflexivity.
            intro.
            apply H15.
            Col.
          unfold Out.
          repeat split; auto.
          right.
          Between.
        assert(OS C A B D).
          apply in_angle_one_side.
            intro.
            apply H15.
            Col.
            intro.
            apply H5.
            Col.
          apply l11_24.
          auto.
        assert(TS C A B C').
          unfold TS.
          repeat split.
            auto.
            intro.
            apply H5.
            Col.
            intro.
            apply H5.
            apply bet_col in H35.
            assert(C <> C').
              intro.
              subst C'.
              apply cong_symmetry in H36.
              apply cong_identity in H36.
              subst C.
              apply H16.
              Col.
            eapply (col_transitivity_1 _ C'); Col.
          exists C.
          split; Col.
        assert(OS C A B E'').
          eapply one_side_transitivity.
            apply H44.
          auto.
        assert(OS D A C E'').
          eapply out_out_one_side.
            apply one_side_reflexivity.
            intro.
            apply H15.
            Col.
          unfold Out.
          repeat split; auto.
        assert(OS D A B C).
          apply in_angle_one_side.
            intro.
            apply H15.
            Col.
            intro.
            apply H6.
            Col.
          auto.
        assert(TS D A B D').
          unfold TS.
          repeat split.
            auto.
            intro.
            apply H6.
            Col.
            intro.
            apply H6.
            apply bet_col in H37.
            assert(D <> D').
              intro.
              subst D'.
              apply cong_symmetry in H38.
              apply cong_identity in H38.
              subst D.
              apply H16.
              Col.
            eapply (col_transitivity_1 _ D'); Col.
          exists D.
          split; Col.
        assert(OS D A B E'').
          eapply one_side_transitivity.
            apply H48.
          auto.
        split.
          apply invert_two_sides.
          eapply l9_8_2.
            apply H45.
          auto.
        apply invert_two_sides.
        apply l9_2.
        eapply l9_8_2.
          apply H49.
        auto.
      split.
        eapply conga_trans.
          apply conga_comm.
          apply H34.
        apply H40.
      apply conga_sym.
      eapply conga_trans.
        apply conga_sym.
        apply H27.
      apply conga_right_comm.
      auto.
    assert(D' <> B).
      intro.
      subst D'.
      apply between_identity in H37.
      subst D.
      apply H16.
      Col.
    assert(C' <> B).
      intro.
      subst C'.
      apply between_identity in H35.
      subst C.
      apply H16.
      Col.
    assert(~ Col C' D' B).
      intro.
      apply H16.
      apply bet_col in H35.
      apply  bet_col in H37.
      assert(Col C' B D).
        ColR.
      ColR.
    assert(Par_strict C' D' C D).
      apply(triangle_mid_par C' D' B D C).
        auto.
        unfold Midpoint.
        split.
          Between.
        Cong.
      unfold Midpoint.
      split.
        Between.
      Cong.
    assert(TS A E'' C D).
      unfold TS.
      repeat split.
        auto.
        intro.
        apply H15.
        apply bet_col in H25.
        apply col_permutation_2.
        eapply (col_transitivity_1 _ E''); Col.
        intro.
        apply H15.
        apply bet_col in H25.
        apply col_permutation_1.
        eapply (col_transitivity_1 _ E''); Col.
      exists E''.
      split; Col.
      Between.
    assert(TS B A C D).
      apply in_angle_two_sides.
        intro.
        apply H5.
        Col.
        intro.
        apply H6.
        Col.
      apply l11_24.
      assumption.
    assert (OS A B C C').
      apply (out_one_side_1 _ _ _ _ B); Col.
      unfold Out.
      repeat split; auto.
      intro.
      subst C.
      apply H5.
      Col.
    assert (OS A B D D').
      apply (out_one_side_1 _ _ _ _ B); Col.
      unfold Out.
      repeat split; auto.
      intro.
      subst D.
      apply H6.
      Col.
    apply invert_two_sides in H49.
    assert(TS A B C' D).
      eapply l9_8_2.
        apply H49.
      auto.
    assert(TS A B C' D').
      apply l9_2.
      eapply l9_8_2.
        apply l9_2.
        apply H52.
      auto.
    assert(Perp  C' D' A E'').
      eapply cong_conga_perp.
        apply conga_right_comm in H43.
        apply conga__or_out_ts in H43.
        induction H43.
          assert(OS A B C' D').
            eapply (out_one_side_1 _ _ _ _ A); Col.
            intro.
            assert(B <> C').
              intro.
              subst C'.
              apply H46.
              Col.
            apply H5.
            apply col_permutation_1.
            eapply col_transitivity_1.
              apply H55.
              apply bet_col in H35.
              Col.
            Col.
          apply l9_9 in H53.
          contradiction.
        apply invert_two_sides.
        assumption.
        unfold Cong_3 in *.
        spliter.
        apply cong_transitivity with B A; Cong.
      apply conga_left_comm.
      assumption.


assert(Cong A C' A B).
apply l8_2 in H0.
unfold Per in H0.
ex_and H0 C''.
assert(C' = C'').
apply(symmetric_point_uniqueness B C C' C''); finish.
split; finish.
subst C''.
Cong.

assert(Cong A D' A B).
apply l8_2 in H1.
unfold Per in H1.
ex_and H1 D''.
assert(D' = D'').
apply(symmetric_point_uniqueness B D D' D''); finish.
split; finish.
subst D''.
Cong.

assert(Cong A C' A D').
apply cong_transitivity with A B; Cong.

assert(HM:=midpoint_existence C' D').
ex_and HM R.
assert(exists X Y : Tpoint, Perp_at R X Y C' D' /\ Perp X Y D C).
apply(l13_1 C' D' B D C R);
finish.
split; Between; Cong.
split; Between; Cong.
ex_and H59 X.
ex_and H60 Y.

assert(HXY:X <> Y).
apply perp_distinct in H60.
tauto.

assert(Perp C D A E'').

induction(eq_dec_points A R).
subst R.

assert(Perp_at A C' D' A E'').
assert_cols.
apply(l8_14_2_1b_bis C' D' A E'' A); Col.

assert(Col X Y A).
apply(perp_in_perp_in_col X Y A E'' C' D' A); finish.
assert(Col X Y E'').
apply(perp_in_perp_in_col X Y E'' A C' D' A); finish.
apply perp_sym.
induction(eq_dec_points Y A).
subst Y.
apply(perp_col _ X).
auto.
Perp.
Col.
apply(perp_col _ Y).
auto.
apply perp_left_comm.
apply (perp_col _ X); Col.
Perp.
ColR.

assert(R <> C').
intro.
subst R.
unfold Midpoint in H58.
spliter.
apply cong_symmetry in H62.
apply cong_identity in H62.
subst D'.
apply perp_distinct in H54.
tauto.

assert(Per A R C').
unfold Per.
exists D'.
split; finish.
apply per_perp_in in H63; auto.
apply perp_in_sym in H63.
apply perp_in_perp_bis in H63.
induction H63.
apply perp_comm in H63.
assert(Perp C' D' R A).
apply(perp_col _ R).
intro.
subst D'.
apply perp_distinct in H54.
tauto.
assumption.
assert_cols.
Col.

assert(Perp_at R C' D' R A).
apply(l8_14_2_1b_bis C' D' R A R); Col.
assert_cols.
Col.

assert( Col X Y A).
apply(perp_in_perp_in_col X Y A R C' D' R); Perp.
assert( Col X Y R).
apply(perp_in_perp_in_col X Y R A C' D' R); Perp.

assert(Col A E'' R).
apply(perp_perp_col A E'' R C' D'); Perp.

assert(Col A R X).
ColR.
assert(Col A R Y).
ColR.


apply perp_sym.
induction(eq_dec_points X A).
subst X.
apply (perp_col _ Y); finish.
ColR.
apply (perp_col _ X); finish.
apply perp_left_comm.
apply(perp_col _ Y); finish.
ColR.
apply perp_distinct in H63.
tauto.

    assert(Col A E E'').
      eapply perp_perp_col.

        apply H3.
Perp.

    assert(E'' = E).
      apply (l6_21 C D A E); Col.
      apply perp_not_eq_1 in H3.
      assumption.
    subst E''.
    split.
      auto.
    split.
      apply conga_sym.
      apply conga_right_comm.
      auto.
    Between.
Qed.
perp2_refl
Proof.
    intros.
    induction(Col_dec A B P).
      assert(HH:=not_col_exists A B H).
      ex_and HH X.
      assert(HH:=l10_15 A B P X  H0 H1).
      ex_and HH Q.
      unfold Perp2.
      exists Q.
      exists P.
      split; Perp.
      Col.
    assert(HH:=l8_18_existence A B P H0).
    ex_and HH Q.
    unfold Perp2.
    exists P.
    exists Q.
    split; Perp.
    Col.
Qed.
perp2_sym
Proof.
    unfold Perp2.
    intros.
    ex_and H X.
    ex_and H0 Y.
    exists X.
    exists Y.
    repeat split; Perp.
Qed.
perp2_left_comm
Proof.
    unfold Perp2.
    intros.
    ex_and H X.
    ex_and H0 Y.
    exists X.
    exists Y.
    repeat split; Perp.
Qed.
perp2_right_comm
Proof.
    unfold Perp2.
    intros.
    ex_and H X.
    ex_and H0 Y.
    exists X.
    exists Y.
    repeat split; Perp.
Qed.
perp2_comm
Proof.
    unfold Perp2.
    intros.
    ex_and H X.
    ex_and H0 Y.
    exists X.
    exists Y.
    repeat split; Perp.
Qed.
perp2_trans
Proof.
    intros.
    unfold Perp2 in *.
    ex_and H X.
    ex_and H1 Y.
    ex_and H0 X'.
    ex_and H3 Y'.
    assert(Par X Y X' Y').
      eapply (l12_9 _ _ _ _ C D); Perp.
    exists X.
    exists Y.
    assert(Col X X' Y').
      induction H5.
        unfold Par_strict in H5.
        spliter.
        apply False_ind.
        apply H8.
        exists P.
        split; Col.
      spliter.
      auto.
    assert(Col Y X' Y').
      induction H5.
        unfold Par_strict in H5.
        spliter.
        apply False_ind.
        apply H9.
        exists P.
        split; Col.
      spliter.
      auto.
    repeat split; auto.
    assert(X <> Y).
      apply perp_not_eq_1 in H1.
      assert(X' <> Y').
        apply perp_not_eq_1 in H3.
        auto.
      auto.
    induction(eq_dec_points X Y').
      subst Y'.
      apply (perp_col _ X').
        auto.
        Perp.
      ColR.
    apply (perp_col _ Y').
      auto.
      apply perp_left_comm.
      apply(perp_col _ X').
        auto.
        Perp.
      ColR.
    apply par_symmetry in H5.
    induction H5.
      unfold Par_strict in H5.
      spliter.
      apply False_ind.
      apply H12.
      exists P.
      split; Col.
    spliter.
    Col.
Qed.
perp2_par
Proof.
    intros.
    unfold Perp2 in H.
    ex_and H X.
    ex_and H0 Y.
    eapply (l12_9 _ _ _ _ X Y).
      Perp.
    Perp.
Qed.
perp2_preserves_bet23
Proof.
intros.

assert(HD1: A <> A').
intro.
subst A'.
apply H1.
Col.

induction(eq_dec_points A' B').
subst B'.
Between.

assert(A <> B).
intro.
subst B.
unfold Perp2 in H2.
ex_and H2 X.
ex_and H4 Y.
assert(Col A A' B').
apply(perp_perp_col A A' B' X Y); Perp.
apply H1.
ColR.

assert(Par A A' B B').
apply(perp2_par A A' B B' O H2).
induction H5.
assert(OS A A' B B').
apply l12_6; Par.
assert(TS A A' O B).
repeat split; Col.
intro.
apply H5.
exists B.
split; Col.
exists A.
split; Col.

assert(TS A A' B' O).
apply( l9_8_2 A A' B B' O); auto.
apply l9_2.
auto.

unfold TS in H8.
spliter.
ex_and H10 T.
assert(T = A').
apply (l6_21 A A' O B'); Col.
intro.
subst B'.
apply between_identity in H11.
subst T.
contradiction.
subst T.
Between.

spliter.
apply False_ind.
apply H1.
ColR.
Qed.
perp2_preserves_bet13
Proof.
intros.

induction(eq_dec_points C' O).
subst C'.
Between.
induction(eq_dec_points B' O).
Between.

assert(B <> O).
intro.
subst B.
apply H1.
Col.

assert(B' <> O).
intro.
subst B'.
apply H1.
Col.

assert(Col B O C).
apply bet_col.
Between.

induction(eq_dec_points B C).
subst C.
apply between_identity in H.
contradiction.

assert(Par B C' C B').
apply (perp2_par _ _ _ _ O); auto.
assert(Par_strict B C' C B').
induction H9.
assumption.
spliter.
apply False_ind.
apply H1.
ColR.

assert(C<> O).
intro.
subst C.
assert(Par_strict B C' O C').
apply(par_strict_col_par_strict _ _ _ B'); auto.
apply H11.
exists C'.
Col.

assert(B' <> O).
intro.
subst B'.
assert(Par_strict B C' O B).
apply(par_strict_col_par_strict _ _ _ C); auto.
apply par_strict_right_comm.
assumption.
Col.
apply H12.
exists B.
split; Col.

unfold Perp2 in H2.
ex_and H2 X.
ex_and H13 Y.

assert(X <> Y).
apply perp_distinct in H13.
tauto.

induction(Col_dec X Y B).
assert(Col X Y C).
ColR.

apply(per13_preserves_bet_inv  B' O C' C B); Between.
Col.

apply perp_in_per.
induction(eq_dec_points X C).
subst X.
assert(Perp C O B' C).
apply(perp_col _ Y); Perp.
ColR.
apply perp_perp_in in H18.
Perp.
assert(Perp X C C B').
apply(perp_col _ Y); Perp.
assert(Perp C O B' C).
apply(perp_col _ X); Perp.
ColR.
apply perp_perp_in in H20.
Perp.

apply perp_in_per.
induction(eq_dec_points X B).
subst X.
assert(Perp B O C' B).
apply(perp_col _ Y); Perp.
ColR.
apply perp_perp_in in H18.
Perp.
assert(Perp X B C' B).
apply(perp_col _ Y); Perp.
assert(Perp B O C' B).
apply(perp_col _ X); Perp.
ColR.
apply perp_perp_in in H20.
Perp.

assert(HP1:=l8_18_existence X Y B H16).
ex_and HP1 B0.
assert(~Col X Y C).
intro.
apply H16.
ColR.
assert(HP1:=l8_18_existence X Y C H19).
ex_and HP1 C0.

assert(B0 <> O).
intro.
subst B0.
assert(Par B O B C').
apply(l12_9 B O B C' X Y); Perp.
induction H22.
apply H22.
exists B.
split; Col.
spliter.
apply H1.
ColR.

assert(C0 <> O).
intro.
subst C0.
assert(Par C O C B').
apply(l12_9 C O C B' X Y); Perp.
induction H23.
apply H23.
exists C.
split; Col.
spliter.
apply H1.
ColR.

assert(Bet B0 O C0).

apply(per13_preserves_bet B O C B0 C0); auto.
Between.
ColR.
apply perp_in_per.
induction(eq_dec_points X B0).
subst X.
assert(Perp B0 O B B0).
apply(perp_col _ Y); Perp.
Col.
apply perp_perp_in in H24.
Perp.
assert(Perp X B0 B B0).
apply(perp_col _ Y); Perp.
assert(Perp B0 O B B0).
apply (perp_col _ X); Perp.
ColR.
apply perp_perp_in in H26.
Perp.

apply perp_in_per.
induction(eq_dec_points X C0).
subst X.
assert(Perp C0 O C C0).
apply(perp_col _ Y); Perp.
Col.
apply perp_perp_in in H24.
Perp.
assert(Perp X C0 C C0).
apply(perp_col _ Y); Perp.
assert(Perp C0 O C C0).
apply (perp_col _ X); Perp.
ColR.
apply perp_perp_in in H26.
Perp.

induction(eq_dec_points C' B0).
subst B0.
assert(B' = C0).
apply bet_col in H24.
apply (l6_21 C' O C C0); Col.
assert(Par C B' C C0).
apply(l12_9 C B' C C0 X Y); Perp.

induction H25.
apply False_ind.
apply H25.
exists C.
split; Col.
spliter.
Col.
intro.
apply H1.
ColR.
intro.
subst C0.
apply H1.
ColR.
apply(perp_perp_col C C0 B' X Y); Perp.
subst C0.
Between.

assert(B' <> C0).
intro.
subst C0.
apply H25.
apply (l6_21 B' O B B0); Col.
intro.
subst B0.
Col.
assert(Par B C' B B0).
apply(l12_9 B C' B B0 X Y); Perp.

induction H26.
apply False_ind.
apply H26.
exists B.
split; Col.
spliter.
Col.

assert(Col C C0 B').
apply(perp_perp_col C C0 B' X Y); Perp.
assert(Col B B0 C').
apply(perp_perp_col B B0 C' X Y); Perp.

apply(per13_preserves_bet_inv B' O C' C0 B0); Between.
Col.

apply perp_in_per.
induction(eq_dec_points X C0).
subst X.
assert(Perp C0 O C B').
apply (perp_col _ Y); Perp.
Col.
assert(Perp B' C0 C0 O).
apply(perp_col _ C); Perp.
Col.
apply perp_comm in H30.
apply perp_perp_in in H30.
Perp.

assert(Perp X C0 C B').
apply(perp_col _ Y); Perp.
assert(Perp C0 O C B').
apply (perp_col _ X); Perp.
ColR.
assert(Perp B' C0 C0 O).
apply(perp_col _ C); Perp.
Col.
apply perp_comm in H32.
apply perp_perp_in in H32.
Perp.


apply perp_in_per.

assert(Perp C' B0 X Y).
apply (perp_col _ B); Perp.
Col.
induction (eq_dec_points X O).
subst X.
assert(Perp O B0 B0 C').
apply(perp_col _ Y);Perp.
apply perp_comm in H30.
apply perp_perp_in in H30.
Perp.
 
assert(Perp X O C' B0).
apply(perp_col _ Y); Perp.
Col.
assert(Perp O B0 B0 C').
apply(perp_col _ X); Perp.
ColR.
apply perp_comm in H32.
apply perp_perp_in in H32.
Perp.

Qed.
is_image_perp_in
Proof.
intros.
unfold Reflect in H.
induction H1.
spliter.
unfold ReflectL in H2.
spliter.
ex_and H2 P.
induction H3.
exists P.

apply perp_in_sym.
apply perp_in_right_comm.
apply(l8_14_2_1b_bis X Y A' A P); Col.
assert_cols.
Col.
subst A'.
tauto.
spliter.
contradiction.
Qed.
perp_inter_perp_in_n
Proof.
intros.
assert(A <> B /\ C <> D).
apply perp_distinct in H.
tauto.
spliter.
induction(Col_dec A B C).
exists C.
split; Col.
split; Col.
apply(l8_14_2_1b_bis A B C D C); Col.

assert(HH:=l8_18_existence A B C H2).
ex_and HH P.
exists P.
assert(Col C D P).
apply(perp_perp_col C D P A B); Perp.
split; Col.
split; Col.
apply(l8_14_2_1b_bis A B C D P); Col.
Qed.
perp2_perp_in
Proof.
    intros.
    unfold Perp2 in H.
    ex_and H X.
    ex_and H1 Y.
    assert(X <> Y).
      apply perp_not_eq_1 in H2.
      auto.
    assert(HH:= perp_inter_perp_in_n X Y A B H2).
    ex_and HH P.
    assert(HH:= perp_inter_perp_in_n X Y C D H3).
    ex_and HH Q.
    exists P.
    exists Q.
    split; auto.
    split; auto.
    split.
      apply (col3 X Y); Col.
    split.
      induction(eq_dec_points X O).
        subst X.
        apply perp_in_sym.
        apply(perp_in_col_perp_in A B O Y P P).
          intro.
          subst P.
          apply H.
          Col.
          Col.
        apply perp_in_sym.
        auto.
      assert(Perp_at P A B X O).
        apply(perp_in_col_perp_in A B X Y O P H11).
          Col.
        apply perp_in_sym.
        auto.
      apply perp_in_right_comm in H12.
      eapply (perp_in_col_perp_in _ _ _ _ P) in H12 .
        apply perp_in_sym.
        auto.
        intro.
        subst P.
        apply H.
        Col.
      ColR.
    induction(eq_dec_points X O).
      subst X.
      apply perp_in_sym.
      apply(perp_in_col_perp_in C D O Y Q Q).
        intro.
        subst Q.
        apply H0.
        Col.
        Col.
      apply perp_in_sym.
      auto.
    assert(Perp_at Q C D X O).
      apply(perp_in_col_perp_in C D X Y O Q H11).
        Col.
      apply perp_in_sym.
      auto.
    apply perp_in_right_comm in H12.
    eapply (perp_in_col_perp_in _ _ _ _ Q) in H12 .
      apply perp_in_sym.
      auto.
      intro.
      subst Q.
      apply H0.
      Col.
    ColR.
Qed.
l13_8
Proof.
    intros.
    induction(eq_dec_points P U).
      subst P.
      assert(Col Q V O).
        ColR.
      assert(HH:= l8_9 Q V O H4 H5).
      induction HH.
        subst Q.
        tauto.
      subst V.
      tauto.
    assert(Q <> V).
      intro.
      subst Q.
      assert(HH:= per_not_col P U O H5 H H3).
      apply HH.
      ColR.
split.
intro.
unfold Out in H7.
spliter.
induction H9.

assert(HH:= per23_preserves_bet O P Q U V).
repeat split; auto.
left.
apply(per23_preserves_bet O P Q U V); auto.
Perp.
Perp.
repeat split; auto.
right.
apply(per23_preserves_bet O Q P V U); Col.
Perp.
Perp.

intro.
unfold Out in H7.
spliter.

repeat split.
intro.
subst P.
apply l8_8 in H3.
contradiction.
intro.
subst Q.
apply l8_8 in H4.
contradiction.
induction H9.
left.
apply(per23_preserves_bet_inv O P Q U V); Perp.
right.
apply(per23_preserves_bet_inv O Q P V U); Perp.
Col.
Qed.
perp_in_rewrite
Proof.
intros.
assert(HH:= perp_in_col A B C D P H).
spliter.
induction(eq_dec_points A P);
induction(eq_dec_points C P).
subst A .
subst C.
right;right;right.
Perp.
subst A.
right; right; left.
apply perp_in_right_comm.
assert(HP:=perp_in_col_perp_in P B C D P P H3 H1 H).
Perp.
subst C.
right; left.
apply perp_in_sym.
apply(perp_in_col_perp_in P D A B P P H2 H0).
Perp.
left.
assert(HP:= perp_in_col_perp_in A B C D P P H3 H1 H).
apply perp_in_sym.
apply perp_in_left_comm.
apply(perp_in_col_perp_in C P A B P P H2 H0).
Perp.
Qed.
gta_to_lta
Proof.
intros.
unfold GtA in H.
assumption.
Qed.
lta_to_gta
Proof.
intros.
unfold GtA.
assumption.
Qed.
conga_preserves_obtuse
Proof.
intros.
unfold Obtuse in *.
ex_and H A1.
ex_and H1 B1.
ex_and H C1.

exists A1.
exists B1.
exists C1.
split; auto.

assert(A1 <> B1 /\ C1 <> B1).
unfold GtA in H1.
unfold LtA in H1.
spliter.
unfold LeA in H1.
ex_and H1 P.
unfold CongA in H3.
spliter.
split; auto.

unfold GtA in *.
spliter.
apply(conga_preserves_lta A1 B1 C1 A B C A1 B1 C1 A' B' C'); auto.
apply conga_refl; auto.
Qed.
perp_out_acute
Proof.
intros.
assert(A <> B /\ C' <> B).
apply out_distinct.
assumption.
spliter.

assert(Perp B C' C C').
apply(perp_col _ A); Perp.
apply out_col in H.
Col.
assert(Per C C' B).
apply perp_in_per.
apply perp_sym in H3.
apply perp_left_comm in H3.
apply perp_perp_in in H3.
apply perp_in_comm.
assumption.
assert(Acute C' C B /\ Acute C' B C).
apply( l11_43 C' C B).

apply perp_left_comm in H3.
apply perp_not_col in H3.
intro.
apply H3.
assert_cols.
ColR.
left.
assumption.
spliter.

assert(C <> B).
intro.
subst C.
apply l8_8 in H4.
subst C'.
apply perp_distinct in H0.
tauto.

assert(CongA C' B C A B C ).
apply(out_conga A B C A B C C' C A C); auto.
apply conga_refl; auto.
apply out_trivial; auto.
apply out_trivial; auto.
apply out_trivial; auto.
apply (acute_conga__acute C' B C); auto.
Qed.
flat_all_lea
Proof.
intros.
unfold LeA.
exists P.
spliter.
split.
unfold InAngle.
repeat split; auto.
exists B.
split; auto.
apply conga_refl; auto.
Qed.
acute_bet_obtuse
Proof.
intros.

assert(A <> C).
intro.
subst C.
apply between_identity in H0.
subst B.
tauto.

assert(A <> B).
unfold Acute in H1.
ex_and H1 A'.
ex_and H3 B'.
ex_and H1 P'.
unfold LtA in H3.
spliter.
unfold LeA in H3.
ex_and H3 X.
apply conga_distinct in H5.
tauto.

assert(D : P <> B).
unfold Acute in H1.
ex_and H1 A'.
ex_and H4 B'.
ex_and H1 Q'.
unfold LtA in H4.
spliter.
unfold LeA in H4.
ex_and H4 X.
apply conga_distinct in H6.
tauto.

induction(Col_dec A B P).
assert(HH:= perp_exists B A B H3).
ex_and HH Q.

assert(HD: Q <> B).
apply perp_distinct in H5.
intro.
subst Q.
tauto.

assert(Per A B Q).
apply perp_in_per.
apply perp_perp_in in H5.
Perp.

unfold Obtuse.
exists A.
exists B.
exists Q.
split; auto.

assert(Out B A P).
apply(col_in_angle_out A B Q); Col.
intro.
apply perp_not_col in H5.
apply H5.
apply bet_col in H7.
Col.

unfold Acute in H1.
ex_and H1 A'.
ex_and H7 B'.
ex_and H1 Q'.

assert(CongA A B Q A' B' Q').
apply l11_16; auto.

intro.
subst B'.
unfold LtA in H7.
spliter.
unfold LeA in H7.
ex_and H7 X.
apply conga_distinct in H9.
tauto.
intro.
subst Q'.
unfold LtA in H7.
spliter.
unfold LeA in H7.
ex_and H7 X.
unfold InAngle in H7.
tauto.

assert(LtA A B P A B Q).

apply(conga_preserves_lta A B P A' B' Q' A B P A B Q).
apply conga_refl;auto.
apply conga_sym.
assumption.
assumption.
unfold InAngle.
repeat split; auto.
unfold LtA in H9.
spliter.
exists A.
split.
Between.
right.

induction H4.

assert(HH:= flat_all_lea A B P H3 D H4).
assert(HP:=HH Q HD).
assert(HQ:=lea_asym A B P A B Q H9 HP).
contradiction.

induction H4.
unfold Out.
repeat split; auto.
unfold Out.
repeat split; auto.
left.
Between.

unfold GtA.
unfold LtA.
split.
unfold LeA.
exists Q.
split.
unfold InAngle.
repeat split; auto.
exists B.
split.

induction H7.
spliter.
induction H9.

apply (outer_transitivity_between _ _ A); Between.
apply (between_inner_transitivity _ _ _ A); Between.
left.
auto.
apply l11_16; Perp.

assert(Perp B C B Q).
apply (perp_col _ A);Perp.
apply bet_col in H0.
Col.
apply perp_in_per.
apply perp_right_comm in H8.
apply perp_perp_in in H8.
Perp.
intro.

assert(HH:= l11_17 A B Q C B P H6 H8).
apply per_not_col in HH; auto.
apply HH.
apply bet_col in  H0.
ColR.

assert(HC:Col A B C).
apply bet_col in H0.
Col.

assert(exists Q : Tpoint, Perp A C Q B /\ OS A C P Q).
apply(l10_15 A C B P); Col.
intro.
apply H4.
ColR.

ex_and H5 Q.
assert(Perp A B Q B).
apply (perp_col _ C); Perp.
Col.
apply perp_left_comm in H7.

assert(~Col B A Q).
apply perp_not_col in H7.
assumption.

assert(Per A B Q).
apply perp_in_per.
apply perp_perp_in in H7.
Perp.

assert(B <> Q).
intro.
subst Q.
apply H8.
Col.


assert(OS B Q A P).
unfold Acute in H1.
ex_and H1 A'.
ex_and H11 B'.
ex_and H1 Q'.
assert(CongA A B Q A' B' Q').
apply l11_16; auto.
unfold LtA in H11.
spliter.
unfold LeA in H11.
ex_and H11 X.
apply conga_distinct in H13.
tauto.
unfold LtA in H11.
spliter.
unfold LeA in H11.
ex_and H11 X.
unfold InAngle in H11.
tauto.

assert(LtA A B P A B Q).
apply(conga_preserves_lta A B P A' B' Q' A B P A B Q ); auto.
apply conga_refl; auto.
apply conga_sym.
assumption.
unfold LtA in H13.
spliter.
unfold LeA in H13.
ex_and H13 P0.

assert(InAngle P A B Q).

apply(conga_preserves_in_angle A B Q P0 A B Q P).
apply conga_refl; auto.
apply conga_sym.
assumption.
assumption.
apply (col_one_side _ C); Col.

unfold InAngle in H16.
spliter.

ex_and H19 X.

induction H20.
subst X.
apply False_ind.
apply H8.
apply bet_col in H19.
Col.

assert(OS Q B A X).
apply out_one_side.
left.
intro.
apply H8.
Col.
repeat split.
intro.
subst Q.
apply l8_8 in H9.
contradiction.
intro.
subst X.
apply H14.
apply conga_sym.
apply(out_conga A B P A B P A Q A P).
apply conga_refl; auto.
apply out_trivial; auto.
apply l6_6.
assumption.
apply out_trivial; auto.
apply out_trivial; auto.
right.
Between.

assert(OS B Q X P).

apply( out_one_side B Q X P).
right.
intro.
apply H14.

apply conga_sym.
apply(out_conga A B P A B P A Q A P).
apply conga_refl; auto.
apply out_trivial; auto.

apply(col_one_side_out _ C).
Col.
apply invert_one_side.

apply(col_one_side _ A); Col.
apply invert_one_side.
assumption.
apply out_trivial; auto.
apply out_trivial; auto.
assumption.
apply invert_one_side in H21.
eapply(one_side_transitivity _ _ _ X); auto.

assert(TS B Q A C).
unfold TS.
repeat split; auto.
intro.
apply H8.
Col.
intro.
apply H8.
ColR.
exists B.
split; Col.

assert(TS B Q P C).
apply(l9_8_2 B Q A P C); auto.

unfold Obtuse.
exists A.
exists B.
exists Q.
split; auto.
unfold GtA.
unfold LtA.

assert(HP:Per C B Q).
assert(Perp B C Q B).
apply(perp_col _ A); Perp.
Col.
apply perp_in_per.
apply perp_perp_in in H14.
Perp.

split.
unfold LeA.
exists Q.
split.
unfold InAngle.
repeat split; auto.
unfold TS in H13.
spliter.
ex_and H15 X.
exists X.
split; Between.
right.

assert(OS C A X P).
apply out_one_side.
right.
intro.
apply H4.
ColR.
repeat split.
intro.
subst X.
contradiction.
intro.
subst P.
apply between_identity in H16.
subst X.
contradiction.
left.
Between.
apply invert_one_side in H17.
assert(OS A C X Q).
apply (one_side_transitivity _ _ _ P); auto.
apply(col_one_side_out B C X Q).
Col.
apply invert_one_side.
apply(col_one_side _ A); Col.
apply invert_one_side.
assumption.
apply l11_16; Perp.

assert(CongA A B Q C B Q).
apply l11_16; Perp.
intro.
assert(CongA C B Q C B P).
apply(conga_trans _ _ _ A B Q); auto.
apply conga_sym.
auto.

unfold Acute in H1.
ex_and H1 A'.
ex_and H17 B'.
ex_and H1 Q'.
assert(CongA A B Q A' B' Q').
apply l11_16; Perp.
intro.
subst B'.
unfold LtA in H17.
spliter.
unfold LeA in H17.
ex_and H17 X.
apply conga_distinct in H19.
tauto.
intro.
subst Q'.
unfold LtA in H17.
spliter.
unfold LeA in H17.
ex_and H17 X.
unfold InAngle in H17.
tauto.
assert(LtA A B P A B Q).
apply(conga_preserves_lta A B P A' B' Q' A B P A B Q); auto.
apply conga_refl; auto.
apply conga_sym; auto.
unfold LtA in H19.
spliter.
apply H20.
apply conga_sym.
apply(l11_13 C B Q C B P A A H16); Between.
Qed.
perp_bet_obtuse
Proof.
intros.
assert(HPO:=perp_out_acute).
assert(HBO:=acute_bet_obtuse).
assert(Col A B C').
apply bet_col in H1.
Col.
assert(Acute C' B C).
apply (HPO _ _ _ C').
apply out_trivial; auto.
apply perp_left_comm.
apply(perp_col _ A); Perp.
Col.
apply (HBO C').
intro.
subst B.
apply perp_distinct in H0.
tauto.
Between.
assumption.
Qed.
lg_exists
Proof.
    intros.
    unfold Q_Cong.
    exists (fun x y => Cong A B x y).
    split.
      exists A.
      exists B.
      intros.
      split; auto.
    Cong.
Qed.
lg_cong
Proof.
    intros.
    unfold Q_Cong in H.
    ex_and H X.
    ex_and H2 Y.
    assert(HH:= H A B).
    destruct HH.
    assert(HH:= H C D).
    destruct HH.
    apply H3 in H0.
    apply H5 in H1.
    apply cong_transitivity with X Y; Cong.
Qed.
lg_cong_lg
Proof.
    intros.
    unfold Q_Cong in H.
    ex_and H A0.
    ex_and H2 B0.
    assert(HP:= H A B).
    assert(HQ:= H C D).
    destruct HP.
    destruct HQ.
    apply H4.
    eapply cong_transitivity.
      apply H3.
      assumption.
    assumption.
Qed.
lg_sym
Proof.
    intros.
    apply (lg_cong_lg l A B); Cong.
Qed.
ex_points_lg
Proof.
    intros.
    unfold Q_Cong in H.
    ex_and H A.
    ex_and H0 B.
    assert(HH:= H A B).
    destruct HH.
    exists A.
    exists B.
    apply H0.
    Cong.
Qed.
is_len_cong
Proof.
    intros.
    unfold Len in *.
    spliter.
    eapply (lg_cong l); auto.
Qed.
is_len_cong_is_len
Proof.
    intros.
    unfold Len in *.
    spliter.
    split.
      auto.
    unfold Q_Cong in H.
    ex_and H a.
    ex_and H2 b.
    assert(HH:= H A B).
    destruct HH.
    assert(HH1:= H C D).
    destruct HH1.
    apply H3 in H1.
    apply H4.
    apply cong_transitivity with A B; trivial.
Qed.
not_cong_is_len
Proof.
    intros.
    unfold Len in H0.
    spliter.
    intro.
    apply H.
    apply (lg_cong l); auto.
Qed.
not_cong_is_len1
Proof.
    intros.
    intro.
    unfold Len in *.
    spliter.
    apply H.
    apply (lg_cong l); auto.
Qed.
lg_null_instance
Proof.
    intros.
    unfold Q_Cong_Null in H.
    spliter.
    unfold Q_Cong in H.
    ex_and H X.
    ex_and H1 Y.
    assert(HH:= H A A).
    destruct HH.
    ex_and H0 P.
    assert(HH:=(H P P)).
    destruct HH.
    apply H4 in H3.
    apply H1.
    apply cong_symmetry in  H3.
    apply cong_reverse_identity in H3.
    subst Y.
    apply cong_trivial_identity.
Qed.
lg_null_trivial
Proof.
    intros.
    unfold Q_Cong_Null.
    split.
      auto.
    exists A.
    auto.
Qed.
lg_null_dec
Proof.
    intros.
    assert(HH:=H).
    unfold Q_Cong in H.
    ex_and H A.
    ex_and H0 B.
    induction(eq_dec_points A B).
      subst B.
      left.
      unfold Q_Cong_Null.
      split.
        auto.
      exists A.
      apply H.
      Cong.
    right.
    intro.
    unfold Q_Cong_Null in H1.
    spliter.
    ex_and H2 P.
    apply H0.
    assert(Cong A B P P).
      apply H; auto.
    apply cong_identity in H2.
    auto.
Qed.
ex_point_lg
Proof.
    intros.
    induction(lg_null_dec l).
      exists A.
      apply lg_null_instance.
      auto.
      assert(HH:= H).
      unfold Q_Cong in HH.
      ex_and HH X.
      ex_and H1 Y.
      assert(HH:= another_point A).
      ex_and HH P.
      assert(HP:= H2 X Y).
      destruct HP.
      assert(l X Y).
        apply H3.
        apply cong_reflexivity.
      assert(X <> Y).
        intro.
        subst Y.
        apply H0.
        unfold Q_Cong_Null.
        split.
          auto.
        exists X.
        auto.
      assert(HH:= segment_construction_3 A P X Y H1 H6).
      ex_and HH B.
      exists B.
      assert(HH:= H2 A B).
      destruct HH.
      apply H9.
      Cong.
    auto.
Qed.
ex_point_lg_out
Proof.
    intros.
    assert(HH:= H0).
    unfold Q_Cong in HH.
    ex_and HH X.
    ex_and H2 Y.
    assert(HP:= H3 X Y).
    destruct HP.
    assert(l X Y).
      apply H2.
      apply cong_reflexivity.
    assert(X <> Y).
      intro.
      subst Y.
      apply H1.
      unfold Q_Cong_Null.
      split.
        auto.
      exists X.
      auto.
    assert(HH:= segment_construction_3 A P X Y H H6).
    ex_and HH B.
    exists B.
    split.
      assert(HH:= H3 A B).
      destruct HH.
      apply H9.
      Cong.
    apply l6_6.
    auto.
Qed.
ex_point_lg_bet
Proof.
    intros.
    assert(HH:= H).
    unfold Q_Cong in HH.
    ex_and HH X.
    ex_and H0 Y.
    assert(HP:= H1 X Y).
    destruct HP.
    assert(l X Y).
      apply H0.
      apply cong_reflexivity.
    prolong A M B X Y.
    exists B.
    split; auto.
    eapply (lg_cong_lg l X Y); Cong.
Qed.
ex_points_lg_not_col
Proof.
    intros.
    assert(HH:=another_point P).
    ex_elim HH A.
    assert(HH:= not_col_exists P A H1).
    ex_elim HH Q.
    exists A.
    assert(A <> Q).
      intro.
      subst Q.
      apply H2.
      Col.
    lg_instance2 l A Q B.
    exists B.
    split.
      auto.
    intro.
    apply H2.
    assert(A <> B).
      intro.
      subst B.
      unfold Out in H5.
      tauto; apply out_col in H5.
    apply out_col in H5.
    ColR.
Qed.
ex_eql
Proof.
    intros.
    ex_and H A.
    ex_and H0 B.
    assert(HH:=H).
    assert(HH0:=H0).
    unfold Len in HH.
    unfold Len in HH0.
    spliter.
    unfold EqL.
    repeat split; auto.
      intro.
      assert(Len A0 B0 l1).
        unfold Len.
        split; auto.
      assert(Cong A B A0 B0).
        apply (is_len_cong _ _ _ _ l1); auto.
      assert(Len A0 B0 l2).
        apply(is_len_cong_is_len A B).
          apply H0.
        auto.
      unfold Len in H8.
      spliter.
      auto.
    intro.
    assert(Len A0 B0 l2).
      unfold Len.
      split; auto.
    assert(Cong A B A0 B0).
      apply (is_len_cong _ _ _ _ l2); auto.
    assert(Len A0 B0 l1).
      apply(is_len_cong_is_len A B).
        apply H.
      auto.
    unfold Len in H8.
    spliter.
    auto.
Qed.
all_eql
Proof.
    intros.
    apply ex_eql.
    exists A.
    exists B.
    split; auto.
Qed.
null_len
Proof.
    intros.
    eapply (all_eql A A).
      apply H.
    eapply (is_len_cong_is_len B B); Cong.
Qed.
eqL_equivalence
Proof.
split.
- unfold Reflexive.
  intros.
  unfold EqL.
  intros.
  tauto.
- unfold Symmetric.
  intros.
  unfold EqL in *.
  firstorder.
- unfold Transitive.
  unfold EqL.
  intros.
  rewrite H.
  apply H0.
Qed.
ex_lg
Proof.
    intros.
    exists (fun C D => Cong A B C D).
    unfold Q_Cong.
    split.
      exists A. exists B.
      tauto.
    Cong.
Qed.
lg_eql_lg
Proof.
    intros.
    unfold EqL in *.
    unfold Q_Cong in *.
    decompose [ex] H.
    exists x. exists x0.
    intros.
    rewrite H2.
    apply H0.
Qed.
ex_eqL
Proof.
intros.
ex_and H1 A.
ex_and H2 B.
unfold EqL.
assert(HH1:= H).
assert(HH2:= H0).

unfold Q_Cong in HH1.
unfold Q_Cong in HH2.
ex_and HH1 A1.
ex_and H3 B1.
ex_and HH2 A2.
ex_and H3 B2.

repeat split; auto.
intro.
assert(HH:= H4 A0 B0).
assert(HP:= H5 A0 B0).
destruct HP.
apply H6.
assert(HP:= H4 A B).
assert(HQ:= H5 A B).
destruct HP.
destruct HQ.
apply H9 in H1.
apply H11 in H2.
destruct HH.
apply H13 in H3.
apply cong_transitivity with A B; trivial.
apply cong_transitivity with A1 B1; Cong.

intro.
assert(HH:= H4 A0 B0).
assert(HP:= H5 A0 B0).
destruct HH.
apply H6.
assert(HH:= H4 A B).
assert(HQ:= H5 A B).
destruct HH.
destruct HQ.
apply H9 in H1.
apply H11 in H2.
destruct HP.
apply H13 in H3.
apply cong_transitivity with A2 B2; trivial.
apply cong_transitivity with A B; Cong.
Qed.
ang_exists
Proof.
    intros.
    exists (fun D E F => CongA A B C D E F).
    split.
      unfold Q_CongA.
      exists A.
      exists B.
      exists C.
      split; auto.
      split; auto.
      intros.
      split.
        auto.
      auto.
    apply conga_refl; auto.
Qed.
ex_points_ang
Proof.
    intros.
    unfold Q_CongA in H.
    ex_and H A.
    ex_and H0 B.
    ex_and H C.
    assert(HH:= H1 A B C).
    destruct HH.
    exists A.
    exists B.
    exists C.
    apply H2.
    apply conga_refl; auto.
Qed.
ang_conga
Proof.
    intros.
    unfold Q_CongA in H.
    ex_and H A0.
    ex_and H2 B0.
    ex_and H C0.
    assert(HH:=H3 A B C).
    assert(HH1:= H3 A' B' C').
    destruct HH.
    destruct HH1.
    apply H5 in H0.
    apply H7 in H1.
    eapply conga_trans.
      apply conga_sym.
      apply H0.
    auto.
Qed.
is_ang_conga
Proof.
    intros.
    unfold Ang in *.
    spliter.
    eapply (ang_conga a); auto.
Qed.
is_ang_conga_is_ang
Proof.
    intros.
    unfold Ang in *.
    spliter.
    split.
      auto.
    unfold Q_CongA in H.
    ex_and H A0.
    ex_and H2 B0.
    ex_and H C0.
    assert(HH:= H3 A B C).
    destruct HH.
    assert(HH1:= H3 A' B' C').
    destruct HH1.
    apply H5 in H1.
    apply H6.
    eapply conga_trans.
      apply H1.
    auto.
Qed.
not_conga_not_ang
Proof.
    intros.
    intro.
    assert(HH:=ang_conga a A B C A' B' C' H H1 H2).
    contradiction.
Qed.
not_conga_is_ang
Proof.
    intros.
    unfold Ang in H0.
    spliter.
    intro.
    apply H.
    apply (ang_conga a); auto.
Qed.
not_cong_is_ang1
Proof.
    intros.
    intro.
    unfold Ang in *.
    spliter.
    apply H.
    apply (ang_conga a); auto.
Qed.
ex_eqa
Proof.
    intros.
    ex_and H A.
    ex_and H0 B.
    ex_and H C.
    assert(HH:=H).
    assert(HH0:=H0).
    unfold Ang in HH.
    unfold Ang in HH0.
    spliter.
    unfold EqA.
    repeat split; auto; intro.
      assert(CongA A B C A0 B0 C0).
        eapply (is_ang_conga _ _ _ _ _ _ a1); auto.
        split; auto.
      assert(Ang A0 B0 C0 a2).
        apply (is_ang_conga_is_ang A B C); auto.
      unfold Ang in H7.
      tauto.
    assert(CongA A B C A0 B0 C0).
      eapply (is_ang_conga _ _ _ _ _ _ a2); auto.
      split; auto.
    assert(Ang A0 B0 C0 a1).
      apply (is_ang_conga_is_ang A B C); auto.
    unfold Ang in H7.
    tauto.
Qed.
all_eqa
Proof.
    intros.
    apply ex_eqa.
    exists A.
    exists B.
    exists C.
    split; auto.
Qed.
is_ang_distinct
Proof.
    intros.
    unfold Ang in H.
    spliter.
    unfold Q_CongA in H.
    ex_and H A0.
    ex_and H1 B0.
    ex_and H C0.
    assert(HH:= H2 A B C).
    destruct HH.
    apply H4 in H0.
    unfold CongA in H0.
    spliter.
    tauto.
Qed.
null_ang
Proof.
    intros.
    eapply (all_eqa A B A).
      apply H.
    eapply (is_ang_conga_is_ang C D C).
      auto.
    eapply l11_21_b.
      apply out_trivial.
      apply is_ang_distinct in H0.
      tauto.
    apply out_trivial.
    apply is_ang_distinct in H.
    tauto.
Qed.
flat_ang
Proof.
    intros.
    eapply (all_eqa A B C).
      apply H1.
    eapply (is_ang_conga_is_ang A' B' C').
      apply H2.
    apply is_ang_distinct in H1.
    apply is_ang_distinct in H2.
    spliter.
    eapply conga_line; auto.
Qed.
ang_distinct:
Proof.
    intros.
    assert(Ang A B C a).
      split; auto.
    apply (is_ang_distinct _ _ _ a); auto.
Qed.
ex_ang
Proof.
    intros.
    exists (fun X Y Z => CongA A B C X Y Z).
    unfold Q_CongA.
    split.
      exists A.
      exists B.
      exists C.
      split.
        auto.
      split.
        auto.
      intros.
      split.
        intro.
        auto.
      intro.
      auto.
    apply conga_refl; auto.
Qed.
anga_exists
Proof.
    intros.
    exists (fun D E F => CongA A B C D E F).
    split.
      unfold Q_CongA.
      exists A.
      exists B.
      exists C.
      split.
        auto.
      intros.
      split; auto.
    apply conga_refl; auto.
Qed.
anga_is_ang
Proof.
    intros.
    unfold Q_CongA_Acute in H.
    unfold Q_CongA.
    ex_and H A.
    ex_and H0 B.
    ex_and H C.
    exists A.
    exists B.
    exists C.
    apply acute_distincts in H.
    spliter.
    split.
      auto.
    split.
      auto.
    intros.
    split.
      intro.
      assert(Ang X Y Z a).
        unfold Ang.
        split.
          unfold Q_CongA.
          exists A.
          exists B.
          exists C.
          split.
            assumption.
          split.
            assumption.
          auto.
        assert(HH:= H0 X Y Z).
        apply HH.
        auto.
      unfold Ang in H3.
      spliter.
      auto.
    intro.
    apply H0.
    auto.
Qed.
ex_points_anga
Proof.
    intros.
    assert(HH:=H).
    apply anga_is_ang in H.
    ang_instance a A B C.
    exists A.
    exists B.
    exists C.
    assumption.
Qed.
anga_conga
Proof.
    intros.
    apply (ang_conga a); auto.
    apply anga_is_ang.
    auto.
Qed.
is_anga_to_is_ang
Proof.
    intros.
    unfold Ang_Acute in H.
    unfold Ang.
    spliter.
    split.
      apply anga_is_ang.
      auto.
    auto.
Qed.
is_anga_conga
Proof.
    intros.
    unfold Ang_Acute in *.
    spliter.
    apply (anga_conga a); auto.
Qed.
is_anga_conga_is_anga
Proof.
    intros.
    unfold Ang_Acute in *.
    spliter.
    split.
      auto.
    apply anga_is_ang in H.
    unfold Q_CongA in H.
    ex_and H A0.
    ex_and H2 B0.
    ex_and H C0.
    assert(HH:= H3 A B C).
    destruct HH.
    assert(HH1:= H3 A' B' C').
    destruct HH1.
    apply H5 in H1.
    apply H6.
    eapply conga_trans.
      apply H1.
    auto.
Qed.
not_conga_is_anga
Proof.
    intros.
    unfold Ang_Acute in H0.
    spliter.
    intro.
    apply H.
    apply (anga_conga a); auto.
Qed.
not_cong_is_anga1
Proof.
    intros.
    intro.
    unfold Ang_Acute in *.
    spliter.
    apply H.
    apply (anga_conga a); auto.
Qed.
ex_eqaa
Proof.
    intros.
    apply ex_eqa.
    ex_and H A.
    ex_and H0 B.
    ex_and H C.
    exists A.
    exists B.
    exists C.
    split; apply is_anga_to_is_ang; auto.
Qed.
all_eqaa
Proof.
    intros.
    apply ex_eqaa.
    exists A.
    exists B.
    exists C.
    split; auto.
Qed.
is_anga_distinct
Proof.
    intros.
    apply (is_ang_distinct A B C a).
    apply is_anga_to_is_ang.
    auto.
Qed.
eqA_equivalence
Proof.
split.
unfold Reflexive.
intros.
unfold EqA.
intros;tauto.
unfold Symmetric, EqA.
intros.
firstorder.
unfold Transitive, EqA.
intros.
rewrite H.
apply H0.
Qed.
null_anga
Proof.
    intros.
    eapply (all_eqaa A B A).
      apply H.
    eapply (is_anga_conga_is_anga C D C).
      auto.
    eapply l11_21_b.
      apply out_trivial.
      apply is_anga_distinct in H0.
      tauto.
    apply out_trivial.
    apply is_anga_distinct in H.
    tauto.
Qed.
anga_distinct:
Proof.
    intros.
    assert(Ang_Acute A B C a).
      split; auto.
    apply (is_anga_distinct _ _ _ a); auto.
Qed.
out_is_len_eq
Proof.
    intros.
    assert(Cong A B A C).
      apply (is_len_cong _ _ _ _ l); auto.
    assert(A <> C).
      unfold Out in H.
      spliter.
      auto.
    eapply (l6_11_uniqueness A A C C ); Cong.
    apply out_trivial.
    auto.
Qed.
out_len_eq
Proof.
    intros.
    apply (out_is_len_eq A _ _ l).
      auto.
      split; auto.
    split; auto.
Qed.
ex_anga
Proof.
    intros.
    exists (fun X Y Z => CongA A B C X Y Z).
    unfold Q_CongA_Acute.
    assert (HH := acute_distincts A B C H).
    spliter.
    split.
      exists A.
      exists B.
      exists C.
      split; auto.
      intros.
      intros.
      split.
        intro.
        auto.
      intro.
      auto.
    apply conga_refl; auto.
Qed.
not_null_ang_ang
Proof.
    intros.
    unfold Q_CongA_nNull  in H.
    spliter; auto.
Qed.
not_null_ang_def_equiv
Proof.
    intros.
    split.
      intro.
      unfold Q_CongA_nNull in H.
      spliter.
      assert(HH:= H).
      unfold Q_CongA in HH.
      ex_and HH A.
      ex_and H1 B.
      ex_and H2 C.
      split.
        auto.
      exists A.
      exists B.
      exists C.
      assert(HH:= H3 A B C).
      destruct HH.
      assert(a A B C).
        apply H4.
        apply conga_refl; auto.
      split.
        auto.
      apply (H0 A B C).
      auto.
    intros.
    spliter.
    ex_and H0 A.
    ex_and H1 B.
    ex_and H0 C.
    unfold Q_CongA_nNull.
    split; auto.
    intros.
    assert(CongA A0 B0 C0 A B C).
      apply (ang_conga a); auto.
    intro.
    apply H1.
    apply (out_conga_out A0 B0 C0); auto.
Qed.
not_flat_ang_def_equiv
Proof.
    intros.
    split.
      intro.
      unfold Q_CongA_nFlat in H.
      spliter.
      assert(HH:= H).
      unfold Q_CongA in HH.
      ex_and HH A.
      ex_and H1 B.
      ex_and H2 C.
      split.
        auto.
      exists A.
      exists B.
      exists C.
      assert(HH:= H3 A B C).
      destruct HH.
      assert(a A B C).
        apply H4.
        apply conga_refl; auto.
      split.
        auto.
      apply (H0 A B C).
      auto.
    intros.
    spliter.
    ex_and H0 A.
    ex_and H1 B.
    ex_and H0 C.
    unfold Q_CongA_nFlat.
    split; auto.
    intros.
    assert(CongA A0 B0 C0 A B C).
      apply (ang_conga a); auto.
    intro.
    apply H1.
    apply (bet_conga_bet A0 B0 C0); auto.
Qed.
ang_const
Proof.
    intros.
    unfold Q_CongA in H.
    ex_and H A0.
    ex_and H1 B0.
    ex_and H C0.
    apply(swap_diff) in H1.
    assert(HH:= H2 A0 B0 C0).
    destruct HH.
    assert(a A0 B0 C0).
      apply H3.
      apply conga_refl; auto.
    assert(HH :=not_col_exists A B H0).
    ex_and HH P.
    induction(eq_dec_points A0 C0).
      subst C0.
      exists A.
      assert(HH:= (H2 A B A)).
      destruct HH.
      apply H7.
      apply conga_trivial_1; auto.
    assert(HH:=angle_construction_2 A0 B0 C0 A B P H H7 H1).
    ex_and HH C; auto.
    exists C.
    apply H2.
    auto.
Qed.
ang_sym
Proof.
    intros.
    unfold Q_CongA in H.
    ex_and H A0.
    ex_and H1 B0.
    ex_and H C0.
    assert(HH:= H2 A B C).
    destruct HH.
    apply H4 in H0.
    apply conga_right_comm in H0.
    assert(HH:= H2 C B A).
    destruct HH.
    apply H5.
    auto.
Qed.
ang_not_null_lg
Proof.
    intros.
    intro.
    unfold Q_CongA in H.
    unfold Q_Cong_Null in H3.
    spliter.
    unfold Q_Cong in H0.
    ex_and H A0.
    ex_and H5 B0.
    ex_and H C0.
    assert(HH:= H6 A B C).
    destruct HH.
    assert(CongA A0 B0 C0 A B C).
      apply H8.
      auto.
    apply conga_distinct in H8.
      spliter.
      ex_and H0 A1.
      ex_and H14 B1.
      assert(HH:= H0 A B).
      destruct HH.
      ex_and H4 A'.
      assert(HH:= H0 A' A').
      destruct HH.
      assert(Cong A1 B1 A' A').
        apply H17.
        auto.
      assert(Cong A1 B1 A B).
        apply H15.
        auto.
      apply cong_identity in H17.
        subst B1.
        apply cong_symmetry in H19.
        apply cong_identity in H19.
        contradiction.
      auto.
    auto.
Qed.
ang_distincts
Proof.
    intros.
    assert(HH:= ex_lg A B).
    ex_and HH la.
    assert(HH:= ex_lg C B).
    ex_and HH lc.
    assert(HH:= ang_not_null_lg a la A B C H H1 H0 H2).
    assert(a C B A).
      apply ang_sym; auto.
    assert(HQ:= ang_not_null_lg a lc C B A H H3 H5 H4).
    split; intro; subst B.
      apply HH.
      unfold Q_Cong_Null.
      split.
        auto.
      exists A.
      auto.
    apply HQ.
    unfold Q_Cong_Null.
    split.
      auto.
    exists C.
    auto.
Qed.
anga_sym
Proof.
    intros.
    unfold Q_CongA_Acute in H.
    ex_and H A0.
    ex_and H1 B0.
    ex_and H C0.
    assert(HH:= H1 A B C).
    destruct HH.
    apply H3 in H0.
    apply conga_right_comm in H0.
    assert(HH:= H1 C B A).
    destruct HH.
    apply H4.
    auto.
Qed.
anga_not_null_lg
Proof.
    intros.
    intro.
    unfold Q_CongA_Acute in H.
    unfold Q_Cong_Null in H3.
    spliter.
    unfold Q_Cong in H0.
    ex_and H A0.
    ex_and H5 B0.
    ex_and H C0.
    assert(HH:= H5 A B C).
    destruct HH.
    assert(CongA A0 B0 C0 A B C).
      apply H7.
      auto.
    apply conga_distinct in H8.
    spliter.
    ex_and H0 A1.
    ex_and H13 B1.
    assert(HH:= H0 A B).
    destruct HH.
    ex_and H4 A'.
    assert(HH:= H0 A' A').
    destruct HH.
    assert(Cong A1 B1 A' A').
      apply H16.
      auto.
    assert(Cong A1 B1 A B).
      apply H14.
      auto.
    apply cong_identity in H17.
    subst B1.
    apply cong_symmetry in H18.
    apply cong_identity in H18.
    contradiction.
Qed.
anga_distincts
Proof.
    intros.
    assert(HH:= ex_lg A B).
    ex_and HH la.
    assert(HH:= ex_lg C B).
    ex_and HH lc.
    assert(HH:= anga_not_null_lg a la A B C H H1 H0 H2).
    assert(a C B A).
      apply anga_sym; auto.
    assert(HQ:= anga_not_null_lg a lc C B A H H3 H5 H4).
    split; intro; subst B.
      apply HH.
      unfold Q_Cong_Null.
      split.
        auto.
      exists A.
      auto.
    apply HQ.
    unfold Q_Cong_Null.
    split.
      auto.
    exists C.
    auto.
Qed.
ang_const_o
Proof.
    intros.
    assert(HH:= H0).
    unfold Q_CongA in HH.
    ex_and HH A0.
    ex_and H3 B0.
    ex_and H4 C0.
    apply(swap_diff) in H4.
    assert(HH:= H5 A0 B0 C0).
    destruct HH.
    assert(a A0 B0 C0).
      apply H6.
      apply conga_refl; auto.
    assert(HH:=ang_distincts a A0 B0 C0 H0 H8).
    assert(A0 <> C0).
      intro.
      subst C0.
      unfold Q_CongA_nNull in H1.
      spliter.
      assert(HH:=H11 A0 B0 A0 H8).
      apply HH.
      apply out_trivial; auto.
    spliter.
    assert(A <> B).
      intro.
      subst B.
      apply H.
      Col.
    assert(HH:=angle_construction_2 A0 B0 C0 A B P H10 H9 H4).
    ex_and HH C; auto.
    exists C.
    assert(a A B C).
      assert(HH:= H5 A B C).
      destruct HH.
      apply H15.
      auto.
    split.
      auto.
    induction H14.
      auto.
    unfold Q_CongA_nNull in H1.
    spliter.
    assert(HH:= H16 A B C H15).
    unfold Q_CongA_nFlat in H2.
    spliter.
    assert(Hh:=H17 A B C H15).
    apply False_ind.
    assert(HH0:=ang_distincts a A B C H0 H15).
    spliter.
    assert(HP:=or_bet_out A B C).
    induction HP.
      contradiction.
    induction H20.
      contradiction.
    contradiction.
Qed.
anga_const
Proof.
    intros.
    apply anga_is_ang in H.
    apply ang_const; auto.
Qed.
null_anga_null_anga'
Proof.
    intro.
    split.
      intro.
      unfold Q_CongA_Null_Acute in H.
      unfold is_null_anga'.
      spliter.
      split.
        auto.
      anga_instance a A B C.
      assert(HH:= H0 A B C H1).
      exists A.
      exists B.
      exists C.
      split; auto.
    intro.
    unfold is_null_anga' in H.
    unfold Q_CongA_Null_Acute.
    spliter.
    ex_and H0 A.
    ex_and H1 B.
    ex_and H0 C.
    split; auto.
    intros.
    assert(CongA A B C A0 B0 C0).
      apply (anga_conga a); auto.
    apply (out_conga_out A B C); auto.
Qed.
is_null_anga_out
Proof.
    intros.
    unfold Q_CongA_Null_Acute in H1.
    spliter.
    assert(HH:= (H2 A B C)).
    apply HH.
    auto.
Qed.
acute_not_bet
Proof.
    intros.
    unfold Acute in H.
    ex_and H A0.
    ex_and H0 B0.
    ex_and H C0.
    unfold LtA in H0.
    spliter.
    unfold LeA in H0.
    ex_and H0 P.
    unfold InAngle in H0.
    spliter.
    ex_and H5 X.
    intro.
    apply conga_distinct in H2.
    spliter.
    assert(A<>C) by (intro; Between).
    induction H6.
      subst X.
      apply H1.
      apply conga_line; auto.
    assert(Bet A0 B0 P).
      apply (bet_conga_bet A B C); auto.
    assert(Bet A0 B0 C0).
      unfold Out in H6.
      spliter.
      induction H15.
        eBetween.
      eBetween.
    apply H1.
    apply (conga_line A B C); auto.
Qed.
anga_acute
Proof.
    intros.
    unfold Q_CongA_Acute in H.
    ex_and H A0.
    ex_and H1 B0.
    ex_and H C0.
    assert(HH:= acute_lea_acute A B C A0 B0 C0).
    apply HH.
      auto.
    unfold LeA.
    exists C0.
    split.
      unfold InAngle.
      apply acute_distincts in H.
      spliter.
      repeat split; auto.
      exists C0.
      split.
        Between.
      right.
      apply out_trivial.
      auto.
    assert(HP:= H1 A B C).
    destruct HP.
    apply conga_sym.
    apply H3.
    auto.
Qed.
acute_col_out
Proof.
    intros.
    assert(HH:= acute_not_bet A B C H).
    induction H0.
      contradiction.
    unfold Out.
    apply acute_distincts in H.
    spliter.
    repeat split; auto.
    induction H0.
      right.
      auto.
    left.
    Between.
Qed.
not_null_not_col
Proof.
    intros.
    intro.
    apply H0.
    unfold Q_CongA_Null_Acute.
    split.
      auto.
    assert(Acute A B C).
      apply (anga_acute a); auto.
    intros.
    assert(Out B A C).
      apply acute_col_out; auto.
    assert(HH:= anga_conga a A B C A0 B0 C0 H H1 H4).
    apply (out_conga_out A B C); auto.
Qed.
ang_cong_ang
Proof.
    intros.
    assert(Ang A B C a).
      unfold Ang.
      split; auto.
    assert(Ang A' B' C' a).
      apply (is_ang_conga_is_ang A B C); auto.
    unfold Ang in H3.
    tauto.
Qed.
is_null_ang_out
Proof.
    intros.
    unfold Q_CongA_Null in H1.
    spliter.
    assert(HH:= (H2 A B C)).
    apply HH.
    auto.
Qed.
out_null_ang
Proof.
    intros.
    unfold Q_CongA_Null.
    split.
      auto.
    intros.
    assert(HH:=out_conga_out A B C A0 B0 C0 H1).
    apply HH.
    apply (ang_conga a); auto.
Qed.
bet_flat_ang
Proof.
    intros.
    unfold Ang_Flat.
    split.
      auto.
    intros.
    assert(HH:=bet_conga_bet A B C A0 B0 C0 H1).
    apply HH.
    apply (ang_conga a); auto.
Qed.
out_null_anga
Proof.
    intros.
    unfold Q_CongA_Null_Acute.
    split.
      auto.
    intros.
    assert(HH:=out_conga_out A B C A0 B0 C0 H1).
    apply HH.
    apply (anga_conga a); auto.
Qed.
anga_not_flat
Proof.
    intros.
    unfold Q_CongA_nFlat.
    split.
      apply anga_is_ang in H.
      auto.
    intros.
    assert(HH:= anga_acute a A B C H H0).
    unfold Q_CongA_Acute in H.
    ex_and H A0.
    ex_and H1 B0.
    ex_and H C0.
    assert(HP:= H1 A B C).
    apply acute_not_bet.
    auto.
Qed.
anga_const_o
Proof.
    intros.
    assert(Q_CongA a).
      apply anga_is_ang; auto.
    assert(Q_CongA_nNull a).
      unfold Q_CongA_nNull.
      split.
        auto.
      intros A' B' C' HP.
      intro.
      apply H0.
      eapply (out_null_anga a A' B' C'); auto.
    assert(Q_CongA_nFlat a).
      apply anga_not_flat.
      auto.
    assert(HH:= ang_const_o a A B P H H2 H3 H4).
    auto.
Qed.
anga_conga_anga
Proof.
    intros.
    unfold Q_CongA_Acute in H.
    ex_and H A0.
    ex_and H2 B0.
    ex_and H C0.
    assert(HH := H2 A B C).
    assert(HP := H2 A' B' C').
    destruct HH.
    destruct HP.
    apply H4 in H0.
    assert(CongA A0 B0 C0 A' B' C').
      eapply conga_trans.
        apply H0.
      apply H1.
    apply H5.
    auto.
Qed.
anga_out_anga
Proof.
    intros.
    assert(HH:= H).
    unfold Q_CongA_Acute in HH.
    ex_and HH A0.
    ex_and H3 B0.
    ex_and H4 C0.
    assert(HP:= H4 A B C).
    destruct HP.
    assert(CongA A0 B0 C0 A B C).
      apply H6.
      auto.
    assert(HP:= anga_distincts a A B C H H0).
    spliter.
    assert(CongA A B C A' B C').
      apply (out_conga A B C A B C).
        apply conga_refl; auto.
        apply out_trivial; auto.
        apply out_trivial; auto.
        auto.
      auto.
    assert(HH:= H4 A' B C').
    destruct HH.
    apply H11.
    apply (conga_trans _ _ _ A B C); auto.
Qed.
out_out_anga
Proof.
    intros.
    assert(CongA A B C A' B' C').
      apply l11_21_b; auto.
    apply (anga_conga_anga a A B C); auto.
Qed.
is_null_all
Proof.
    intros.
    unfold Q_CongA_Null_Acute in H0.
    spliter.
    assert(HH:= H0).
    unfold Q_CongA_Acute in HH.
    ex_and HH A0.
    ex_and H2 B0.
    ex_and H3 C0.
    apply acute_distincts in H2.
    spliter.
    apply H3.
    assert (a A0 B0 C0).
      apply H3.
      apply conga_refl; auto.
    assert(HH:= (H1 A0 B0 C0 H5)).
    apply l11_21_b; auto.
    apply out_trivial.
    auto.
Qed.
anga_col_out
Proof.
    intros.
    assert(Acute A B C).
      apply (anga_acute a); auto.
    unfold Col in H1.
    induction H1.
      apply acute_not_bet in H2.
      contradiction.
    unfold Out.
    apply (anga_distinct a A B C) in H.
      spliter.
      repeat split; auto.
      induction H1.
        right.
        auto.
      left.
      Between.
    auto.
Qed.
ang_not_lg_null
Proof.
    intros.
    assert(HH:=ang_distincts a A B C H1 H4).
    spliter.
    split.
      intro.
      unfold Q_Cong_Null in H7.
      spliter.
      ex_and H8 P.
      assert(HH:= lg_cong la A B P P H H2 H9).
      apply cong_identity in HH.
      contradiction.
    intro.
    unfold Q_Cong_Null in H7.
    spliter.
    ex_and H8 P.
    assert(HH:= lg_cong lc C B P P H0 H3 H9).
    apply cong_identity in HH.
    contradiction.
Qed.
anga_not_lg_null
Proof.
    intros.
    apply anga_is_ang in H1.
    apply(ang_not_lg_null a la lc A B C); auto.
Qed.
anga_col_null
Proof.
    intros.
    assert(HH:= anga_distincts a A B C H H0).
    spliter.
    assert(Out B A C).
      induction H1.
        assert(HP:=anga_acute a A B C H H0).
        assert(HH:=acute_not_bet A B C HP).
        contradiction.
      induction H1.
        unfold Out.
        repeat split; auto.
      unfold Out.
      repeat split; auto.
      left.
      Between.
    split.
      auto.
    apply (out_null_anga a A B C); auto.
Qed.
eqA_preserves_ang:
Proof.
intros.
unfold Q_CongA in *.
decompose [ex and] H.
exists x. exists x0. exists x1.
split.
assumption.
split.
assumption.
intros.
rewrite H4.
unfold EqA in H0.
apply H0.
Qed.
eqA_preserves_anga
Proof.
    intros.
    assert (Q_CongA a).
        apply eqA_preserves_ang with b;auto.
        symmetry;auto.
    unfold EqA in H1.
    anga_instance a A B C.

    assert(HH:= H1 A B C).
    destruct HH.
    unfold Q_CongA_Acute.
    exists A.
    exists B.
    exists C.
    split.
      unfold Q_CongA_Acute in H.
      ex_and H A'.
      ex_and H6 B'.
      ex_and H C'.
      assert(a A' B' C').
        assert(HP:= H6 A B C).
        destruct HP.
        assert(CongA A B C A' B' C') by (apply conga_sym;auto).
        assert(HP:=is_ang_conga_is_ang A B C A' B' C' a).
        assert(Ang A' B' C' a).
          apply HP.
            split; auto.
          auto.
        unfold Ang in H10.
        spliter.
        auto.
      apply (acute_lea_acute _ _ _ A' B' C').
        auto.
      unfold LeA.
      exists C'.
      split.
        assert (HH:= is_ang_distinct A' B' C' a).
        assert( A' <> B' /\ C' <> B').
          apply HH.
          split; auto.
        spliter.
        apply in_angle_trivial_2; auto.
      eapply (is_ang_conga _ _ _ _ _ _ a).
        split; auto.
      split; auto.
    intros.
    split.
      intro.
      assert(HH:= H1 X Y Z).
      destruct HH.
      assert(Ang X Y Z a).
        eapply (is_ang_conga_is_ang A B C).
          split; auto.
        auto.
      unfold Ang in H9.
      spliter.
      auto.
    intro.
    assert(HH:= H1 X Y Z).
    destruct HH.
    assert(a X Y Z).
      auto.
    eapply (is_ang_conga _ _ _ _ _ _ a).
      split; auto.
    split; auto.
Qed.
l13_6
Proof.
    intros.
    unfold Lcos in *.
    spliter.
    ex_and H6 X1.
    ex_and H7 Y1.
    ex_and H6 Z1.
    ex_and H3 X2.
    ex_and H10 Y2.
    ex_and H3 Z2.
    clean_duplicated_hyps.
    assert(Len X1 Z1 l).
      split; auto.
    assert(Len X2 Z2 l).
      split; auto.
    assert(Cong X1 Z1 X2 Z2).
      eapply (is_len_cong _ _ _ _ l); auto.
    assert(Ang_Acute Y1 X1 Z1 a).
      split; auto.
    assert(Ang_Acute Y2 X2 Z2 a).
      split; auto.
    assert(CongA Y1 X1 Z1 Y2 X2 Z2).
      apply (is_anga_conga _ _ _ _ _ _ a); split; auto.
    assert(Len X1 Y1 lc).
      split; auto.
    assert(Len X2 Y2 ld).
      split; auto.
    induction(eq_dec_points Z1 Y1).
      subst Z1.
      assert(Out X2 Y2 Z2).
        apply (eq_conga_out Y1 X1); auto.
      assert(Y2 = Z2).
        assert(Z2 = Y2 \/ X2 = Y2).
          apply l8_9.
            auto.
          apply out_col in H19.
          Col.
        induction H20.
          auto.
        unfold Out in H19.
        spliter.
        subst Y2.
        tauto.
      subst Z2.
      assert(EqL l lc).
        apply ex_eql.
        exists X1.
        exists Y1.
        split; auto.
      assert(EqL l ld).
        apply ex_eql.
        exists X2.
        exists Y2.
        split; auto.
     transitivity l;auto.
     symmetry; auto.
    assert(Z2 <> Y2).
      intro.
      subst Z2.
      assert(Out X1 Y1 Z1).
        apply (eq_conga_out Y2 X2).
        apply conga_sym.
        auto.
      assert(Y1 = Z1).
        assert(Z1 = Y1 \/ X1 = Y1).
          apply l8_9.
            auto.
          apply out_col in H20.
          Col.
        induction H21.
          auto.
        subst Y1.
        unfold Out in H20.
        spliter.
        tauto.
      subst Z1.
      tauto.
    apply conga_distinct in H16.
    spliter.
    assert(CongA X1 Y1 Z1 X2 Y2 Z2).
      apply l11_16; Perp; auto.
    assert(~Col Z1 X1 Y1).
      intro.
      assert(X1 = Y1 \/ Z1 = Y1).
        apply l8_9.
          Perp.
        Col.
      induction H27.
        subst Y1.
        tauto.
      contradiction.
    apply conga_comm in H16.
    apply cong_commutativity in H13.
    assert(HH:=l11_50_2 Z1 X1 Y1 Z2 X2 Y2 H26 H25 H16 H13).
    spliter.
    apply ex_eql.
    exists X1.
    exists Y1.
    split.
      auto.
    eapply is_len_cong_is_len.
      apply H18.
    Cong.
Qed.
null_lcos_eql
Proof.
    intros.
    unfold Lcos in H.
    spliter.
    ex_and H3 A.
    ex_and H4 B.
    ex_and H3 C.
    unfold Q_CongA_Null_Acute in H0.
    spliter.
    assert(HH:= H7 B A C H6).
    assert(Col A B C) by (apply out_col;auto).
    assert(Col C B A) by Col.
    assert(HQ:= l8_9 C B A H3 H9).
    induction HQ.
      subst C.
      apply (all_eql A B).
        split; auto.
      split; auto.
    subst B.
    exfalso.
    unfold Out in HH.
    tauto.
Qed.
eql_lcos_null
Proof.
    intros.
    unfold Lcos in H.
    spliter.
    ex_and H3 B.
    ex_and H4 A.
    ex_and H3 C.
    assert(forall A0 B0 : Tpoint, l A0 B0 <-> lp A0 B0).
      apply H0; auto.
    assert(HP:= (H7 B A)).
    assert(HQ:= (H7 B C)).
    destruct HP.
    destruct HQ.
    assert(l B C).
      apply H11.
      auto.
    assert(lp B A).
      apply H8.
      auto.
    clear H7 H8 H9 H10 H11.
    assert(Cong B A B C).
      apply (lg_cong l); auto.
    unfold Per in H3.
    ex_and H3 B'.
    assert(HH:= anga_distinct a A B C H2 H6).
    spliter.
    assert(A = C).
      eapply (l4_18 B B').
        intro.
        subst B'.
        apply l7_3 in H3.
        contradiction.
        unfold Midpoint in H3; assert(HH:= midpoint_col).
        spliter.
        apply bet_col in H3.
        Col.
        auto.
      unfold Midpoint in H3.
      spliter.
      eapply cong_transitivity.
        apply cong_symmetry.
        apply cong_commutativity.
        apply H11.
      eapply cong_transitivity.
        apply cong_commutativity.
        apply H7.
      Cong.
    subst C.
    unfold Q_CongA_Null_Acute.
    split.
      auto.
    intros A0 B0 C0 HP.
    apply (eq_conga_out A B).
    apply (anga_conga a); auto.
Qed.
lcos_lg_not_null:
Proof.
    intros.
    unfold Lcos in H.
    spliter.
    ex_and H2 A.
    ex_and H3 B.
    ex_and H2 C.
    assert(HH:= anga_distinct a B A C H1 H5).
    spliter.
    unfold Q_Cong_Null.
    split; intro; spliter; ex_and H9 X.
      assert (Cong A B X X) by (apply (lg_cong l); auto).
      treat_equalities;intuition.
    assert(Cong A C X X) by (apply (lg_cong lp); auto).
    treat_equalities;intuition.
Qed.
perp_acute_out
Proof.
    intros.
    assert (HH:= H).
    unfold Acute in HH.
    ex_and HH A0.
    ex_and H2 B0.
    ex_and H3 C0.
    assert(HH:=H3).
    unfold LtA in HH.
    spliter.
    unfold LeA in H4.
    ex_and H4 P0.
    apply conga_distinct in H6.
    spliter.
    assert(C' <> B).
      intro.
      subst C'.
      assert(Per A B C).
        apply perp_in_per.
        apply perp_in_comm.
        apply perp_perp_in; auto.
        Perp.
      unfold InAngle in H4.
      spliter.
      apply H5.
      apply l11_16; auto.
    induction H1.
      apply False_ind.
      assert(HH:= H4).
      unfold InAngle in HH.
      spliter.
      ex_and H15 X.
      induction H16.
        subst X.
        assert(~ Col A0 B0 C0).
          apply per_not_col; auto.
        assert(Col A0 B0 C0).
          apply bet_col.
          auto.
        contradiction.
      assert(LeA A B C A0 B0 C0).
        unfold LtA in H3.
        spliter.
        auto.
      assert(HQ:= l11_29_a A B C A0 B0 C0 H17).
      ex_and HQ Q.
      assert(Per A B Q).
        apply (l11_17 A0 B0 C0).
          auto.
        apply conga_sym.
        auto.
      assert(Perp_at B Q B A B).
        apply perp_in_right_comm.
        apply per_perp_in.
          apply conga_distinct in H19.
          spliter.
          auto.
          auto.
        apply l8_2.
        auto.
      assert(HH:= perp_in_perp_bis Q  B A B B H21).
      induction HH.
        apply perp_distinct in H22.
        tauto.
      assert(HH:= l12_9 Q B  C C' A B).
      assert(Par Q B C C').
        apply HH; Perp.
      assert(OS B Q C C').
        apply l12_6.
        induction H23.
          apply par_strict_left_comm.
          auto.
        spliter.
        apply False_ind.
        assert(~Col B C' C).
          apply per_not_col; auto.
          apply perp_in_per.
          apply perp_in_comm.
          apply perp_perp_in.
          apply perp_comm.
          apply (perp_col _ A); Perp.
          apply bet_col in H1.
          Col.
        apply H27.
        Col.
      assert(OS Q B C A).
        eapply in_angle_one_side.
          intro.
          assert(~ Col B Q A).
            apply( perp_not_col).
            Perp.
          apply H26.
          Col.
          intro.
          apply H11.
          eapply (l8_18_uniqueness A B Q).
            intro.
            assert(~Col B A Q).
              apply perp_not_col.
              Perp.
            apply H27.
            Col.
            apply bet_col in H1.
            Col.
            apply perp_sym.
            apply perp_left_comm.
            eapply (perp_col _ C).
              intro.
              subst Q.
              unfold OS in H24.
              ex_and H24 T.
              unfold TS in H26.
              spliter.
              apply H26.
              Col.
              Perp.
            unfold Par in H23.
            induction H23.
              apply False_ind.
              apply H23.
              exists C.
              split; Col.
            spliter.
            Col.
            Col.
          Perp.
        apply l11_24.
        auto.
      apply invert_one_side in H25.
      assert(OS B Q A C').
        eapply one_side_transitivity.
          apply one_side_symmetry.
          apply H25.
        assumption.
      assert(~ Col B A Q).
        apply perp_not_col.
        Perp.
      assert(TS B Q A C').
        unfold TS.
        repeat split; auto.
          apply perp_distinct in H22.
          spliter.
          auto.
          intro.
          apply H27.
          Col.
          intro.
          apply H27.
          apply bet_col in H1.
          ColR.
        exists B.
        split.
          Col.
        auto.
      apply l9_9_bis in H26.
      contradiction.
    unfold Out.
    repeat split; auto.
    induction H1.
      right.
      auto.
    left.
    Between.
Qed.
perp_out__acute
Proof.
    intros.
    split.
      intro.
      apply (perp_acute_out _ _ C); auto.
    intro.
    apply (perp_out_acute _ _ C C'); auto.
Qed.
obtuse_not_acute
Proof.
    intros.
    intro.
    unfold Obtuse in H.
    unfold Acute in H0.
    ex_and H A0.
    ex_and H1 B0.
    ex_and H C0.
    ex_and H0 A1.
    ex_and H2 B1.
    ex_and H0 C1.
    assert(A0 <> B0 /\ C0 <> B0 /\ A1 <> B1 /\ C1 <> B1 /\ A <> B /\ C <> B).
      unfold GtA in H1.
      unfold LtA in *.
      unfold LeA in *.
      spliter.
      ex_and H1 P0.
      ex_and H2 P.
      unfold InAngle in H2.
      unfold CongA in H5 .
      unfold CongA in H6 .
      spliter.
      repeat split; auto.
    spliter.
    assert(CongA A0 B0 C0 A1 B1 C1).
      apply l11_16; auto.
    assert(GtA A B C A1 B1 C1).
      apply (conga_preserves_gta A B C A0 B0 C0).
        apply conga_refl; auto.
        auto.
      assumption.
    assert(HH:=not_lta_and_gta A B C A1 B1 C1).
    apply HH.
    split; auto.
Qed.
acute_not_obtuse
Proof.
    intros.
    intro.
    apply obtuse_not_acute in H0.
    contradiction.
Qed.
perp_obtuse_bet
Proof.
    intros.
    assert(HH:= H1).
    unfold Obtuse in HH.
    ex_and HH A0.
    ex_and H2 B0.
    ex_and H3 C0.
    assert(A0 <> B0 /\ C0 <> B0 /\ A <> B /\ C <> B).
      unfold GtA in H3.
      unfold LtA in H3.
      spliter.
      unfold LeA in H3.
      ex_and H3 P.
      unfold CongA in H5.
      spliter.
      repeat split; auto.
      intro.
      subst C.
      apply perp_comm in H.
      apply perp_not_col in H.
      apply H.
      Col.
    spliter.
    assert(B <> C').
      intro.
      subst C'.
      assert(Per A B C).
        apply perp_in_per.
        apply perp_in_comm.
        apply perp_perp_in.
        Perp.
      assert(CongA A0 B0 C0 A B C).
        apply l11_16; auto.
      unfold GtA in H3.
      unfold LtA in H3.
      spliter.
      unfold LeA in H3.
      contradiction.
    induction H0.
      auto.
    assert(Out B A C').
      unfold Out.
      repeat split; auto.
      induction H0.
        right.
        auto.
      left.
      Between.
    eapply (perp_out_acute _ _ C) in H9.
      apply obtuse_not_acute in H1.
      contradiction.
      auto.
Qed.
lcos_const0
Proof.
    intros.
    assert(HH:=H).
    unfold Lcos in HH.
    spliter.
    ex_and H4 A.
    ex_and H5 B.
    ex_and H4 C.
    exists C.
    exists A.
    exists B.
    repeat split.
      apply lg_sym; auto.
      auto.
    apply anga_sym; auto.
Qed.
lcos_const1
Proof.
    intros.
    assert(HH:=H).
    unfold Lcos in HH.
    spliter.
    assert(HH:= (lcos_lg_not_null lp l a H)).
    spliter.
    lg_instance_not_col l P A B.
    exists A.
    exists B.
    assert(HH:=anga_const_o a A B P H8 H0 H3).
    ex_and HH C'.
    assert(A <> B /\ B <> C').
      assert(HP:= anga_distinct a A B C' H3 H9).
      spliter.
      auto.
    spliter.
    assert(HH:=ex_point_lg_out lp B C' H12 H1 H5).
    ex_and HH C.
    exists C.
    repeat split; auto.
      assert(~ Col A B C').
        unfold OS in H10.
        ex_and H10 D.
        unfold TS in H10.
        spliter.
        intro.
        apply H10.
        Col.
      assert(HP:=out_one_side_1 A B C' C B H15).
      eapply (one_side_transitivity _ _ _ C').
        apply one_side_symmetry.
        apply HP.
          Col.
        apply l6_6.
        auto.
      auto.
    apply (anga_out_anga a A B C'); auto.
      apply out_trivial.
      auto.
    apply l6_6.
    auto.
Qed.
lcos_const
Proof.
    intros.
    unfold Lcos in H.
    spliter.
    ex_and H2 A.
    ex_and H3 B.
    ex_and H2 C.
    exists B.
    exists A.
    exists C.
    repeat split; auto.
    apply lg_sym; auto.
Qed.
lcos_lg_distincts
Proof.
    intros.
    assert(HH:= lcos_lg_not_null lp l a H).
    spliter.
    unfold Q_Cong_Null in *.
    split.
      intro.
      subst B.
      apply H4.
      unfold Lcos in H.
      split.
        tauto.
      exists A.
      auto.
    intro.
    subst C.
    apply H3.
    unfold Lcos in H.
    split.
      tauto.
    exists B.
    auto.
Qed.
lcos_const_a
Proof.
    intros.
    assert(HH:=H).
    unfold Lcos in HH.
    spliter.
    clear H3.
    assert(HH:= ex_point_lg l B H1).
    ex_and HH A.
    assert(l A B).
      apply lg_sym; auto.
    exists A.
    assert(HH:= lcos_lg_not_null lp l a H).
    spliter.
    assert(A <> B).
      intro.
      subst A.
      apply H6.
      unfold Q_Cong_Null.
      split.
        auto.
      exists B.
      auto.
    assert(HH:= anga_const a A B H2 H7).
    ex_and HH C'.
    assert(HH:= anga_distincts a A B C' H2 H8).
    spliter.
    assert(B <> C'); auto.
    assert(HH:= ex_point_lg_out lp B C' H11 H0 H5).
    ex_and HH C.
    exists C.
    repeat split; auto.
    apply (anga_out_anga a A B C' A C); auto.
      apply out_trivial.
      auto.
    apply l6_6.
    auto.
Qed.
lcos_const_ab
Proof.
    intros.
    assert(HH:=H).
    unfold Lcos in HH.
    spliter.
    clear H4.
    assert(HH:= lcos_lg_not_null lp l a H).
    spliter.
    assert(A <> B).
      intro.
      subst A.
      apply H5.
      unfold Q_Cong_Null.
      split.
        auto.
      exists B.
      auto.
    assert(HH:= anga_const a A B H3 H6).
    ex_and HH C'.
    assert(HH:= anga_distincts a A B C' H3 H7).
    spliter.
    assert(B <> C'); auto.
    assert(HH:= ex_point_lg_out lp B C' H10 H1 H4).
    ex_and HH C.
    exists C.
    repeat split; auto.
    apply (anga_out_anga a A B C' A C); auto.
      apply out_trivial.
      auto.
    apply l6_6.
    auto.
Qed.
lcos_const_cb
Proof.
    intros.
    assert(HH:=H).
    unfold Lcos in HH.
    spliter.
    clear H4.
    assert(HH:= lcos_lg_not_null lp l a H).
    spliter.
    assert(C <> B).
      intro.
      subst C.
      apply H4.
      unfold Q_Cong_Null.
      split.
        auto.
      exists B.
      auto.
    assert(HH:= anga_const a C B H3 H6).
    ex_and HH A'.
    assert(HH:= anga_distincts a C B A' H3 H7).
    spliter.
    assert(B <> A'); auto.
    assert(HH:= ex_point_lg_out l B A' H10 H2 H5).
    ex_and HH A.
    exists A.
    split.
      apply lg_sym; auto.
    apply(anga_out_anga a A' B C); auto.
      apply anga_sym; auto.
      apply l6_6.
      auto.
    apply out_trivial.
    auto.
Qed.
lcos_lg_anga
Proof.
    intros.
    split.
      auto.
    unfold Lcos in H.
    tauto.
Qed.
lcos_eql_lcos
Proof.
    intros.
    unfold Lcos in *.
    spliter.
    ex_and H4 A.
    ex_and H5 B.
    ex_and H4 C.

    assert(HH:=lg_eql_lg l1 l2 H2 H0).
    assert(HP:=lg_eql_lg lp1 lp2 H1 H).
    repeat split; auto.
    exists A.
    exists B.
    exists C.
    unfold EqL in *.
    spliter.
    repeat split; auto.
      apply H.
      auto.
    apply H0; auto.
Qed.
lcos_morphism
Proof.
unfold Proper.
split.
 - rewrite H1.
   intro.
   eauto using lcos_eql_lcos.
 - intro.
   rewrite H1.
   eapply lcos_eql_lcos with y y0;
   try symmetry;assumption.
Qed.
lcos_not_lg_null
Proof.
    intros.
    intro.
    unfold Q_Cong_Null in H0.
    spliter.
    unfold Lcos in H.
    spliter.
    ex_and H4 B.
    ex_and H5 A.
    ex_and H4 C.
    ex_and H1 P.
    unfold Q_Cong in H0.
    ex_and H0 X.
    ex_and H1 Y.
    assert(HH:= (H0 B A)).
    destruct HH.
    assert(HH:= (H0 P P)).
    destruct HH.
    apply H11 in H8.
    apply H9 in H5.
    assert(Cong B A P P).
      apply (cong_transitivity _ _ X Y); Cong.
    assert(A = B).
      eapply (cong_identity _ _ P).
      Cong.
    assert(HH:=anga_distincts a A B C H3 H7).
    spliter.
    contradiction.
Qed.
lcos_const_o
Proof.
    intros.
    assert(HH:= anga_const_o a A B P H H0 H3).
    ex_and HH C'.
    assert(A <> B /\ C' <> B).
      apply (anga_distincts a); auto.
    spliter.
    assert(HH:= lcos_not_lg_null lp l a H5).
    assert (B <> C').
      intro.
      apply H9.
      auto.
    assert(HP:=lg_exists C' B).
    ex_and HP lc'.
    assert(HQ:=anga_not_lg_null a l lc' A B C' H1 H11 H3 H4 H12 H6).
    spliter.
    assert(HR:= ex_point_lg_out lp B C' H10 H2 HH).
    ex_and HR C.
    exists C.
    split.
      apply invert_one_side.
      apply one_side_symmetry.
      apply (out_out_one_side _ _ _ C').
        apply invert_one_side.
        apply one_side_symmetry.
        auto.
      apply l6_6.
      auto.
    split.
      eapply (anga_out_anga a A B C'); auto.
        apply out_trivial.
        auto.
      apply l6_6.
      auto.
    auto.
Qed.
flat_not_acute
Proof.
    intros.
    intro.
    unfold Acute in H0.
    ex_and H0 A'.
    ex_and H1 B'.
    ex_and H0 C'.
    unfold LtA in H1.
    spliter.
    unfold LeA in H1.
    ex_and H1 P'.
    unfold InAngle in H1.
    spliter.
    ex_and H6 X.
    apply conga_distinct in H3.
    spliter.
    assert(A <> C).
      intro.
      subst C.
      apply between_identity in H.
      contradiction.
    induction H7.
      subst X.
      apply H2.
      apply conga_line; auto.
    assert(CongA A B C A' B' X).
      apply (out_conga A B C A' B' P').
        auto.
        apply out_trivial; auto.
        apply out_trivial; auto.
        apply out_trivial; auto.
      apply l6_6.
      auto.
    apply H2.
    assert(Bet A' B' X).
      apply (bet_conga_bet A B C); auto.
    apply conga_line; auto.
    apply (between_exchange4 _ _ X); auto.
Qed.
acute_comp_not_acute
Proof.
    intros.
    intro.
    induction(Col_dec A C D).
      induction H2.
        assert(Bet A B D).
          eBetween.
        assert(HH:= flat_not_acute A B D H3).
        contradiction.
      induction H2.
        assert(Bet A B D \/ Bet A D B).
          apply (l5_3 A B D C).
            auto.
          Between.
        induction H3.
          assert(HH:= flat_not_acute A B D H3).
          contradiction.
        assert(Bet C B D).
          eBetween.
        assert(HH:= flat_not_acute C B D H4).
        contradiction.
      assert(Bet C B D).
        eBetween.
      assert(HH:= flat_not_acute C B D H3).
      contradiction.
    unfold Acute in *.
    ex_and H0 A0.
    ex_and H3 B0.
    ex_and H0 C0.
    ex_and H1 A1.
    ex_and H4 B1.
    ex_and H1 C1.
    apply lta_diff in H3.
    apply lta_diff in H4.
    spliter.
    assert(HH:=l11_16 A0 B0 C0 A1 B1 C1 H0 H11 H12 H1 H7 H8).
    assert(LtA C B D A0 B0 C0).
      eapply(conga_preserves_lta C B D A1 B1 C1).
        apply conga_refl; auto.
        apply conga_sym.
        auto.
      auto.
    clear H4.
    assert(A <> C).
      intro.
      subst C.
      apply between_identity in H.
      contradiction.
    assert(Col A C B).
      apply bet_col in H.
      Col.
    assert(HP:= l10_15 A C B D H14 H2).
    ex_and HP P.
    assert(HP:= perp_col A C P B B H9 H15 H14).
    apply perp_left_comm in HP.
    apply perp_perp_in in HP.
    assert(Per A B P).
      apply perp_in_per.
      apply perp_in_comm.
      auto.
    assert(HR:= perp_not_eq_2 A C P B H15).
    assert(HQ:=l11_16 A B P A0 B0 C0 H17 H9 HR H0 H11 H12).
    assert(LtA A B D A B P).
      apply (conga_preserves_lta A B D A0 B0 C0); auto.
        apply conga_refl; auto.
      apply conga_sym.
      auto.
    assert(LtA C B D A B P).
      apply (conga_preserves_lta C B D A0 B0 C0); auto.
        apply conga_refl; auto.
      apply conga_sym.
      auto.
    clear HQ H13 H8 HH H3 H11 H12 H0 H1 H7.
    unfold LtA in *.
    spliter.
    assert((LeA A B D A B P <-> LeA C B P C B D)).
      apply (l11_36 A B D A B P C C); auto.
    destruct H8.
    assert(LeA C B P C B D).
      apply H8.
      auto.
    assert(CongA A B P C B P).
      apply l11_16; auto.
      apply perp_in_per.
      assert(Perp C B P B).
        apply(perp_col _ A).
          auto.
          apply perp_left_comm.
          auto.
        apply bet_col in H.
        Col.
      apply perp_in_comm.
      apply perp_perp_in.
      apply perp_left_comm.
      auto.
    assert(LeA A B P C B D).
      apply (l11_30 C B P C B D); auto.
        apply conga_sym.
        auto.
      apply conga_refl; auto.
    assert(HH:=lea_asym C B D A B P H0 H18).
    contradiction.
Qed.
lcos_per
Proof.
    intros.
    induction(eq_dec_points B C).
      subst C.
      apply l8_5.
    unfold Lcos in H2.
    spliter.
    ex_and H9 A0.
    ex_and H10 B0.
    ex_and H9 C0.
    assert(CongA B0 A0 C0 B A C).
      apply (anga_conga a); auto.
    assert(Cong A0 C0 A C).
      apply (lg_cong l); auto.
    assert(Cong A0 B0 A B).
      apply (lg_cong lp); auto.
    assert(HH:=l11_49 B0 A0 C0 B A C H13 H15 H14).
    spliter.
    assert(B0 <> C0).
      intro.
      subst C0.
      apply H6.
      apply (cong_identity _ _ B0).
      Cong.
    apply H17 in H18.
    spliter.
    eapply (l11_17 A0 B0 C0).
      apply l8_2.
      auto.
    auto.
Qed.
is_null_anga_dec
Proof.
    intros a H.
    assert (H' := H).
    unfold Q_CongA_Acute in H.
    destruct H as [A [B [C [Hacute HConga]]]].
    elim (out_dec B A C); intro Hout.
      left.
      unfold Q_CongA_Null_Acute.
      split; auto.
      intros.
      apply (out_conga_out A B C); auto.
      apply HConga.
      assumption.
    right.
    unfold Q_CongA_Null_Acute.
    intro H.
    destruct H as [Hclear H]; clear Hclear.
    apply Hout.
    apply H.
    apply HConga.
    apply acute_distincts in Hacute.
    spliter.
    apply conga_refl; auto.
Qed.
lcos_lg
Proof.
    intros.
    assert(HH:=H).
    unfold Lcos in HH.
    spliter.
    ex_and H6 A'.
    ex_and H7 B'.
    ex_and H6 C'.
    assert(Cong A C A' C').
      apply (lg_cong l); auto.
    assert(CongA B A C B' A' C').
      apply (anga_conga a); auto.
    induction(is_null_anga_dec a).
      assert(HP := null_lcos_eql lp l a H H12).
      unfold Q_CongA_Null_Acute in H12.
      spliter.
      assert(HH:= (H13 B A C H1)).
      apply perp_comm in H0.
      apply perp_not_col in H0.
      apply False_ind.
      apply H0.
      apply out_col in HH.
      Col.
      apply conga_distinct in H11.
      spliter.
      assert(CongA A B C A' B' C').
        apply l11_16; auto.
          apply perp_in_per.
          apply perp_in_comm.
          apply perp_perp_in.
          apply perp_comm.
          auto.
          apply perp_not_eq_2 in H0.
          auto.
          apply l8_2.
          auto.
        intro.
        subst C'.
        apply H12.
        unfold Q_CongA_Null_Acute.
        split; auto.
        intros.
        assert(CongA A0 B0 C0 B' A' B').
          apply (anga_conga a); auto.
        apply (out_conga_out B' A' B') .
          apply out_trivial; auto.
        apply conga_sym.
        auto.
      assert(Cong C B C' B' /\ Cong A B A' B' /\ CongA B C A B' C' A').
        apply(l11_50_2 C A B C' A' B').
          apply perp_comm in H0.
          apply perp_not_col in H0.
          intro.
          apply H0.
          Col.
          auto.
          apply conga_comm.
          auto.
        Cong.
      spliter.
      apply (lg_cong_lg lp A' B');auto.
      Cong.
    assumption.
Qed.
l13_7
Proof.
    intros.
    apply lcos_lg_anga in H.
    apply lcos_lg_anga in H0.
    apply lcos_lg_anga in H1.
    apply lcos_lg_anga in H2.
    spliter.
    clean_duplicated_hyps.
    induction (is_null_anga_dec a).
      assert(HH:=null_lcos_eql lba lb  a H2 H3).
      assert(HP:=null_lcos_eql la l  a H H3).
      assert(Lcos lab l b) by (rewrite HP;assumption).
      assert(HQ:= l13_6 b lb lab l H0 H5).
      rewrite <- HQ;assumption.
      induction (is_null_anga_dec b).
        assert(HH:=null_lcos_eql lab la  b H1 H5).
        assert(HP:=null_lcos_eql lb l  b H0 H5).
        assert(Lcos lba l a) by (rewrite HP;auto).
        assert(HQ:= l13_6 a la lba l H H6).
        rewrite HH in HQ;assumption.
        assert(HH:=lcos_const la l a H).
        ex_and HH C.
        ex_and H6 A.
        ex_and H8 B.
        assert(HH:= anga_distincts a C A B H14 H9).
        spliter.
        assert(~Col A B C).
          intro.
          apply H3.
          assert(Col C A B).
            Col.
          assert(HH:= anga_col_null a C A B H14 H9 H18).
          spliter.
          auto.
        assert(HH:=l10_2_existence B A C).
        ex_and HH P.
        assert( ~ Col B A P).
          eapply (osym_not_col _ _ C).
            apply l10_4.
            auto.
          intro.
          apply H17.
          Col.
        assert(l B A).
          apply lg_sym; auto.
        assert(HH:= lcos_const_o lb l b B A P H19 H5 H12 H10 H11 H20 H0).
        ex_and HH D.
        assert(TS B A P C).
          apply l10_14.
            intro.
            subst P.
            assert(Col C B A).
              apply(l10_8 B A C); auto.
            apply H19.
            Col.
            auto.
          auto.
        assert(TS B A D C).
          eapply (l9_8_2 _ _ P).
            auto.
          apply one_side_symmetry.
          auto.
        assert(Per A C B).
          apply (lcos_per _ _ _ la l a); auto.
          apply lg_sym; auto.
        assert(Per A D B).
          apply (lcos_per _ _ _ lb l b); auto.
          apply anga_sym; auto.
        assert(~ Col C D A).
          intro.
          assert(Per B C D).
            apply(per_col B C A D); auto.
              apply l8_2.
              auto.
            Col.
          assert(Per B D C).
            apply(per_col B D A C); auto.
              unfold OS in H21.
              ex_and H21 T.
              unfold TS in H21.
              spliter.
              intro.
              subst D.
              apply H21.
              Col.
              apply l8_2.
              auto.
            Col.
          assert(C = D).
            apply (l8_7 B); auto.
          subst D.
          unfold TS in H25.
          spliter.
          ex_and H32 T.
          assert(C=T).
            apply between_identity.
            auto.
          subst T.
          contradiction.
        assert(HH:= l8_18_existence C D A H28).
        ex_and HH E.
        assert(CongA B A C D A E /\ CongA B A D C A E /\ Bet C E D).
          apply(l13_2 A B C D E).
            apply invert_two_sides.
            apply l9_2.
            auto.
            apply l8_2.
            auto.
            apply l8_2.
            auto.
            auto.
          apply perp_sym.
          auto.
        spliter.
        assert(a D A E).
          eapply (anga_conga_anga a B A C); auto.
          apply anga_sym; auto.
        assert(b C A E).
          eapply (anga_conga_anga b B A D); auto.
        assert(Perp C E A E).
          eapply (perp_col _ D) .
            intro.
            subst E.
            apply H5.
            unfold Q_CongA_Null_Acute.
            split; auto.
            intros.
            assert(CongA A0 B0 C0 C A C).
              apply (anga_conga b); auto.
            apply (out_conga_out C A C A0 B0 C0 ).
              apply out_trivial; auto.
            apply conga_sym.
            auto.
            auto.
          auto.
        assert(lab A E).
          apply (lcos_lg b lab la A E C H1).
            apply perp_sym in H36.
            apply perp_right_comm in H36.
            auto.
            apply anga_sym; auto.
          apply lg_sym; auto.
        assert(Perp D E A E).
          eapply (perp_col _ C) .
            intro.
            subst E.
            apply H3.
            unfold Q_CongA_Null_Acute.
            split; auto.
            intros.
            assert(CongA A0 B0 C0 D A D).
              apply (anga_conga a); auto.
            apply (out_conga_out D A D A0 B0 C0 ).
              apply out_trivial; auto.
              apply perp_not_eq_2 in H36.
              auto.
            apply conga_sym.
            auto.
            Perp.
          Col.
        assert(lba A E).
          apply (lcos_lg a lba lb A E D).
            auto.
            Perp.
            auto.
            apply anga_sym; auto.
          auto.
        apply ex_eql.
        exists A.
        exists E.
        split.
          unfold Len.
          split; auto.
        unfold Len.
        split; auto.
      assumption.
    assumption.
Qed.
out_acute
Proof.
    intros.
    assert( A <> B /\ C <> B).
      unfold Out in H.
      tauto.
    spliter.
    assert(HH:= not_col_exists A B H0).
    ex_and HH Q.
    assert(exists P : Tpoint, Perp A B P B /\ OS A B Q P).
      apply(l10_15 A B B Q).
        Col.
      auto.
    ex_and H3 P.
    assert(Per P B A).
      apply perp_in_per.
      apply perp_left_comm in H3.
      apply perp_in_comm.
      apply perp_perp_in.
      Perp.
    unfold Acute.
    exists A.
    exists B.
    exists P.
    split.
      apply l8_2.
      auto.
    unfold LtA.
    split.
      unfold LeA.
      exists C.
      split.
        apply col_in_angle; auto.
        apply perp_not_eq_2 in H3.
        auto.
      apply conga_refl; auto.
    intro.
    apply out_conga_out in H6.
      apply perp_left_comm in H3.
      apply perp_not_col in H3.
      apply out_col in H6.
      contradiction.
    assumption.
Qed.
perp_acute
Proof.
    intros.
    assert(HH0:=H0).
    assert(HH:= l11_43 P A B).
    induction(Col_dec P A B).
      assert(Perp B A A C).
        eapply (perp_col _ P).
          intro.
          subst A.
          assert(Perp_at B B P C B).
            apply perp_perp_in.
            apply perp_in_perp_bis in H0.
            induction H0.
              apply perp_not_eq_1 in H0.
              tauto.
            Perp.
          assert(P=B).
            eapply(l8_14_3 B P B C); Perp.
          subst P.
          apply perp_in_perp_bis in H0.
          induction H0.
            apply perp_not_eq_1 in H0.
            tauto.
          apply perp_not_eq_1 in H0.
          tauto.
          apply perp_in_perp_bis in H0.
          induction H0.
            apply perp_not_eq_1 in H0.
            tauto.
          auto.
        Col.
      apply perp_comm in H2.
      apply perp_perp_in in H2.
      apply perp_in_comm in H2.
      apply perp_in_sym in H2.
      eapply (perp_in_col_perp_in _ _ _ _ P) in H2.
        assert( A = P).
          eapply(l8_14_3 A C B P); Perp.
        subst P.
        apply out_acute.
        apply perp_in_perp_bis in H2.
        induction H2.
          apply out_trivial.
          apply perp_not_eq_2 in H2.
          auto.
        apply perp_not_eq_1 in H2.
        tauto.
        apply perp_in_perp_bis in H0.
        induction H0; apply perp_not_eq_1 in H0; tauto.
      Col.
    apply acute_sym.
    apply l11_43.
      auto.
    left.
    assert(A <> P).
      intro.
      subst P.
      apply H1.
      Col.
    eapply (perp_in_col_perp_in _ _ _ _ P) in H0; auto.
    apply perp_in_per.
    Perp.
Qed.
null_lcos
Proof.
    intros.
    unfold Q_CongA_Null_Acute in H1.
    spliter.
    assert(HH:=ex_points_anga a H1).
    ex_and HH A.
    ex_and H3 B.
    ex_and H4 C.
    assert(HH:=H2 A B C H3).
    unfold Lcos.
    repeat split; auto.
    assert(B <> A).
      unfold Out in HH.
      spliter.
      auto.
    lg_instance l A' B'.
    assert(HP:=ex_point_lg_out l B A H4 H H0).
    ex_and HP P.
    exists B.
    exists P.
    exists P.
    repeat split; auto.
      apply l8_2.
      apply l8_5.
    apply (anga_out_anga _ A _ C); auto.
      apply l6_6.
      auto.
    apply (out2_out_2 _ _ _ A).
      apply l6_6.
      auto.
    auto.
Qed.
lcos_exists
Proof.
    intros.
    lg_instance l A B.
    induction(is_null_anga_dec a).
      exists l.
      apply null_lcos; auto.
      anga_instance1 a A B C.
        assert(~ Col B C A).
          intro.
          assert(Out B A C /\ Q_CongA_Null_Acute a).
            apply(anga_col_null a A B C H H4).
            Col.
          apply H3.
          tauto.
        assert(HH:= l8_18_existence B C A H5).
        ex_and HH P.
        assert(HH:=lg_exists B P).
        ex_and HH lp.
        exists lp.
        assert(Acute A B C).
          unfold Q_CongA_Acute in H.
          ex_and H A'.
          ex_and H10 B'.
          ex_and H C'.
          assert(HH:=H10 A B C).
          destruct HH.
          assert(HP:= H12 H4).
          apply (acute_lea_acute _ _ _ A' B' C'); auto.
          unfold LeA.
          exists C'.
          split.
            apply in_angle_trivial_2.
              apply conga_distinct in HP.
              tauto.
            apply conga_distinct in HP.
            tauto.
          apply conga_sym.
          auto.
        unfold Lcos.
        repeat split; auto.
        exists B.
        exists P.
        exists A.
        repeat split; auto.
          apply perp_in_per.
          apply perp_in_comm.
          apply perp_perp_in.
          apply perp_sym.
          apply (perp_col _ C).
            intro.
            subst P.
            assert(Per A B C).
              apply perp_in_per.
              apply perp_in_comm.
              apply perp_perp_in.
              Perp.
            apply acute_not_per in H10.
            contradiction.
            Perp.
          Col.
          apply (lg_sym l); auto.
        assert(HH:=H10).
        unfold Acute in HH.
        apply(anga_sym a); auto.
        apply(anga_out_anga a A B C A P); auto.
          apply out_trivial.
          intro.
          subst B.
          apply H5.
          Col.
        eapply (perp_acute_out _ _ A).
          apply acute_sym.
          auto.
          Perp.
        Col.
      intro.
      apply H1.
      unfold Q_Cong_Null.
      split; auto.
      subst B.
      exists A.
      auto.
    assumption.
Qed.
lcos_uniqueness
Proof.
intros.
unfold Lcos in *.
spliter.
ex_and H6 A1.
ex_and H7 B1.
ex_and H6 C1.
ex_and H3 A2.
ex_and H10 B2.
ex_and H3 C2.

assert(Cong A1 C1 A2 C2).
apply (lg_cong l); auto.

assert(CongA B1 A1 C1 B2 A2 C2).
apply (anga_conga a); auto.

induction(eq_dec_points C1 B1).
subst C1.

assert(EqL l l1).
apply ex_eqL; auto.
exists A1.
exists B1.
split; auto.

assert(Out A2 B2 C2).
apply (out_conga_out B1 A1 B1).
apply out_trivial.
intro.
subst B1.
apply conga_distinct in H14.
tauto.
auto.

assert(C2 = B2 \/ A2 = B2).
apply(l8_9 C2 B2 A2).
auto.
apply out_col in H16.
Col.
induction H17.
subst C2.

assert(EqL l l2).
apply ex_eqL; auto.
exists A2.
exists B2.
split; auto.
transitivity l; auto.
symmetry; auto.

subst B2.
apply conga_distinct in H14.
tauto.

apply conga_distinct in H14.
spliter.
assert(CongA C1 B1 A1 C2 B2 A2).
apply l11_16; auto.
intro.
subst C2.

assert(Out A1 B1 C1).
apply (out_conga_out B2 A2 B2).
apply out_trivial; auto.
apply conga_sym.
auto.
assert(C1 = B1 \/ A1 = B1).
apply(l8_9 C1 B1 A1 ); auto.
apply out_col in H20.
Col.
induction H21.
subst C1.
tauto.
subst B1.
tauto.

assert( Cong C1 B1 C2 B2 /\ Cong A1 B1 A2 B2 /\ CongA B1 C1 A1 B2 C2 A2).
apply(l11_50_2 C1 A1 B1 C2 A2 B2).
intro.
assert(C1 = B1 \/ A1 = B1).
apply(l8_9 C1 B1 A1 ); auto.
Col.
induction H22.
contradiction.
subst B1.
tauto.
apply conga_comm.
auto.
apply conga_comm.
auto.
Cong.
spliter.

apply ex_eqL; auto.
exists A1.
exists B1.
split; auto.
apply (lg_cong_lg l2 A2 B2); auto.
Cong.
Qed.
lcos_eqa_lcos
Proof.
    intros.
    assert(HH:=lcos_lg_anga l lp a H).
    spliter.
    clear H1.
    assert(HH:= H0).
    unfold EqA in HH.
    assert (Q_CongA a) by (apply anga_is_ang;auto).
    assert (Q_CongA b) by (apply eqA_preserves_ang with a;auto).
    assert (Q_CongA_Acute b).
      apply (eqA_preserves_anga a b); auto.
    unfold Lcos in *.
    spliter.
    repeat split; auto.
    ex_and H9 A.
    ex_and H10 B.
    ex_and H9 C.
    exists A.
    exists B.
    exists C.
    repeat split; auto.
    apply HH;auto.
Qed.
lcos_eq_refl
Proof.
    intros.
    unfold Eq_Lcos.
    assert(HH:=lcos_exists la a H1 H H0).
    ex_and HH lp.
    exists lp.
    split; auto.
Qed.
lcos_eq_sym
Proof.
    intros.
    unfold Eq_Lcos in *.
    ex_and H lp.
    exists lp.
    split; auto.
Qed.
lcos_eq_trans
Proof.
    intros.
    unfold Eq_Lcos in *.
    ex_and H lab.
    ex_and H0 lbc.
    assert(HH:= l13_6 b lab lbc lb H1 H0).
    assert(Lcos lbc la a).
      rewrite <- HH.
      apply lcos_lg_anga in H.
      tauto.
    exists lbc.
    split; auto.
Qed.
lcos2_comm
Proof.
    intros.
    unfold lcos2 in *.
    ex_and H la.
    apply lcos_lg_anga in H.
    apply lcos_lg_anga in H0.
    spliter.
    assert(exists lb, Lcos lb l b).
      apply(lcos_exists l b); auto.
      assert(HH:= lcos_lg_not_null la l a H).
      tauto.
    ex_and H7 lb.
    apply lcos_lg_anga in H8.
    spliter.
    exists lb.
    split.
      auto.
    assert(exists lp', Lcos lp' lb a).
      apply(lcos_exists lb a); auto.
      assert(HH:= lcos_lg_not_null lb l b H7).
      tauto.
    ex_and H11 lp'.
    assert(EqL lp lp').
      apply(l13_7 a b l la lb lp lp'); auto.
    apply lcos_lg_anga in H12.
    rewrite H11. tauto.
Qed.
lcos2_exists
Proof.
    intros.
    assert(HH:= lcos_exists l a H1 H H0).
    ex_and HH la.
    apply lcos_lg_anga in H3.
    spliter.
    assert(~ Q_Cong_Null la /\ ~ Q_Cong_Null l).
      apply (lcos_lg_not_null _ _ a).
      auto.
    spliter.
    clear H8.
    assert(HH:= lcos_exists la b H2 H5 H7).
    ex_and HH lab.
    exists lab.
    unfold lcos2.
    exists la.
    split; auto.
Qed.
lcos2_exists'
Proof.
    intros.
    assert(HH:=lcos_exists l a H1 H H0).
    ex_and HH la.
    exists la.
    apply lcos_lg_anga in H3.
    spliter.
    assert(HP:=lcos_not_lg_null la l a H3).
    assert(HH:=lcos_exists la b H2 H5 HP).
    ex_and HH lab.
    exists lab.
    split; auto.
Qed.
lcos2_eq_refl
Proof.
    intros.
    assert(HH:= lcos2_exists l a b H H0 H1 H2).
    ex_and HH lab.
    unfold Eq_Lcos2.
    exists lab.
    split; auto.
Qed.
lcos2_eq_sym
Proof.
    intros.
    unfold Eq_Lcos2 in *.
    ex_and H lp.
    exists lp.
    auto.
Qed.
lcos2_uniqueness:
Proof.
    intros.
    unfold lcos2 in *.
    ex_and H la.
    ex_and H0 lb.
    assert(EqL la lb).
      apply (l13_6 a _ _ l); auto.
    apply lcos_lg_anga in H2.
    apply lcos_lg_anga in H1.
    spliter.
    assert(Lcos l2 la b).
      rewrite H3;auto.
    apply (l13_6 b _ _ la); auto.
Qed.
lcos2_eql_lcos2
Proof.
    intros.
    unfold lcos2 in *.
    ex_and H l.
    exists l.
    apply lcos_lg_anga in H.
    apply lcos_lg_anga in H2.
    spliter.
    split.
    rewrite <- H0;auto.
    rewrite <- H1;auto.
Qed.
lcos2_lg_anga
Proof.
    intros.
    split; auto.
    unfold lcos2 in H.
    ex_and H ll.
    apply lcos_lg_anga in H.
    apply lcos_lg_anga in H0.
    spliter.
    split; auto.
Qed.
lcos2_eq_trans
Proof.
    intros.
    unfold Eq_Lcos2 in *.
    ex_and H lp.
    ex_and H0 lq.
    exists lp.
    split; auto.
    assert(EqL lp lq).
      eapply (lcos2_uniqueness l2 _ _ c d); auto.
    apply lcos2_lg_anga in H2.
    apply lcos2_lg_anga in H1.
    spliter.
    eapply (lcos2_eql_lcos2 l3 _ lq); auto.
      reflexivity.
    symmetry; auto.
Qed.
lcos_eq_lcos2_eq
Proof.
    intros.
    assert(HH0:=H0).
    unfold Eq_Lcos in HH0.
    ex_and HH0 lp.
    apply lcos_lg_anga in H1.
    apply lcos_lg_anga in H2.
    spliter.
    clear H7.
    assert(~ Q_Cong_Null lp /\ ~ Q_Cong_Null la).
      apply (lcos_lg_not_null _ _ a).
      auto.
    spliter.
    unfold Eq_Lcos2.
    assert(HH:= lcos_exists lp c H H4 H7).
    ex_and HH lq.
    exists lq.
    split.
      unfold lcos2.
      exists lp.
      split; auto.
    unfold lcos2.
    exists lp.
    split; auto.
Qed.
lcos2_lg_not_null:
Proof.
    intros.
    unfold lcos2 in H.
    ex_and H la.
    apply lcos_lg_not_null in H.
    apply lcos_lg_not_null in H0.
    spliter.
    split; auto.
Qed.
lcos3_lcos_1_2
Proof.
    intros.
    split.
      intro.
      unfold Lcos3 in H.
      ex_and H la.
      ex_and H0 lab.
      exists la.
      split; auto.
      unfold lcos2.
      exists lab.
      split; auto.
    intro.
    ex_and H la.
    unfold lcos2 in H0.
    ex_and H0 lab.
    unfold Lcos3.
    exists la.
    exists lab.
    apply lcos_lg_anga in H0.
    apply lcos_lg_anga in H1.
    spliter.
    split; auto.
Qed.
lcos3_lcos_2_1
Proof.
    intros.
    split.
      intro.
      unfold Lcos3 in H.
      ex_and H la.
      ex_and H0 lab.
      exists lab.
      split.
        unfold lcos2.
        exists la.
        split; assumption.
      assumption.
    intro.
    ex_and H lab.
    unfold Lcos3.
    unfold lcos2 in H.
    ex_and H la.
    exists la.
    exists lab.
    split; auto.
Qed.
lcos3_permut3
Proof.
    intros.
    assert(HH:= lcos3_lcos_2_1 lp l a b c).
    destruct HH.
    assert(exists lab : Tpoint -> Tpoint -> Prop, lcos2 lab l a b /\ Lcos lp lab c).
      apply lcos3_lcos_2_1; auto.
    ex_and H2 lab.
    apply lcos2_comm in H2.
    apply lcos3_lcos_2_1.
    exists lab.
    split; auto.
Qed.
lcos3_permut1
Proof.
    intros.
    assert(HH:= lcos3_lcos_1_2 lp l a b c).
    destruct HH.
    assert(exists la : Tpoint -> Tpoint -> Prop, Lcos la l a /\ lcos2 lp la b c).
      apply lcos3_lcos_1_2; auto.
    ex_and H2 la.
    apply lcos2_comm in H3.
    apply lcos3_lcos_1_2.
    exists la.
    split; auto.
Qed.
lcos3_permut2
Proof.
    intros.
    apply lcos3_permut3.
    apply lcos3_permut1.
    apply lcos3_permut3.
    auto.
Qed.
lcos3_exists
Proof.
    intros.
    assert(HH:= lcos_exists l a H1 H H0).
    ex_and HH la.
    apply lcos_lg_anga in H4.
    spliter.
    assert(~ Q_Cong_Null la /\ ~ Q_Cong_Null l).
      apply (lcos_lg_not_null _ _ a).
      auto.
    spliter.
    clear H9.
    clear H7.
    assert(HH:= lcos_exists la b H2 H6 H8).
    ex_and HH lab.
    apply lcos_lg_anga in H7.
    spliter.
    assert(~ Q_Cong_Null lab /\ ~ Q_Cong_Null la).
      apply (lcos_lg_not_null _ _ b).
      auto.
    spliter.
    assert(HH:= lcos_exists lab c H3 H10 H12).
    ex_and HH lp.
    exists lp.
    unfold Lcos3.
    exists la.
    exists lab.
    split;auto.
Qed.
lcos3_eq_refl
Proof.
    intros.
    assert(HH:= lcos3_exists l a b c H H0 H1 H2 H3).
    ex_and HH lp.
    unfold Eq_Lcos3.
    exists lp.
    split; auto.
Qed.
lcos3_eq_sym
Proof.
    intros.
    unfold Eq_Lcos3 in *.
    ex_and H lp.
    exists lp.
    auto.
Qed.
lcos3_uniqueness:
Proof.
    intros.
    unfold Lcos3 in *.
    ex_and H la.
    ex_and H1 lab.
    ex_and H0 la'.
    ex_and H3 lab'.
    assert(EqL la la').
      apply (l13_6 a _ _ l); auto.
    apply lcos_lg_anga in H2.
    apply lcos_lg_anga in H3.
    apply lcos_lg_anga in H.
    apply lcos_lg_anga in H4.
    spliter.
    assert(Lcos lab' la b).
      rewrite H5;auto.
    assert(EqL lab lab') by
      (apply (l13_6 b _ _ la); auto).
    assert(Lcos l2 lab c).
      rewrite H19. auto.
    apply (l13_6 c _ _ lab); auto.
Qed.
lcos3_eql_lcos3
Proof.
    intros.
    unfold Lcos3 in *.
    ex_and H lpa.
    exists lpa.
    ex_and H2 lpab.
    exists lpab.
    apply lcos_lg_anga in H.
    apply lcos_lg_anga in H2.
    apply lcos_lg_anga in H3.
    spliter.
    split.
    rewrite <- H0;auto.
    split.
      auto.
    rewrite <- H1;auto.
Qed.
lcos3_lg_anga
Proof.
    intros.
    split; auto.
    unfold Lcos3 in H.
    ex_and H la.
    ex_and H0 lab.
    apply lcos_lg_anga in H.
    apply lcos_lg_anga in H0.
    apply lcos_lg_anga in H1.
    spliter.
    split; auto.
Qed.
lcos3_lg_not_null:
Proof.
    intros.
    unfold Lcos3 in H.
    ex_and H la.
    ex_and H0 lab.
    apply lcos_lg_not_null in H.
    apply lcos_lg_not_null in H1.
    spliter.
    split; auto.
Qed.
lcos3_eq_trans
Proof.
    intros.
    unfold Eq_Lcos3 in *.
    ex_and H lp.
    ex_and H0 lq.
    exists lp.
    split; auto.
    assert(EqL lp lq).
      eapply (lcos3_uniqueness l2 _ _ d e f); auto.
    apply lcos3_lg_anga in H2.
    apply lcos3_lg_anga in H1.
    spliter.
    eapply (lcos3_eql_lcos3 l3 _ lq); auto.
      reflexivity.
    symmetry; auto.
Qed.
lcos_eq_lcos3_eq
Proof.
    intros.
    assert(HH1:=H1).
    unfold Eq_Lcos in HH1.
    ex_and HH1 lp.
    apply lcos_lg_anga in H2.
    apply lcos_lg_anga in H3.
    spliter.
    assert(~ Q_Cong_Null lp /\ ~ Q_Cong_Null la).
      apply (lcos_lg_not_null _ _ a).
      auto.
    spliter.
    assert(HH:= lcos_exists lp c H H5 H10).
    ex_and HH lq.
    apply lcos_lg_anga in H12.
    spliter.
    assert(~ Q_Cong_Null lq /\ ~ Q_Cong_Null lp).
      apply (lcos_lg_not_null _ _ c); auto.
    spliter.
    assert(HH:= lcos_exists lq d H0 H14 H16).
    ex_and HH lm.
    unfold Eq_Lcos3.
    exists lm.
    split; unfold Lcos3.
      exists lp.
      exists lq.
      split; auto.
    exists lp.
    exists lq.
    split; auto.
Qed.
lcos2_eq_lcos3_eq
Proof.
    intros.
    assert(HH0:=H0).
    unfold Eq_Lcos2 in HH0.
    ex_and HH0 lp.
    apply lcos2_lg_anga in H1.
    apply lcos2_lg_anga in H2.
    spliter.
    assert(~ Q_Cong_Null la /\ ~ Q_Cong_Null lp).
      eapply (lcos2_lg_not_null _ _ a b).
      auto.
    spliter.
    assert(HH:= lcos_exists lp e H H3 H12).
    ex_and HH lq.
    apply lcos_lg_anga in H13.
    spliter.
    assert(~ Q_Cong_Null lq /\ ~ Q_Cong_Null lp).
      apply (lcos_lg_not_null _ _ e); auto.
    spliter.
    unfold Eq_Lcos3.
    exists lq.
    split; apply lcos3_lcos_2_1; exists lp; split; auto.
Qed.
l13_10_aux1
Proof.
    intros.
    assert(Acute A O P).
      eapply (perp_acute _ _ P);finish.
    assert(P <> O).
      intro.
      subst P.
      apply perp_not_eq_1 in H1.
      tauto.
    assert(A <> O).
      intro.
      subst A.
      apply perp_not_col in H1.
      apply H1.
      Col.
    assert(Q <> O).
      intro.
      subst Q.
      apply perp_not_eq_1 in H2.
      tauto.
    assert(B <> O).
      intro.
      subst B.
      apply perp_not_col in H2.
      apply H2.
      Col.
    assert(HH:= anga_exists A O P H13 H12 H11).
    ex_and HH a.
    assert(a B O Q).
      assert(~ Par O P A P).
        intro.
        unfold Par in H18.
        induction H18.
          unfold Par_strict in H18.
          spliter.
          apply H21.
          exists P.
          split; Col.
        spliter.
        apply perp_comm in H1.
        apply perp_not_col in H1.
        apply H1.
        Col.
      assert(A <> P).
        apply perp_not_eq_2 in H1.
        auto.
      assert(Proj O O O P A P).
        unfold Proj.
        repeat split; Col.
      assert(Proj A P O P A P).
        unfold Proj.
        repeat split; Col.
        left.
        apply par_reflexivity.
        auto.
      assert(Proj B Q O P A P).
        unfold Proj.
        repeat split; Col.
        left.
        eapply (l12_9 _ _ _ _ O P).
          apply perp_sym.
          eapply (perp_col _ Q); Col.
          Perp.
        Perp.
      induction H.
        assert(Bet O P Q).

        apply(per23_preserves_bet O A B P Q); auto.
        apply perp_in_per.
apply perp_comm in H1.
apply perp_perp_in in H1.
Perp.
apply perp_in_per.
apply perp_comm in H2.
apply perp_perp_in in H2.
Perp.

   (*       apply(project_preserves_bet O P A P O A B O P Q); auto. *)
        assert(CongA A O P B O Q).
          eapply (out_conga B _ Q B _ Q).
            apply conga_refl; auto.
            unfold Out.
            repeat split; auto.
            unfold Out.
            repeat split; auto.
            apply out_trivial; auto.
          apply out_trivial; auto.
        apply (anga_conga_anga _ A O P); auto.
      induction H.
        assert(Bet P Q O).

apply between_symmetry.
apply(per23_preserves_bet O B A Q P); Between.
Col.

apply perp_in_per.
apply perp_comm in H2.
apply perp_perp_in in H2.
Perp.
apply perp_comm in H1.
apply perp_perp_in in H1.
Perp.

 (*         apply(project_preserves_bet O P A P A B O P Q O); auto.*)
        assert(CongA A O P B O Q).
          eapply (out_conga B _ Q B _ Q).
            apply conga_refl; auto.
            unfold Out.
            repeat split; auto.
            left.
            Between.
            unfold Out.
            repeat split; auto.
            left.
            Between.
            apply out_trivial; auto.
          apply out_trivial; auto.
        apply (anga_conga_anga _ A O P); auto.
      assert(Bet Q O P).

apply(per13_preserves_bet B O A Q P); auto.
Col.
apply perp_in_per.
apply perp_comm in H2.
apply perp_perp_in in H2.
Perp.
apply perp_comm in H1.
apply perp_perp_in in H1.
Perp.

 (*       apply(project_preserves_bet O P A P B O A Q O P); auto. *)
      assert(CongA A O P B O Q).
        eapply (l11_14 ); Between.
      apply (anga_conga_anga _ A O P); auto.
    exists a.
    repeat split; auto.
      exists O.
      exists P.
      exists A.
      repeat split; auto.
        apply perp_in_per.
        Perp.
      apply anga_sym; auto.
    exists O.
    exists Q.
    exists B.
    repeat split; auto.
      apply perp_in_per.
      Perp.
    apply anga_sym; auto.
Qed.
l13_10_aux2
Proof.
    intros.
    assert(HH:=anga_exists A O A H8 H8 (acute_trivial A O H8)).
    ex_and HH a.
    exists a.
    split; auto.
    assert(Q_CongA_Null_Acute a).
      assert(Out O A A /\ Q_CongA_Null_Acute a).
        apply(anga_col_null a A O A); auto.
        Col.
      tauto.
    split.
      assert(EqL la lla).
        apply ex_eql.
        exists O.
        exists A.
        repeat split; auto.
      rewrite <- H13.
      apply null_lcos; auto.
      intro.
      unfold Q_Cong_Null in H14.
      spliter.
      ex_and H15 X.
      assert(HH:= lg_cong la O A X X H0 H4 H16).
      treat_equalities.
      tauto.
    assert(HH:=anga_exists B O B H9 H9 (acute_trivial B O H9)).
    ex_and HH b.
    assert(EqA a b).
      assert(HH:=null_anga A O B O a b).
      apply HH; split; auto.
    assert(EqL lb llb).
      apply ex_eql.
      exists O.
      exists B.
      repeat split; auto.
    rewrite <- H16.
    apply null_lcos; auto.
    intro.
    unfold Q_Cong_Null in H17.
    spliter.
    ex_and H18 X.
    assert(HH:= lg_cong lb O B X X H2 H6 H19).
    treat_equalities.
    tauto.
Qed.
l13_6_bis
Proof.
    intros.
    induction(is_null_anga_dec a).
      apply lcos_lg_anga in H.
      apply lcos_lg_anga in H0.
      spliter.
      assert(HH:= null_lcos_eql lp l1 a H H1).
      assert(HP:= null_lcos_eql lp l2 a H0 H1).
      transitivity lp; auto.
      symmetry; auto.
      apply lcos_lg_anga in H.
      apply lcos_lg_anga in H0.
      spliter.
      assert (HH:= H).
      assert(HH0:= H0).
      unfold Lcos in HH.
      unfold Lcos in HH0.
      spliter.
      ex_and H11 A.
      ex_and H16 B.
      ex_and H11 C.
      ex_and H15 A'.
      ex_and H19 B'.
      ex_and H15 C'.
      assert(HH:=not_null_not_col a B A C H4 H1 H18).
      assert(HP:=not_null_not_col a B' A' C' H4 H1 H21).
      assert(B <> C).
        intro.
        subst C.
        apply HH.
        Col.
      assert(B' <> C').
        intro.
        subst C'.
        apply HP.
        Col.
      assert(HQ:= anga_distincts a B A C H4  H18).
      assert(HR:= anga_distincts a B' A' C' H4 H21).
      spliter.
      assert(Cong A B A' B').
        apply (lg_cong lp); auto.
      assert(CongA B A C B' A' C').
        apply (anga_conga a); auto.
      assert(CongA C B A C' B' A').
        apply l11_16; auto.
      assert(Cong A C A' C' /\ Cong B C B' C' /\ CongA A C B A' C' B').
        apply(l11_50_1 A B C A' B' C'); auto.
          intro.
          apply HH.
          Col.
        apply conga_comm.
        auto.
      spliter.
      apply (all_eql A' C').
        split; auto.
      split; auto.
      eapply (lg_cong_lg _ A C); auto.
    unfold Lcos in *;intuition.
Qed.
lcos3_lcos2
Proof.
    intros.
    unfold Eq_Lcos3 in H.
    ex_and H lp.
    unfold Eq_Lcos2.
    apply lcos3_lcos_2_1 in H.
    apply lcos3_lcos_2_1 in H0.
    ex_and H ll1.
    ex_and H0 ll2.
    assert (EqL ll1 ll2).
      eapply(l13_6_bis lp _ _ n); auto.
    exists ll1.
    split; auto.
    apply lcos2_lg_anga in H.
    apply lcos2_lg_anga in H0.
    spliter.
    apply(lcos2_eql_lcos2 l2 l2 ll2 ll1 c d); auto.
      reflexivity.
    symmetry; auto.
Qed.
lcos2_lcos
Proof.
    intros.
    unfold Eq_Lcos2 in H.
    ex_and H lp.
    unfold lcos2 in H.
    unfold lcos2 in H0.
    ex_and H lx.
    ex_and H0 ly.
    unfold Eq_Lcos.
    assert(EqL lx ly).
      eapply(l13_6_bis lp _ _ c); auto.
    exists lx.
    split; auto.
    apply lcos_lg_anga in H.
    apply lcos_lg_anga in H0.
    spliter.
    rewrite H3;auto.
Qed.
lcos_per_anga
Proof.
    intros.
    assert(HH:= H).
    unfold Lcos in HH.
    spliter.
    ex_and H6 O'.
    ex_and H7 P'.
    ex_and H6 A'.
    assert(Cong O A O' A').
      apply (lg_cong la); auto.
    assert(Cong O P O' P').
      apply (lg_cong lp); auto.
    assert(HH:= lcos_lg_not_null lp la a H).
    spliter.
    induction(eq_dec_points A P).
      subst A.
      assert(Cong O' A' O' P').
        apply (cong_transitivity _ _ O P); Cong.
      assert(A' = P').
        induction(Col_dec A' P' O').
          assert(A' = P' \/ O' = P').
            apply l8_9; auto.
          induction H16.
            auto.
          subst P'.
          eapply (cong_identity _  O' O'); Cong.
        assert(Lt P' A' A' O' /\ Lt P' O' A' O').
          apply(l11_46 A' P' O' H15).
          left.
          auto.
        spliter.
        unfold Lt in H17.
        spliter.
        apply False_ind.
        apply H18.
        Cong.
      subst A'.
      assert(Q_CongA_Null_Acute a).
        apply(out_null_anga a P' O' P'); auto.
        apply out_trivial.
        intro.
        subst P'.
        apply H12.
        unfold Q_Cong_Null.
        split.
          auto.
        exists O'.
        auto.
      apply(is_null_all a P O).
        intro.
        subst P.
        apply H12.
        unfold Q_Cong_Null.
        split.
          auto.
        exists O.
        auto.
      auto.
    assert(O <> P).
      intro.
      subst P.
      apply H12.
      split.
        auto.
      exists O.
      auto.
    induction(Col_dec A P O).
      assert (HH:=anga_distincts a P' O' A' H5 H9).
      spliter.
      assert(A' <> P').
        intro.
        subst A'.
        assert(A = P \/ O = P).
          apply l8_9; auto.
        induction H19.
          auto.
        contradiction.
      assert(~ Col A P O).
        apply(per_not_col A P O); auto.
      contradiction.
    assert (HH:=anga_distincts a P' O' A' H5 H9).
    spliter.
    assert(A' <> P').
      intro.
      subst A'.
      assert(Cong O P O A).
        apply (cong_transitivity _ _ O' P'); Cong.
      assert(Lt P A A O /\ Lt P O A O).
        apply(l11_46 A P O H16).
        left.
        auto.
      spliter.
      unfold Lt in H21.
      spliter.
      apply H22.
      Cong.
    assert(CongA A P O A' P' O').
      apply l11_16; auto.
    assert(Cong P A P' A' /\ CongA P A O P' A' O' /\ CongA P O A P' O' A').
      assert(Lt P A A O /\ Lt P O A O).
        apply(l11_46 A P O H16).
        left.
        auto.
      spliter.
      unfold Lt in H22.
      spliter.
      apply(l11_52 A P O A' P' O' ); Cong.
    spliter.
    apply conga_comm in H23.
    apply (anga_conga_anga a A' O' P'); auto.
      apply (anga_sym a); auto.
    apply conga_sym.
    auto.
Qed.
lcos_lcos_col
Proof.
    intros.
    apply lcos_lg_anga in H.
    apply lcos_lg_anga in H0.
    spliter.
    assert(Per O P A).
      apply (lcos_per O P A lp la a); auto.
      apply anga_sym; auto.
    assert(Per O P B).
      apply (lcos_per O P B lp lb b); auto.
      apply anga_sym; auto.
    eapply (per_per_col _ _ O); Perp.
    intro.
    subst P.
    assert(HH:=lcos_lg_not_null lp la a H).
    spliter.
    apply H14.
    unfold Q_Cong_Null.
    split; auto.
    exists O.
    auto.
Qed.
per13_preserves_bet_inv
Proof.
intros.
assert(Col A' B C').
apply bet_col in H.
Col.

induction(eq_dec_points A A').
subst A'.
assert(Col B C' C).
ColR.
assert(HH:=l8_9 B C' C H4 H6 ).
induction HH.
contradiction.
subst C'.
assumption.

assert(C <> C').
intro.
subst C'.
assert(Col B A' A).
ColR.
assert(HH:=l8_9 B A' A H3 H7).
induction HH;
contradiction.

assert(Perp B A' A' A).
apply per_perp_in in H3; auto.
apply perp_in_comm in H3.
apply perp_in_perp_bis in H3.
induction H3.
Perp.
apply perp_distinct in H3.
tauto.

assert(Perp B C' C' C).
apply per_perp_in in H4; auto.
apply perp_in_comm in H4.
apply perp_in_perp_bis in H4.
induction H4.
Perp.
apply perp_distinct in H4.
tauto.

assert(Par A A' C C').
apply(l12_9 A A' C C' B A');Perp.
apply perp_sym.
apply(perp_col _ C'); Perp.
ColR.

induction H10.
assert(HH:=par_strict_symmetry A A' C C' H10).
apply l12_6 in H10.
apply l12_6 in HH.

assert(~Col A' A B).
apply per_not_col in H3; auto.
intro.
apply H3.
Col.

assert(~Col C' C B).
apply per_not_col in H4; auto.
intro.
apply H4.
Col.

assert(OS A' A B C').
apply out_one_side.
left; auto.
repeat split.
intro.
subst A'.
apply H11.
Col.
intro.
subst C'.
apply one_side_symmetry in H10.
unfold OS in H10.
ex_and H10 X.
unfold TS in H10.
spliter.
apply H10.
Col.
left.
assumption.

assert(OS C' C B A').
apply out_one_side.
left; auto.
repeat split.
intro.
subst C'.
apply H12.
Col.
intro.
subst C'.
apply one_side_symmetry in H10.
unfold OS in H10.
ex_and H10 X.
unfold TS in H10.
spliter.
apply H10.
Col.
left.
Between.

assert(OS A' A B C).
apply(one_side_transitivity _ _ _ C'); auto.
apply invert_one_side.
apply one_side_symmetry.
assumption.

assert(OS C C' B A).
apply(one_side_transitivity _ _ _ A'); auto.
apply invert_one_side.
assumption.
apply one_side_symmetry.
assumption.

apply invert_one_side in H15.

assert(HP:= col_one_side_out A A' B C H2 H15).

assert(Out C B A).
apply(col_one_side_out C C' B A); Col.

unfold Out in *.
spliter.

induction H19.
Between.
induction H22.
Between.
apply False_ind.
apply H18.
apply (between_equality _ _ B); Between.

(****************************)

spliter.
assert(Perp A' C' A A').
apply (perp_col _ B); Perp.
intro.
subst C'.
apply between_identity in H.
subst A'.
apply perp_distinct in H9.
tauto.
apply perp_not_col in H14.

apply False_ind.
apply H14.
ColR.
Qed.
l13_10_aux3
Proof.
    intros.
    assert(A <> O).
      intro.
      subst A.
      apply H.
      Col.
    assert(A' <> O).
      intro.
      subst A'.
      apply H.
      Col.
    assert(Col O A C).
      apply (col_transitivity_1 _ B); Col.
    assert(Col O A' C').
      apply (col_transitivity_1 _ B'); Col.
    assert(Bet C A O \/ Bet A C O \/ Bet O C B \/ Bet O B C).
      apply(fourth_point A O B C); auto.
      ColR.
    induction H15.
      assert(Bet O C' A').
        apply(perp2_preserves_bet23 O A C C' A'); Between.
          Col.
          intro.
          apply H.
               ColR.
               apply perp2_sym.
        auto.

      assert(Bet B' O C').
        apply(perp2_preserves_bet13 O B C B' C'); eBetween.
          intro.
          apply H.
          ColR.
          eBetween.

    (***************)
    induction H15.
      assert(Bet C O B).
        eBetween.
      assert(Bet O A' C').
        apply(perp2_preserves_bet23 O C A A' C'); Between.
        intro.
        apply H.
ColR.

      assert(Bet B' O C').
        apply(perp2_preserves_bet13 O B C B' C'); Between.
          intro.
          apply H.
ColR.
eBetween.
    induction H15.
      assert(Bet A O C).
        eBetween.
      assert(Bet O B' C').
        apply(perp2_preserves_bet23 O C B B' C'); Between.
          intro.
          apply H.
ColR.
        apply perp2_sym.
        auto.
      assert(Bet C' O A').
        apply(perp2_preserves_bet13 O C A C' A'); Col.
Between.
          intro.
          apply H.
ColR.
eBetween.
    assert(Bet A O C).
      eBetween.
    assert(Bet O C' B').
      apply(perp2_preserves_bet23 O B C C' B'); Col.
      intro.
      apply H.
ColR.
    assert(Bet C' O A').
      apply(perp2_preserves_bet13 O C A C' A'); Col.
Between.
        intro.
        apply H.
ColR.
    eBetween.
Qed.
l13_10_aux4
Proof.
    intros.
    assert(A <> O).
      intro.
      subst A.
      apply H.
      Col.
    assert(A' <> O).
      intro.
      subst A'.
      apply H.
      Col.
    assert(Col O A C).
    ColR.
    induction(eq_dec_points A B).
      subst B.
assert(HH:= perp2_trans C A' A C' C B' O H9 H8).
      assert(A' = B').
      apply perp2_par in HH.

        assert(Col A' B' C).
          induction HH.
            apply False_ind.
            apply H14.
            exists C.
            split; Col.
          spliter.
          Col.
        apply (l6_21 O C' C B'); Col.
          intro.
          apply H.
ColR.
        intro.
        subst B'.
apply par_distinct in HH.
tauto.
ColR.
      subst B'.
      apply out_trivial.
      auto.


    assert(Bet C O A \/ Bet O C A \/ Bet A C B \/ Bet A B C).
      apply(fourth_point O A B C); auto.

    induction H15.
      assert(Bet B' O C').
        assert(Bet C O B).
        eBetween.
        apply(perp2_preserves_bet13 O B C B' C'); Between.
          intro.
          apply H.
ColR.
  (*        assert(Col O A B').

            apply (col_transitivity_1 _ C); Col.
          apply (col_transitivity_1 _ B'); Col.
        apply perp2_sym.
        auto.*)
      assert(Bet A' O C').
        apply(perp2_preserves_bet13 O A C A' C');Between.
        ColR.
apply perp2_sym.
assumption.
repeat split; auto.
apply(l5_2 C' O A' B'); Between.

    induction H15.
      assert(Bet O C B).
eBetween.
      assert(Bet O B' C').
        apply(perp2_preserves_bet23 O C B B' C'); Col.
          intro.
          apply H.
ColR.
        apply perp2_sym.
        auto.
      assert(Bet O A' C').
        apply(perp2_preserves_bet23 O C A A' C'); Between.
 ColR.
        intro.
        apply H.
ColR.
      repeat split; auto.
apply(l5_3 O A' B' C'); auto.

    induction H15.
      assert(Bet O A C).
eBetween.
      assert(Bet O C' A').
        apply(perp2_preserves_bet23 O A C C' A'); auto.
ColR.
          intro.
          apply H.
ColR.
        apply perp2_sym.
        auto.
      assert(Bet O C B).
eBetween.
      assert(Bet O B' C').
        apply(perp2_preserves_bet23 O C B B' C'); auto.
          intro.
          apply H.
ColR.
        apply perp2_sym.
        auto.
repeat split; auto.
right.
eBetween.

(*      assert(Bet O B' A').
eBetween.
*)
    assert(Bet O A C).
eBetween.
    assert( Bet O B C).
eBetween.

    assert(Bet O C' B').
      apply(perp2_preserves_bet23  O B C C' B'); Col.
      intro.
      apply H.
ColR.
    assert(Bet O C' A').
      apply(perp2_preserves_bet23  O A C C' A'); auto.
ColR.
        intro.
        apply H.
ColR.
      apply perp2_sym.
      auto.
    repeat split; auto.
    apply (l5_1 _ C'); auto.
Qed.
l13_10_aux5
Proof.
    intros.
    assert(A' <> O).
      intro.
      subst A'.
      apply H.
      Col.
    induction H10.
    spliter.
    induction H13.
      eapply (l13_10_aux4 A B C _ _ C'); auto.
    apply l6_6.
    apply(l13_10_aux4 B A C B' A' C'); try assumption.
      intro.
      apply H.
      ColR.
      Col.
      ColR.
      Col.
      ColR.
      apply perp2_sym.
      assumption.
    apply perp2_sym.
    auto.
Qed.
per_per_perp
Proof.
    intros.
    induction H1.
      assert(HH:=H2).
      apply per_perp_in in H2; auto.
      apply perp_in_perp_bis in H2.
      induction H2.
        apply perp_not_eq_1 in H2.
        tauto.
      apply perp_sym.
      apply (perp_col _ B); auto.
        Perp.
      apply col_permutation_5.
      eapply (per_per_col _ _ A); Perp.
    assert(HH:=H3).
    apply per_perp_in in H3; auto.
    apply perp_in_perp_bis in H3.
    induction H3.
      apply perp_not_eq_1 in H3.
      tauto.
    apply perp_sym.
    apply perp_left_comm.
    apply (perp_col _ B); auto.
      Perp.
    apply col_permutation_5.
    eapply (per_per_col _ _ A); Perp.
Qed.
l13_10
Proof.
    intros.
    assert(HH8:= H8).
    assert(HH9:= H9).
    assert(Col O A C).
      apply (col_transitivity_1 _ B); Col.
    assert(Col O A' C').
      apply (col_transitivity_1 _ B'); Col.
    assert(A <> O).
      intro.
      subst A.
      apply H.
      Col.
    assert(~ Col A B' O).
      intro.
      apply H.
      apply (col_transitivity_1 _ B'); Col.
    apply perp2_perp_in in HH8.
      ex_and HH8 L.
      ex_and H14 L'.
      apply perp2_perp_in in HH9.
        ex_and HH9 M.
        ex_and H19 M'.
        assert(HH:=l8_18_existence A B' O H13).
        ex_and HH N.
        unfold Perp2.
        exists O.
        exists N.
        repeat split.
          Col.
          Perp.
        assert(HH:=lg_exists O A).
        ex_and HH la.
        assert(HH:=lg_exists O B).
        ex_and HH lb.
        assert(HH:=lg_exists O C).
        ex_and HH lc.
        assert(HH:=lg_exists O A').
        ex_and HH la'.
        assert(HH:=lg_exists O B').
        ex_and HH lb'.
        assert(HH:=lg_exists O C').
        ex_and HH lc'.
        assert(HH:=lg_exists O L).
        ex_and HH ll.
        assert(HH:=lg_exists O L').
        ex_and HH ll'.
        assert(HH:=lg_exists O M).
        ex_and HH lm.
        assert(HH:=lg_exists O M').
        ex_and HH lm'.
        assert(HH:=lg_exists O N).
        ex_and HH ln.
        assert(O <> L).
          apply perp_in_perp_bis in H17.
          induction H17.
            apply perp_not_eq_1 in H17.
            tauto.
          apply perp_not_eq_1 in H17.
          auto.
        assert(O <> L').
          apply perp_in_perp_bis in H18.
          induction H18.
            apply perp_not_eq_1 in H18.
            tauto.
          apply perp_not_eq_1 in H18.
          auto.
        assert(~ Col O B B').
          intro.
          apply H.
          assert(Col O A B').
            eapply (col_transitivity_1 _ B); Col.
          eapply (col_transitivity_1 _ B'); Col.
        assert(~ Col O C C').
          intro.
          apply H.
          assert(Col O A C').
            eapply (col_transitivity_1 _ C); Col.
          eapply (col_transitivity_1 _ C'); Col.
        assert(exists a, Q_CongA_Acute a /\ Lcos ll lb a /\ Lcos ll' lc a).
          induction(eq_dec_points B L).
            subst L.
            assert(C = L').
              eapply (l6_21 O B B' L'); Col.
              intro.
              subst L'.
              contradiction.
            subst L'.
            apply (l13_10_aux2 O B C); Col.
          apply (l13_10_aux1 O B C L L'); Col.
            apply perp_in_perp_bis in H17.
            induction H17.
              apply perp_not_eq_1 in H17.
              tauto.
            apply perp_sym.
            apply perp_comm.
            eapply (perp_col _ C');auto.
            Perp.
          apply perp_in_perp_bis in H18.
          induction H18.
            apply perp_not_eq_1 in H18.
            tauto.
          apply perp_sym.
          apply perp_comm.
          eapply (perp_col _ B'); auto.
            intro.
            subst L'.
            assert(Col O B L).
              eapply (col_transitivity_1 _ C); Col.
            apply H52.
            apply(l6_21 O C C' B B L); Col.
            intro.
            subst C'.
            unfold Perp_at in H17.
            tauto.
          Perp.
        ex_and H52 l'.
        assert(exists a, Q_CongA_Acute a /\ Lcos ll lc' a /\ Lcos ll' lb' a).
          induction(eq_dec_points C' L).
            subst L.
            assert(B' = L').
              eapply (l6_21 O C' C L'); Col.
              intro.
              subst L'.
              apply H51.
              Col.
            subst L'.
            eapply (l13_10_aux2 O C' B'); Col.
          apply (l13_10_aux1 O C' B' L L'); Col.
            apply perp_in_perp_bis in H17.
            induction H17.
              apply perp_not_eq_1 in H17.
              tauto.
            apply perp_sym.
            apply perp_comm.
            eapply (perp_col _ B); Col.
            Perp.
          apply perp_in_perp_bis in H18.
          induction H18.
            apply perp_not_eq_1 in H18.
            tauto.
          apply perp_sym.
          apply perp_comm.
          eapply (perp_col _ C);Col.
            intro.
            subst L'.
            assert(Col O C' L).
              eapply (col_transitivity_1 _ B'); Col.
            apply H55.
            apply(l6_21 O B' B C' C' L); Col.
            intro.
            subst C'.
            unfold Perp_at in H17.
            tauto.
          Perp.
        ex_and H55 l.
        assert(exists a, Q_CongA_Acute a /\ Lcos lm lc a /\ Lcos lm' la a).
          induction (eq_dec_points C M).
            subst M.
            assert(A = M').
              eapply (l6_21 O C C' M'); Col.
              intro.
              subst M'.
              contradiction.
            subst M'.
            apply (l13_10_aux2 O C A); Col.
          apply (l13_10_aux1 O C A M M'); Col.
            apply perp_in_perp_bis in H22.
            induction H22.
              apply perp_not_eq_1 in H22.
              tauto.
            apply perp_sym.
            apply perp_comm.
            eapply (perp_col _ A');auto.
            Perp.
          apply perp_in_perp_bis in H23.
          induction H23.
            apply perp_not_eq_1 in H23.
            tauto.
          apply perp_sym.
          apply perp_comm.
          eapply (perp_col _ C'); auto.
            intro.
            subst M'.
            assert(Col O C M).
              eapply (col_transitivity_1 _ A); Col.
            apply H58.
            apply(l6_21 O A A' C C M); Col.
            intro.
            subst A'.
            unfold Perp_at in H22.
            tauto.
          Perp.
        ex_and H58 m'.
        assert(exists a, Q_CongA_Acute a /\ Lcos lm la' a /\ Lcos lm' lc' a).
          induction(eq_dec_points A' M).
            subst M.
            assert(C' = M').
              eapply (l6_21 O A' A M'); Col.
              intro.
              subst M'.
              apply H.
              Col.
            subst M'.
            eapply (l13_10_aux2 O A' C'); Col.
            intro.
            subst A'.
            apply H.
            Col.
          apply (l13_10_aux1 O A' C' M M'); Col.
            apply perp_in_perp_bis in H22.
            induction H22.
              apply perp_not_eq_1 in H22.
              tauto.
            apply perp_sym.
            apply perp_comm.
            eapply (perp_col _ C);Col.
            Perp.
          apply perp_in_perp_bis in H23.
          induction H23.
            apply perp_not_eq_1 in H23.
            tauto.
          apply perp_sym.
          apply perp_comm.
          eapply (perp_col _ A);Col.
            intro.
            subst M'.
            assert(Col O A' M).
              eapply (col_transitivity_1 _ C'); Col.
            apply H61.
            apply(l6_21 O C' C A' A' M); Col.
            intro.
            subst A'.
            unfold Perp_at in H22.
            tauto.
          Perp.
        ex_and H61 m.
        assert(exists a, Q_CongA_Acute a /\ Lcos ln la a).
          assert(exists a, Q_CongA_Acute a /\ a A O N).
            apply(anga_exists A O N).
              intro.
              subst A.
              apply H.
              Col.
              apply perp_not_eq_2 in H25.
              auto.
            induction(eq_dec_points A N).
              subst N.
              apply acute_trivial.
              intro.
              subst A.
              apply H.
              Col.
            eapply (perp_acute _ _ N).
              Col.
            apply perp_in_left_comm.
            apply perp_perp_in.
            apply perp_sym.
            apply (perp_col _ B').
              auto.
              Perp.
            Col.
          ex_and H64 n'.
          exists n'.
          split.
            auto.
          unfold Lcos.
          repeat split; auto.
          exists O.
          exists N.
          exists A.
          repeat split; auto.
            induction(eq_dec_points A N).
              subst N.
              apply l8_2.
              apply l8_5.
            apply perp_in_per.
            apply perp_in_comm.
            apply perp_perp_in.
            apply perp_left_comm.
            apply (perp_col _ B').
              auto.
              Perp.
            Col.
          apply anga_sym; auto.
        ex_and H64 n'.
        assert(exists a, Q_CongA_Acute a /\ Lcos ln lb' a).
          assert(exists a, Q_CongA_Acute a /\ a B' O N).
            apply(anga_exists B' O N).
              intro.
              subst B'.
              apply H50.
              Col.
              apply perp_not_eq_2 in H25.
              auto.
            induction(eq_dec_points B' N).
              subst N.
              apply acute_trivial.
              auto.
            eapply (perp_acute _ _ N).
              Col.
            apply perp_in_left_comm.
            apply perp_perp_in.
            apply perp_sym.
            apply (perp_col _ A).
              auto.
              Perp.
            Col.
          ex_and H66 n.
          exists n.
          split.
            auto.
          unfold Lcos.
          repeat split; auto.
          exists O.
          exists N.
          exists B'.
          repeat split; auto.
            induction(eq_dec_points B' N).
              subst N.
              apply l8_2.
              apply l8_5.
            apply perp_in_per.
            apply perp_in_comm.
            apply perp_perp_in.
            apply perp_left_comm.
            apply (perp_col _ A).
              auto.
              Perp.
            Col.
          apply anga_sym; auto.
        ex_and H66 n.
        assert(Eq_Lcos lc l' lb' l).
          unfold Eq_Lcos.
          exists ll'.
          split; auto.
        assert(Eq_Lcos lb l' lc' l).
          unfold Eq_Lcos.
          exists ll.
          split; auto.
        assert(Eq_Lcos lc m' la' m).
          unfold Eq_Lcos.
          exists lm.
          split; auto.
        assert(Eq_Lcos la m' lc' m).
          unfold Eq_Lcos.
          exists lm'.
          split; auto.
        assert(Eq_Lcos la n' lb' n).
          unfold Eq_Lcos.
          exists ln.
          split; auto.
        assert(exists lp, Lcos lp lb n').
          apply(lcos_exists lb n'); auto.
          intro.
          unfold Q_Cong_Null in H73.
          spliter.
          ex_and H74 X.
          apply H0.
          eapply (cong_identity _ _ X).
          apply (lg_cong lb); auto.
          apply (lg_sym lb); auto.
        ex_and H73 bn'.
        assert(exists lp, Lcos lp ll n').
          apply(lcos_exists ll n'); auto.
          intro.
          unfold Q_Cong_Null in H73.
          spliter.
          ex_and H75 X.
          apply H48.
          apply (cong_identity _ _ X).
          apply (lg_cong ll); auto.
        ex_and H73 bl'n'.
        assert(exists lp, Lcos lp bn' l').
          apply(lcos_exists bn' l'); auto.
            apply lcos_lg_anga in H74.
            spliter.
            auto.
          assert(HH:= lcos_lg_not_null bn' lb n' H74 ).
          tauto.
        ex_and H73 bn'l'.
        assert(lcos2 bl'n' lb l' n').
          unfold lcos2.
          exists ll.
          split; auto.
        assert(lcos2 bn'l' lb n' l').
          unfold lcos2.
          exists bn'.
          split; auto.
        assert(EqL bl'n' bn'l').
          apply lcos2_comm in H77.
          apply (lcos2_uniqueness lb _ _ l' n'); auto.
        apply lcos_lg_anga in H75.
        apply lcos_lg_anga in H76.
        spliter.
        assert(Eq_Lcos2 lb l' n' lb n' l').
          unfold Eq_Lcos2.
          exists bl'n'.
          split; auto.
          eapply (lcos2_eql_lcos2 lb _ bn'l').
            auto.
            reflexivity.
          symmetry; auto.
        assert(Eq_Lcos2 lb l' n' lc' l n').
          apply lcos_eq_lcos2_eq; auto.
        assert(Eq_Lcos3 lb l' n' m lc' l n' m).
          apply lcos2_eq_lcos3_eq; auto.
        assert(Eq_Lcos3 lb l' n' m lc' m l n').
          unfold Eq_Lcos3 in H87.
          ex_and H87 lp.
          unfold Eq_Lcos3.
          exists lp.
          split; auto.
          apply lcos3_permut1.
          apply lcos3_permut2.
          auto.
        assert(Eq_Lcos3 la m' l n' lc' m l n').
          apply lcos_eq_lcos3_eq; auto.
        assert(Eq_Lcos3 lb l' n' m la m' l n').
          apply (lcos3_eq_trans _ _ _ _ lc' m l n'); auto.
          apply lcos3_eq_sym; auto.
        assert(Eq_Lcos3 lb l' n' m la n' m' l).
          unfold Eq_Lcos3 in H90.
          ex_and H90 lp.
          unfold Eq_Lcos3.
          exists lp.
          split; auto.
          apply lcos3_permut1.
          apply lcos3_permut2.
          auto.
        assert(Eq_Lcos3 la n' m' l lb' n m' l).
          apply lcos_eq_lcos3_eq; auto.
        assert(Eq_Lcos3 lb l' n' m lb' n m' l).
          apply (lcos3_eq_trans _ _ _ _ la n' m' l); auto.
        assert(Eq_Lcos3 lb l' n' m lb' l n m').
          unfold Eq_Lcos3 in H93.
          ex_and H93 lp.
          unfold Eq_Lcos3.
          exists lp.
          split; auto.
          apply lcos3_permut1.
          apply lcos3_permut2.
          auto.
        assert(Eq_Lcos3 lb' l n m' lc l' n m').
          apply lcos_eq_lcos3_eq; auto.
          apply lcos_eq_sym; auto.
        assert(Eq_Lcos3 lb l' n' m lc l' n m').
          apply (lcos3_eq_trans _ _ _ _ lb' l n m'); auto.
        assert(Eq_Lcos3 lb l' n' m lc m' l' n).
          unfold Eq_Lcos3 in H96.
          ex_and H96 lp.
          unfold Eq_Lcos3.
          exists lp.
          split; auto.
          apply lcos3_permut1.
          apply lcos3_permut2.
          auto.
        assert(Eq_Lcos3 la' m l' n lc m' l' n).
          apply lcos_eq_lcos3_eq; auto.
          apply lcos_eq_sym; auto.
        assert(Eq_Lcos3 lb l' n' m la' m l' n).
          apply (lcos3_eq_trans _ _ _ _ lc m' l' n); auto.
          apply lcos3_eq_sym; auto.
        assert(Eq_Lcos3 lb l' n' m la' n l' m).
          unfold Eq_Lcos3 in H99.
          ex_and H99 lp.
          unfold Eq_Lcos3.
          exists lp.
          split; auto.
          apply lcos3_permut2.
          auto.
        assert(Eq_Lcos2 lb l' n' la' n l').
          apply (lcos3_lcos2 _ _ _ _ _ _ m); auto.
        assert(Eq_Lcos2 lb n' l' la' n l').
          unfold Eq_Lcos2 in H101.
          ex_and H101 lp.
          unfold Eq_Lcos2.
          exists lp.
          split; auto.
          apply lcos2_comm.
          auto.
        assert(Eq_Lcos lb n' la' n).
          apply (lcos2_lcos) in H102.
          auto.
        clear H85 H86 H87 H88 H89 H90 H91 H92 H93 H94 H95 H96 H97 H98 H99 H100 H101 H102.
(*************** we construct the length ln'  ********************)
        unfold Eq_Lcos in H103.
        ex_and H103 ln'.
        assert(O <> N).
          apply perp_not_eq_2 in H25; auto.
        apply lcos_lg_anga in H85.
        spliter.
(*************** we prove : n' A O N  ********************)
        assert(n' A O N).
          apply(lcos_per_anga _ _ _ la ln); auto.
          induction(eq_dec_points A N).
            subst N.
            apply l8_2.
            apply l8_5.
          apply perp_in_per.
          apply perp_in_comm.
          apply perp_perp_in.
          apply perp_left_comm.
          apply (perp_col _ B'); Col.
(*************** we prove : n B O N  ********************)
        assert(n B' O N).
          apply(lcos_per_anga _ _ _ lb' ln); auto.
          induction(eq_dec_points B' N).
            subst N.
            apply l8_2.
            apply l8_5.
          apply perp_in_per.
          apply perp_in_comm.
          apply perp_perp_in.
          apply perp_left_comm.
          apply (perp_col _ A); Col.
          Perp.
(*************** two cases  ********************)
        assert(Bet A O B \/ Out O A B \/ ~ Col A O B).
          apply(or_bet_out A O B); auto.
(*************** case : Bet A O B  ********************)
        induction H93.
(*************** we extend NO with N' such as ln' O N' ********************)
          assert(HH:=ex_point_lg_bet ln' N O H89).
          ex_and HH N'.
          assert(O <> N').
            intro.
            subst N'.
            assert(HH:=lcos_lg_not_null ln' lb n' H85).
            spliter.
            apply H96.
            unfold Q_Cong_Null.
            split; auto.
            exists O.
            auto.
          assert(A' <> B).
            intro.
            subst A'.
            contradiction.
(*************** we prove (Per O N' B) using Lcos ln' lb n'  ********************)        
            assert(Per O N' B).
            apply(lcos_per O N' B ln' lb n'); auto.
            assert(CongA N O A B O N').
(*************** pair of vertical angles (angles opposs par Le sommet) ********************)  
              apply(l11_13 N' O A A O N' N B ); Between.
              apply conga_left_comm.
              apply conga_refl; auto.
            apply (anga_conga_anga n' A O N); auto.
            apply conga_comm.
            auto.
(*************** we prove (Per O N' A') usinglcos ln' la' n  ********************) 
          assert(Per O N' A').
            apply(lcos_per O N' A' ln' la' n); auto.
            assert(CongA N O B' A' O N').
              apply(l11_13 N' O B' B' O N' N A' ); Between.
                apply conga_left_comm.
                apply conga_refl; auto.
                apply between_symmetry.
                apply(l13_10_aux3 A B C A' B' C' O); auto.
              intro.
              subst A'.
              apply H.
              Col.
            eapply (anga_conga_anga  n B' O N); auto.
            apply conga_comm.
            auto.
(*************** we prove (Perp O N B A')  ********************) 
          apply (perp_col _ N'); Col.
          apply per_per_perp; auto.
          induction(eq_dec_points N' B).
            right.
            subst N'.
            auto.
          left.
          auto.
        induction H93.
(*************** case : out O A B  ********************)
(*************** we construct N' on the half-line ON such as ln' O N' /\ out O N' N  ********************)        
          assert(exists N' : Tpoint, ln' O N' /\ Out O N' N).
            apply(ex_point_lg_out ln' O N H87 H89).
            assert(HH:=lcos_lg_not_null ln' la' n H86).
            spliter.
            auto.
          ex_and H94 N'.
(*************** we prove (Per O N' B) using Lcos ln' lb n'  ********************)
          assert(Per O N' B).
            apply(lcos_per O N' B ln' lb n'); auto.
            assert(CongA A O N B O N').
              apply(out_conga A O N A O N A N B N').
                apply conga_refl ; auto.
                apply out_trivial; auto.
                apply out_trivial; auto.
                auto.
              apply l6_6.
              auto.
            apply (anga_conga_anga n' A O N); auto.
            apply conga_right_comm.
            auto.
(*************** we prove (Per O N' A) using Lcos ln' la' n  ********************)
          assert(Per O N' A').
            apply(lcos_per O N' A' ln' la' n); auto.
            assert(CongA B' O N A' O N').
              apply(out_conga B' O N B' O N B' N A' N').
                apply conga_refl; auto.
                apply out_trivial; auto.
                apply out_trivial; auto.
                eapply (l13_10_aux5 B A C B' A' C'); Col.
                  intro.
                  subst A'.
                  apply H.
                  Col.
                  apply perp2_sym.
                  auto.
                  apply perp2_sym.
                  auto.
                apply l6_6.
                auto.
              apply l6_6.
              auto.
            apply (anga_conga_anga n B' O N); auto.
            apply conga_right_comm.
            auto.
          apply(perp_col _ N').
            auto.
            eapply (per_per_perp); auto.
              intro.
              subst N'.
              unfold Out in H95.
              tauto.
              intro.
              subst A'.
              contradiction.
            induction(eq_dec_points N' B).
              subst N'.
              right.
              intro.
              subst A'.
              contradiction.
            left.
            auto.
          apply out_col in H95.
          Col.
        apply False_ind.
        apply H93.
        Col.
      split; intro; apply H; ColR.
      split; intro; apply H; ColR.
Qed.
par_perp2
Proof.
    intros.
    apply par_distincts in H.
    spliter.
    unfold Perp2.
    assert(HH:= perp_exists P A B H0).
    ex_and HH Q.
    exists P.
    exists Q.
    repeat split.
      Col.
      Perp.
    apply perp_sym.
    apply (par_perp_perp A B); auto.
    apply perp_sym; auto.
Qed.
l13_11
Proof.
    intros.
    assert(HH:=par_perp2 B C' C B' O H8).
    assert(HP:=par_perp2 C A' A C' O H9).
    assert(HQ:=perp2_par A B' B A' O).
    apply HQ.
    apply(l13_10 A B C A' B' C' O); auto.
Qed.
l13_14
Proof.
    intros.
    assert(HP:= H).
    unfold Par_strict in HP.
    spliter.
    assert(~Col O A A').
      intro.
      apply H11.
      exists A'.
      split; Col.
    induction(eq_dec_points A C).
      subst C.
      induction H6.
        apply False_ind.
        apply H6.
        exists A.
        split; Col.
      spliter.
      assert(A' =  C').
        eapply (l6_21 A C' O' A'); Col.
        intro.
        apply H11.
        exists A.
        split.
          Col.
        eapply (col_transitivity_1 _ C').
          intro.
          subst C'.
          apply H11.
          exists A.
          Col.
          Col.
        Col.
      subst C'.
      Par.
    assert(A' <> C').
      intro.
      subst C'.
      induction H6.
        apply H6.
        exists A'.
        split; Col.
      spliter.
      apply H13.
      eapply (l6_21 A A' O A); Col.
    assert(Par_strict A C A' C').
      unfold Par_strict.
      repeat split; auto; try apply all_coplanar.
      intro.
      apply H11.
      ex_and H15 X.
      exists X.
      split.
        ColR.
      ColR.
    assert(Plg A C A' C').
      apply(pars_par_plg A C A' C').
        auto.
      apply par_right_comm.
      auto.
    induction(eq_dec_points B C).
      subst C.
      assert(B' = C').
        eapply (l6_21 B C' A' C').
          intro.
          apply H11.
          exists B.
          split.
            Col.
          ColR.
          auto.
          induction H7.
            apply False_ind.
            apply H7.
            exists B.
            split; Col.
          spliter.
          Col.
          Col.
          ColR.
          Col.
      subst.
      Par.
    assert(B' <> C').
      intro.
      subst C'.
      induction H7.
        apply H7.
        exists B'.
        split; Col.
      spliter.
      apply H17.
      eapply (l6_21 A C B' B).
        intro.
        induction H6.
          apply H6.
          exists C.
          split; Col.
        spliter.
        apply H15.
        exists B'.
        split; Col.
        auto.
        ColR.
        Col.
        Col.
        Col.
    assert(Par_strict B C B' C').
      unfold Par_strict.
      repeat split; auto; try apply all_coplanar.
      intro.
      apply H11.
      ex_and H19 X.
      exists X.
      split.
        assert(Col X O B).
          ColR.
        induction(eq_dec_points O B).
          subst O.
          ColR.
        ColR.
      assert(Col X O' B').
        ColR.
      induction(eq_dec_points O' B').
        subst O'.
        ColR.
      ColR.
    assert(Plg B C B' C').
      apply(pars_par_plg B C B' C').
        auto.
      apply par_right_comm.
      auto.
    assert(Parallelogram A C A' C').
      apply plg_to_parallelogram.
      auto.
    assert(Parallelogram B C B' C').
      apply plg_to_parallelogram.
      auto.
    apply plg_mid in H21.
    apply plg_mid in H22.
    ex_and H21 M.
    ex_and H22 N.
    assert(M = N).
      eapply (l7_17 C C'); auto.
    subst N.
    assert(Parallelogram A B A' B').
      apply(mid_plg A B A' B' M).
        left.
        intro.
        subst A'.
        apply H12.
        Col.
        assumption.
      assumption.
    apply par_right_comm.
    induction(eq_dec_points A B).
      subst B.
      assert(B' = A').
        eapply (symmetric_point_uniqueness A M); auto.
      subst B'.
      apply par_reflexivity.
      intro.
      subst A'.
      apply H12.
      Col.
    apply plg_par; auto.
    intro.
    subst A'.
    apply H11.
    exists B.
    split; Col.
Qed.
l13_15_1
Proof.
    intros.
    assert(~Col B A' B').
      intro.
      apply H1.
      exists B.
      split; Col.
    assert(~Col A A' B').
      intro.
      apply H1.
      exists A.
      split; Col.
    assert(B <> O).
      intro.
      subst B.
      apply H1.
      exists A'.
      split; Col.
    assert(A <> O).
      intro.
      subst A.
      apply H1.
      exists B'.
      split; Col.
    assert(~ Col A' A C).
      eapply (par_not_col A' C').
        Par.
      Col.
    assert(C <> O).
      intro.
      subst C.
      apply H10.
      Col.
    assert(~Col O A B).
      intro.
      apply H1.
      exists O.
      split.
        Col.
      assert(Col O A B').
        apply (col_transitivity_1 _ B); Col.
      apply (col_transitivity_1 _ A); Col.
    assert(~Col O A C).
      intro.
      apply H2.
      exists O.
      split.
        Col.
      assert(Col O A C').
        apply (col_transitivity_1 _ C); Col.
      apply (col_transitivity_1 _ A); Col.
    assert(~ Col A' B' C').
      intro.
      apply H.
      assert(Par A' C' A B).
        apply(par_col_par_2 A' B' A B C').
          intro.
          subst C'.
          unfold Par_strict in H2.
          tauto.
          auto.
        left.
        Par.
      assert(Par A C A B).
        apply(par_trans A C A' C'); Par.
      induction H16.
        apply False_ind.
        apply H16.
        exists A.
        split; Col.
      spliter; Col.
    induction(Col_dec O B C).
      right.
      repeat split.
        intro.
        subst C.
        apply H.
        Col.
        intro.
        subst C'.
        apply H14.
        Col.
        assert(Col O B C').
          apply (col_transitivity_1 _ C); Col.
        apply (col_transitivity_1 _ O); Col.
      assert(Col O C B').
        apply (col_transitivity_1 _ B); Col.
      apply (col_transitivity_1 _ O); Col.
    assert(B' <> O).
      intro.
      subst B'.
      apply H7.
      Col.
    assert(B' <> O).
      intro.
      subst B'.
      apply H7.
      Col.
    assert(A' <> O).
      intro.
      subst A'.
      apply H6.
      Col.
    (* TODO modify assert_diffs in order to use par_not_col automatically *)
    assert(~ Col A A' C').
      eapply (par_not_col A C).
        Par.
      Col.
    assert(C' <> O).
      intro.
      subst C'.
      apply H19.
      Col.
    assert(~Col O A' B').
      intro.
      apply H1.
      exists O.
      split.
        assert(Col O A' B).
          apply (col_transitivity_1 _ B'); Col.
        apply (col_transitivity_1 _ A'); Col.
      Col.
    assert(~Col O A' C').
      intro.
      apply H2.
      exists O.
      split.
        ColR.
      Col.
    assert(~Col B' A B).
      intro.
      apply H1.
      exists B'.
      Col.
    assert(~Col A' A B).
      intro.
      apply H1.
      exists A'.
      split; Col.
    (********** construct L *********)
    assert(exists C : Tpoint, exists D : Tpoint, C <> D /\ Par O B C D /\ Col A C D).
      apply(parallel_existence O B A).
      auto.
    ex_and H25 X.
    ex_and H26 Y.
    assert(exists L : Tpoint, Col L X Y /\ Col L A' C').
      apply(not_par_inter_exists X Y A' C').
      intro.
      apply H0.
      eapply (par_trans O B X Y).
        auto.
      apply par_symmetry.
      apply (par_trans A C A' C').
        left.
        auto.
      Par.
    ex_and H28 L.
    assert(A <> L).
      intro.
      subst L.
      contradiction.
    assert(Par A L O B').
      apply par_symmetry.
      apply(par_col_par_2 _ B); Col.
      apply par_symmetry.
      apply par_left_comm.
      induction(eq_dec_points X L).
        subst X.
        apply (par_col_par_2 _ Y); Col.
        Par.
      apply (par_col_par_2 _ X); try auto.
        ColR.
      apply par_left_comm.
      apply (par_col_par_2 _ Y); Col.
      Par.
    (********** construct M *********)
    assert(~ Par X Y O C).
      intro.
      assert(Par O B O C).
        apply (par_trans O B X Y); Par.
      induction H33.
        apply H33.
        exists O.
        split; Col.
      spliter.
      apply H15.
      Col.
    assert(HH:=not_par_inter_exists X Y O C H32).
    ex_and HH M.
    assert(A <> M).
      intro.
      subst M.
      apply H13.
      Col.
    assert(Par O B A M).
      apply (par_col_par_2 _ B'); Col.
      apply par_symmetry.
      apply (par_col_par_2 _ L); try auto.
      ColR.
    (*************** construct N ********************)
    assert(L <> A').
      intro.
      subst L.
      clean_trivial_hyps.
      apply H12.
      induction(eq_dec_points A' X).
        subst X.
        assert(Par A' A O B).
          apply (par_col_par_2 _ Y); Col.
          Par.
        induction H29.
          apply False_ind.
          apply H29.
          exists O.
          split; Col.
        spliter.
        ColR.
      assert(Par X A' O B).
        apply (par_col_par_2 _ Y); Col.
        Par.
      assert(Par A' A O B).
        apply (par_col_par_2 _ X); try auto.
          ColR.
        Par.
      induction H38.
        apply False_ind.
        apply H38.
        exists O.
        split; Col.
      spliter.
      Col.
    assert(~ Par L B' A' B').
      intro.
      induction H38.
        apply H38.
        exists B'.
        split;Col.
      spliter.
      apply H14.
      eapply (col_transitivity_1 _ L); Col.
    assert(~ Par A B L B').
      apply(par_not_par A' B' A B L B').
        left.
        Par.
      intro.
      apply H38.
      Par.
    assert(HH:=not_par_inter_exists A B L B' H39 ).
    ex_and HH N.
    assert(Par_strict A L O B').
      induction H31.
        auto.
      spliter.
      apply False_ind.
      apply H12.
      apply (col_transitivity_1 _ B'); Col.
    assert(A <> N).
      intro.
      subst N.
      apply H42.
      exists B'; Col.
    assert(Par A N A' B').
      apply (par_col_par_2 _ B); Col.
      left.
      Par.
    clean_duplicated_hyps.
    (**********************************)
    assert(Par O N L A').
      induction(Par_dec A O N L).
        assert(Par_strict A O N L).
          induction H17.
            auto.
          spliter.
          apply False_ind.
          apply H23.
          assert(Col N A B').
            eapply (col_transitivity_1 _ L); Col.
          apply col_permutation_2.
          eapply (col_transitivity_1 _ N); Col.
        apply(l13_14 A O A' A N L N B'); Col.
          Par.
        Par.
      assert(N <> L).
        intro.
        subst L.
        apply H42.
        exists B.
        split; Col.
      assert(HH:=not_par_inter_exists A O N L H17).
      ex_and HH P.
      apply par_right_comm.
      assert(P <> L).
        intro.
        subst P.
        apply H42.
        exists O.
        split; Col.
      assert(P <> O).
        intro.
        subst P.
        apply H42.
        exists L.
        split.
          Col.
        apply (col_transitivity_1 _ N); Col.
      assert(L <> B').
        intro.
        subst L.
        apply H42.
        exists B'.
        split; Col.
      assert(A <> P).
        intro.
        subst P.
        assert(Col A B L).
          apply (col_transitivity_1 _ N); Col.
        assert(Col L A B').
          apply (col_transitivity_1 _ N); Col.
        apply H39.
        apply par_symmetry.
        right.
        repeat split.
          assumption.
          intro.
          subst B.
          apply H23.
          Col.
          Col.
        ColR.
      assert(P <> N).
        intro.
        subst P.
        apply H12.
        apply col_permutation_2.
        apply (col_transitivity_1 _ N); Col.
      assert(A' <> P).
        intro.
        subst P.
        apply H38.
        right.
        repeat split; try assumption.
          intro.
          subst B'.
          apply H21.
          Col.
          ColR.
        Col.
      assert(B' <> P).
        intro.
        subst P.
        apply H21.
        apply (col_transitivity_1 _ A); Col.
      apply(l13_11 O A' A L N B' P); Par; try ColR.
      intro.
      apply H42.
      exists L.
      split.
        Col.
      assert(Col L O N).
        apply (col_transitivity_1 _ P); Col.
      apply (col_transitivity_1 _ N); Col.
    (* apply col_permutation_2.
    apply (col_transitivity_1 _ A); Col.
    apply col_permutation_1.
    apply (col_transitivity_1 _ O); Col.
    Col.
    apply col_permutation_2.
    apply (col_transitivity_1 _ L); Col.
    *)
    assert(Par A' C' O N).
      apply (par_col_par_2 _ L).
        intro.
        subst C'.
        apply H22.
        Col.
        Col.
      Par.
    assert(Par O N A C).
      apply (par_trans _ _ A' C'); Par.
    assert(Par N M B C).
      induction(Par_dec A N O C).
        assert(Par_strict A N O C).
          induction H47.
            auto.
          spliter.
          apply False_ind.
          apply H13.
          Col.
        apply par_right_comm.
        apply(l13_14 A N B A O C M O ); Par; Col.
      assert(HH:= not_par_inter_exists A N O C H47).
      ex_and HH P.
      assert(B <> P).
        intro.
        subst P.
        apply H15.
        Col.
      assert(A <> P).
        intro.
        subst P.
        apply H13.
        Col.
      assert(M <> P).
        intro.
        subst P.
        induction H36.
          apply H36.
          exists B.
          split.
            Col.
          apply col_permutation_2.
          apply (col_transitivity_1 _ N); Col.
        spliter.
        apply H12.
        apply col_permutation_2.
        apply (col_transitivity_1 _ M); Col.
      assert(O <> P).
        intro.
        subst P.
        induction H46.
          apply H46.
          exists A.
          split; Col.
        spliter.
        apply H13.
        Col.
      assert(P <> N).
        intro.
        subst P.
        induction H46.
          apply H46.
          exists C.
          split; Col.
        spliter.
        apply H13.
        Col.
      apply(l13_11 N B A C M O P); Par; try ColR.
      intro.
      assert(Col N A C) by ColR.
      apply H.
      ColR.
    (* apply col_permutation_2.
    apply (col_transitivity_1 _ A); Col.
    apply col_permutation_1.
    apply (col_transitivity_1 _ N); Col.
    apply col_permutation_2.
    apply (col_transitivity_1 _ O); Col.
    apply col_permutation_1.
    apply (col_transitivity_1 _ C); Col.
    *)
    assert(Par N M B' C').
      induction(Par_dec N B' O C').
        assert(Par_strict N B' O C').
          induction H48.
            auto.
          spliter.
          apply False_ind.
          induction H46.
            apply H46.
            exists C.
            split.
              ColR.
            Col.
          spliter.
          contradiction.
        assert(M <> L).
          intro.
          subst M.
          apply H49.
          exists L.
          split.
            Col.
          apply col_permutation_2.
          apply(col_transitivity_1 _ C); Col.
        assert(L <> C').
          intro.
          subst C'.
          apply H49.
          exists L.
          split; Col.
        assert(Par L M O B').
          apply (par_col_par_2 _ A); try assumption.
            auto.
            ColR.
          Par.
        assert(Par L C' O N).
          apply (par_col_par_2 _ A'); Col.
          Par.
        apply par_right_comm.
        apply(l13_14 B' N B' L O C' M O);sfinish.
      assert(HH:= not_par_inter_exists N B' O C' H48).
      ex_and HH P.
      assert(B' <> P).
        intro.
        subst P.
        apply H15.
        ColR.
      induction(eq_dec_points C'  L).
        subst L.
        assert(C' = M).
          induction (Col_dec O X C).
            apply (l6_21 O C Y X).
              intro.
              assert(Col O X Y) by ColR.
              induction H26.
                apply H26.
                exists O.
                split; Col.
              spliter.
              apply H12.
              apply(col3 X Y); Col.
              auto.
              Col.
              Col.
              Col.
              Col.
          apply (l6_21 O C X Y); Col.
        subst M.
        right.
        repeat split; try auto.
          intro.
          subst N.
          apply par_distincts in H47; spliter; auto.
          intro; subst; apply H14; Col.
          Col.
        Col.
      assert(L <> P).
        intro.
        subst P.
        apply H22.
        apply col_permutation_1.
        apply (col_transitivity_1 _ L); Col.
      induction (eq_dec_points L M).
        subst L.
        assert(C' = M).
          apply (l6_21 O C A' C'); Col.
            intro.
            apply H22.
            ColR.
            intro.
            subst C'.
            apply H22.
            Col.
            subst M.
            right.
            repeat split; try auto. Col. Col.
              assert(Par L M O B').
            apply (par_col_par_2 _ A); try assumption. ColR.
              Par.
            assert(Par L C' N O).
              apply (par_col_par_2 _ A'); Col.
              Par.
            assert(B' <> N).
              intro.
              subst N.
              contradiction.
            apply(l13_11  N B' L  C' M O P); Par.
              intro.
              assert(Col P B' C').
                apply (col_transitivity_1 _ N).
                  intro.
                  subst N.
                  induction H45.
                    apply H45.
                    exists C'.
                    split; Col.
                  spliter.
                  apply H22.
                  ColR.
                  Col.
                Col.
              assert(Col C' O B' ).
                apply (col_transitivity_1 _ P).
                  intro.
                  subst P.
                  clean_trivial_hyps.
                  assert(Col B' C' L).
                    apply (col_transitivity_1 _ N); Col.
                  apply H14.
                  ColR.
                  Col.
                Col.
              assert(Col O B C').
                apply (col_transitivity_1 _ B'); Col.
              apply H15.
              ColR.
              ColR.
              intro.
              subst M.
              assert(Col B' P L).
                apply (col_transitivity_1 _ N); Col.
              assert(Col L A B').
                assert(Col P A L).
                  apply (col3 X Y); Col.
                apply (col_transitivity_1 _ P); Col.
              apply H42.
              exists B'.
              split; Col.
              intro.
              subst P.
              assert(N = B).
                apply (l6_21 A B O B'); Col.
                  subst N.
                  induction H47.
                    apply H47.
                    exists B.
                    split; Col.
                  spliter.
                  assert(B = O).
                    apply (l6_21 O B' M C); Col.
                  subst B.
                  induction H56.
                    apply H56.
                    exists L.
                    split; Col.
                  tauto.
                  ColR.
                  ColR.
                  apply (par_trans _ _ N M); Par.
              Qed.
l13_15_2_aux
Proof.
    intros.
    assert(~Col O A B /\ ~Col O B C /\ ~Col O A C).
      induction H1; repeat split; intro.
        apply H1.
        exists A.
        split; Col.
        apply H1.
        exists C.
        split; Col.
        apply H1.
        exists O.
        split; Col.
        spliter.
        apply H; Col.
        spliter.
        apply H; Col.
      spliter.
      apply H; Col.
    spliter.
    assert( A <> O /\ B <> O /\ C <> O).
      repeat split; intro; subst O.
        apply H9.
        Col.
        apply H8.
        Col.
      apply H9.
      Col.
    spliter.
    assert( A' <> O).
      intro.
      subst A'.
      assert(Par O B A B).
        apply (par_col_par_2 _ B'); Col.
        left.
        Par.
      induction H13.
        apply H13.
        exists B.
        split; Col.
      spliter.
      contradiction.
    assert(B' <> O).
      intro.
      subst B'.
      assert(Par O A B A).
        apply(par_col_par_2 _ A'); Col.
        apply par_comm.
        apply par_symmetry.
        left.
        Par.
      induction H14.
        apply H14.
        exists A.
        split; Col.
      spliter.
      apply H7.
      Col.
    assert(C' <> O).
      intro.
      subst C'.
      assert(Par O A C A).
        apply (par_col_par_2 _ A'); Col.
        apply par_comm.
        apply par_symmetry.
        left.
        Par.
      induction H15.
        apply H15.
        exists A.
        split; Col.
      spliter.
      apply H9.
      Col.
    assert(~Col O A' B').
      intro.
      assert(Col O A B').
        apply (col_transitivity_1 _ A'); Col.
      apply H7.
      apply (col_transitivity_1 _ B'); Col.
    assert(~Col O B' C').
      intro.
      assert(Col O B C').
        apply (col_transitivity_1 _ B'); Col.
      apply H8.
      apply (col_transitivity_1 _ C'); Col.
    assert(~Col O A' C').
      intro.
      assert(Col O A C').
        apply (col_transitivity_1 _ A'); Col.
      apply H9.
      apply (col_transitivity_1 _ C'); Col.
    assert(A <> A').
      intro.
      subst A'.
      apply H3.
      exists A.
      split; Col.
    assert(B <> B').
      intro.
      subst B'.
      apply H2.
      exists B.
      split; Col.
    assert(C <> C').
      intro.
      subst C'.
      apply H3.
      exists C.
      split; Col.
    induction(Par_dec B C B' C').
      auto.
    assert(B <> C).
      intro.
      subst C.
      apply H.
      Col.
    assert(HP:=parallel_existence B C B' H23).
    ex_and HP X.
    ex_and H24 Y.
    assert(~Par X Y O C).
      intro.
      assert(Par O C B C).
        apply (par_trans _ _  X Y); Par.
      induction H28.
        apply H28.
        exists C.
        split; Col.
      spliter.
      contradiction.
    assert(HH:=not_par_inter_exists X Y O C H27).
    ex_and HH C''.
    assert(B' <> C'').
      intro.
      subst C''.
      assert(Col O B C).
        apply (col_transitivity_1 _ B'); Col.
      contradiction.
    assert(Par B' C'' B C ).
      induction(eq_dec_points B' X).
        subst X.
        apply (par_col_par_2 _ Y).
          auto.
          Col.
        Par.
      apply (par_col_par_2 _ X).
        auto.
        apply col_permutation_2.
        apply(col_transitivity_1 _ Y); Col.
      apply par_left_comm.
      apply (par_col_par_2 _ Y); Col.
      Par.
    assert(Par A C A' C'').
      eapply(l13_15_1 B A C B' A' C'' O); Col.
        apply par_strict_comm.
        auto.
      induction H31.
        Par.
      spliter.
      apply False_ind.
      apply H8.
      apply col_permutation_2.
      apply(col_transitivity_1 _ B'); Col.
    assert(C' <> C'').
      intro.
      subst C''.
      apply H22.
      Par.
    assert(Par A' C' A' C'').
      apply (par_trans _ _ A C).
        left.
        Par.
      Par.
    assert(C' = C'').
      apply (l6_21 A' C' O C); Col.
        induction H34.
        apply False_ind.
        apply H34.
        exists A'.
        split; Col.
        spliter.
        Col.
    contradiction.
Qed.
l13_15_2
Proof.
    intros.
    induction(Par_dec B C B' C').
      auto.
    assert(HH:=not_par_one_not_par B C B' C' O A H6).
    induction HH.
      apply (l13_15_2_aux A B C A' B' C' O); auto.
      intro.
      apply H7.
      Par.
    apply par_symmetry.
    assert(~ Col A' B' C').
      intro.
      apply H.
      assert(Par A' B' A' C').
        right.
        repeat split; Col.
          intro.
          subst B'.
          apply H1.
          exists A.
          split; Col.
        intro.
        subst C'.
        apply H2.
        exists A.
        split; Col.
      assert(Par A B A C).
        apply(par_trans _ _ A' B').
          left.
          auto.
        apply(par_trans _ _ A' C').
          Par.
        left.
        Par.
      induction H10.
        apply False_ind.
        apply H10.
        exists A.
        split; Col.
      spliter.
      Col.
    assert(B' <> O).
      intro.
      subst B'.
      assert(Par O A B A).
        apply (par_col_par_2 _ A'); Col.
          intro.
          subst A.
          apply H1.
          exists O.
          split; Col.
        apply par_comm.
        left.
        Par.
      induction H9.
        apply H9.
        exists A.
        split; Col.
      spliter.
      apply H1.
      exists O.
      split; Col.
    assert(Par O B O B').
      right.
      repeat split; Col.
      intro.
      subst B.
      apply par_distincts in H0.
      tauto.
    apply (l13_15_2_aux A' B' C' A B C O); Col; Par.
      intro.
      apply H7.
      apply par_symmetry.
      apply (par_col_par_2 _ A').
        intro.
        subst A.
        induction H0.
          apply H0.
          exists O.
          split; Col.
        spliter.
        apply H.
        Col.
        Col.
      Par.
    apply (par_trans _ _ O B).
      Par.
    apply (par_trans _ _ A C).
      Par.
    left.
    Par.
Qed.
l13_15
Proof.
    intros.
    induction(Par_dec O B A C).
      apply (l13_15_2 A B C A' B' C' O); Col; Par.
    apply (l13_15_1 A B C A' B' C' O); Col; Par.
Qed.
l13_15_par
Proof.
    intros.
    assert(Plg B' A' A B).
      apply(pars_par_plg B' A' A B).
        apply par_strict_left_comm.
        Par.
      Par.
    apply plg_to_parallelogram in H4.
    apply plg_permut in H4.
    assert(Plg  A' C' C A).
      apply(pars_par_plg  A' C' C A).
        apply par_strict_right_comm.
        Par.
      Par.
    apply plg_to_parallelogram in H5.
    apply plg_permut in H5.
    assert(Parallelogram B B' C' C \/ B = B' /\ A' = A /\ C = C' /\ B = C).
      apply(plg_pseudo_trans B B' A' A C C').
        apply plg_sym.
        auto.
      apply plg_comm2.
      apply plg_permut.
      apply plg_permut.
      auto.
    assert(Par B B' C C').
      apply (par_trans _ _ A A'); Par.
    induction H7.
      induction H6.
        assert(B <> B').
          apply par_distincts in H2.
          tauto.
        apply plg_par in H6.
          spliter.
          Par.
          auto.
        intro.
        subst C'.
        apply H7.
        exists B'.
        split; Col.
      spliter.
      subst C.
      subst C'.
      apply False_ind.
      apply H7.
      exists B.
      split; Col.
    induction H6.
      apply plg_par in H6.
        spliter.
        Par.
        spliter.
        auto.
      spliter.
      intro.
      subst C'.
      assert(Par A B A C).
        apply (par_trans _ _ A' B'); left; Par.
      induction H11.
        apply H11.
        exists A.
        split; Col.
      spliter.
      apply H.
      Col.
    spliter.
    subst B'.
    subst A'.
    subst C'.
    subst C.
    apply False_ind.
    apply H1.
    exists A.
    split; Col.
Qed.
l13_18_2
Proof.
    intros.
    spliter.
    assert(~ Col O A B).
      intro.
      apply H0.
      exists O.
      split.
        Col.
      apply(col_transitivity_1 _ A); Col.
        intro.
        subst A.
        apply H0.
        exists B'.
        split; Col.
      apply(col_transitivity_1 _ B); Col.
      intro.
      subst B.
      apply H0.
      exists A'.
      split; Col.
    assert(exists X : Tpoint, Col X B' C' /\ Col X O C).
      apply not_par_inter_exists, par_not_par with B C; Par.
      intro.
      induction H6.
        apply H6.
        exists C.
        split; Col.
      spliter.
      apply H2.
      exists B'.
      split;Col.
      apply col_permutation_2.
      apply (col_transitivity_1 _ O); Col.
      intro.
      subst O.
      apply H0.
      exists A'.
      split; Col.
    ex_and H6 C''.
    induction(Col_dec O C C').
      auto.
    apply False_ind.
    assert(Par C' C'' B C ).
      apply (par_col_par_2 _ B').
        intro.
        subst C''.
        Col.
        Col.
      apply par_left_comm.
      left.
      Par.
    assert(Par_strict C' C'' B C).
      induction H9.
        auto.
      spliter.
      apply False_ind.
      apply H8.
      apply col_permutation_2.
      apply (col_transitivity_1 _ C'').
        intro.
        subst C''.
        apply H2.
        exists C.
        split; Col.
        apply (col_transitivity_1 _ B); Col.
      Col.
    assert(~Col O B C).
      intro.
      apply H10.
      exists B'.
      split; Col.
      apply col_permutation_2.
      apply (col_transitivity_1 _ O); Col.
      intro.
      subst B.
      apply H5.
      Col.
    assert(Par B' C'' B C).
      apply (par_col_par_2 _ C') ; Col.
        intro.
        subst B'.
        apply H11.
        apply(col_transitivity_1 _ C''); Col.
        intro.
        subst C''.
        apply H0.
        exists A.
        split; Col.
      left.
      Par.
    assert(Par_strict B' C'' B C).
      induction H12.
        auto.
      spliter.
      apply False_ind.
      apply H11.
      apply col_permutation_2.
      apply (col_transitivity_1 _ B'); Col.
      intro.
      subst B'.
      apply H2.
      exists B.
      split; Col.
    assert(Par A C A' C'').
      apply(l13_15 B A C B' A' C'' O); Par; Col.
    assert(Par A' C' A' C'').
      apply (par_trans _ _ A C).
        left.
        Par.
      Par.
    induction H15.
      apply H15.
      exists A'.
      split; Col.
    spliter.
    assert(~ Col A' B' C').
      intro.
      apply H.
      apply(col_par_par_col A' B' C' A B C H19); left; Par.
    assert( C' = C'').
      apply(l6_21 A' C' B' C'); Col.
      intro.
      subst C'.
      apply H19.
      Col.
    subst C''.
    Col.
Qed.
l13_18_3
Proof.
    intros.
    spliter.
    assert(Par C C' A A').
      apply par_distincts in H3.
      spliter.
      assert(HH:= parallel_existence1 B B' C H5).
      ex_and HH P.
      induction(Par_dec C P B C).
        induction H7.
          apply False_ind.
          apply H7.
          exists C.
          split; Col.
        spliter.
        assert(Col P B' C).
          induction H6.
            apply False_ind.
            apply H6.
            exists B.
            split; Col.
          spliter.
          Col.
        assert(Col C B B').
          apply (col_transitivity_1 _ P); Col.
        apply False_ind.
        apply H2.
        exists B'.
        split; Col.
      assert(~ Par C P B' C').
        intro.
        apply H7.
        apply(par_trans _ _ B' C'); Par.
      assert(HH:=not_par_inter_exists C P B' C' H8).
      ex_and HH C''.
      induction(eq_dec_points B' C'').
        subst C''.
        apply False_ind.
        induction H6.
          apply H6.
          exists B'.
          split; Col.
        spliter; apply H2.
        exists B'.
        split; Col.
        apply col_permutation_1.
        apply(col_transitivity_1 _ P); Col.
      assert(Par C C'' B B' ).
        apply (par_col_par_2 _ P); Col.
          intro.
          subst C''.
          apply H2.
          exists C.
          split; Col.
        Par.
      assert(Par B' C'' B C).
        apply (par_col_par_2 _ C'); Col.
        left.
        Par.
      assert(~ Col A' B' C').
        intro.
        apply H.
        assert(Par C' A' B C).
          apply (par_col_par_2 _ B').
            intro.
            subst C'.
            unfold Par_strict in H1.
            tauto.
            Col.
          apply par_left_comm.
          left.
          Par.
        assert(Par B C A C).
          apply (par_trans _ _ A' C'); Par.
        induction H16.
          apply False_ind.
          apply H16.
          exists C.
          split; Col.
        spliter; Col.
      assert(Par A C A' C'').
        apply(l13_15_par B A C B' A' C'').
          intro.
          apply H.
          Col.
          apply par_strict_comm.
          Par.
          induction H13.
            Par.
          spliter.
          apply False_ind.
          apply H2.
          exists B'.
          split; Col.
          Par.
        Par.
      assert(C' = C'').
        apply (l6_21 C' A' B' C'); Col.
          intro.
          subst C'.
          apply H14.
          Col.
          eapply (col_par_par_col A C A); Col.
            apply par_right_comm.
            left.
            Par.
          Par.
      subst C''.
      apply (par_trans _ _ B B'); Par.
    split.
      Par.
    apply (par_trans _ _ A A'); Par.
Qed.
l13_18
Proof.
    intros.
    spliter.
    split.
      intros.
      apply (l13_18_2 A B C A' B' C' O); auto.
    split.
      intros.
      spliter.
      apply l13_18_3; auto.
    intros.
    spliter.
    apply (l13_15_par A B C A' B' C'); auto.
Qed.
l13_19_aux
Proof.
    intros.
    assert(HH:= not_par_inter_exists A B C D H16).
    ex_and HH E.
    assert(~Par A' B' O E).
      intro.
      assert(Par A B O E).
        apply (par_trans _ _ A' B'); Par.
      induction H23.
        apply H23.
        exists E.
        split; Col.
      spliter.
      apply H.
      apply (col_transitivity_1 _ E); Col.
    assert(HH:= not_par_inter_exists A' B' O E H22).
    ex_and HH E'.
    assert(C <> E).
      intro.
      subst E.
      apply H.
      apply col_permutation_2.
      apply (col_transitivity_1 _ C); Col.
    induction(Col_dec A D E).
      assert(B = D).
        apply(l6_21 O B A E); Col.
        intro.
        subst E.
        apply H.
        assert(Col A O D).
          apply (col_transitivity_1 _ C); Col.
        apply (col_transitivity_1 _ D); Col.
      subst D.
      assert(Par A' B' A' D').
        apply (par_trans _ _ A B); Par.
      induction H27.
        apply False_ind.
        apply H27.
        exists A'.
        split; Col.
      spliter.
      assert(B' = D').
        eapply(l6_21 A' B' O B'); Col.
        intro.
        apply H.
        apply (col_transitivity_1 _ A'); Col.
        apply (col_transitivity_1 _ B'); Col.
        apply (col_transitivity_1 _ B); Col.
      subst D'.
      Par.
    assert(B <> B').
      intro.
      subst B'.
      induction H17.
        apply H17.
        exists B.
        split; Col.
      spliter.
      apply H.
      apply col_permutation_2.
      apply (col_transitivity_1 _ A'); Col.
    assert(Par D E D' E').
      eapply (l13_15 A _ _ A' _ _ O); Col.
        induction H18.
          auto.
        spliter.
        apply False_ind.
        assert(Col A' A D).
          apply (col_transitivity_1 _ D'); Col.
        assert(Col A O D).
          apply (col_transitivity_1 _ A'); Col.
        apply H.
        apply (col_transitivity_1 _ D); Col.
        assert(Par A E A' E').
          apply(par_col_par_2 _ B); Col.
            intro.
            subst E.
            apply H26.
            Col.
          apply par_symmetry.
          apply(par_col_par_2 _ B'); Col.
            intro.
            subst E'.
            assert(Col O A E).
              apply(col_transitivity_1 _ A'); Col.
            apply H.
            apply col_permutation_2.
            apply(col_transitivity_1 _ E); Col.
            intro.
            subst E.
            apply H26.
            Col.
          Par.
        induction H28.
          auto.
        spliter.
        apply False_ind.
        assert(Col A' A E).
          apply(col_transitivity_1 _ E'); Col.
        assert(Col A O E).
          apply(col_transitivity_1 _ A'); Col.
        apply H.
        apply col_permutation_2.
        apply(col_transitivity_1 _ E); Col.
      apply(col_transitivity_1 _ B); Col.
    apply par_comm.
    induction(Col_dec B C E).
      assert(B = D).
        apply(l6_21 O B C E); Col.
        intro.
        apply H.
        apply (col_transitivity_1 _ C); Col.
      subst D.
      assert(Par A' B' A' D').
        apply (par_trans _ _ A B); Par.
      induction H30.
        apply False_ind.
        apply H30.
        exists A'.
        split; Col.
      spliter.
      assert(B' = D').
        eapply(l6_21 A' B' O B'); Col.
          Col5.
        ColR.
      subst D'.
      Par.
    assert(Par C E C' E').
      eapply (l13_15 B _ _ B' _ _ O); Col.
        induction H19.
          auto.
        spliter.
        apply False_ind.
        apply H.
        assert(Col B O C').
          apply (col_transitivity_1 _ B'); Col.
        apply (col_transitivity_1 _ C'); Col.
        assert(Par B E B' E').
          apply (par_col_par_2 _ A); Col.
            intro.
            subst E.
            apply H29.
            Col.
          apply par_symmetry.
          apply (par_col_par_2 _ A'); Col.
            intro.
            subst E'.
            assert(Col O B E).
              apply (col_transitivity_1 _ B'); Col.
            apply H.
            apply col_permutation_1.
            apply (col_transitivity_1 _ E); Col.
            intro.
            subst E.
            apply H29.
            Col.
          Par.
        induction H30.
          auto.
        spliter.
        apply False_ind.
        apply H.
        assert(Col O B' E').
          apply col_permutation_2.
          apply (col_transitivity_1 _ B); Col.
        assert(Col B' A' O).
          apply (col_transitivity_1 _ E'); Col.
        apply (col_transitivity_1 _ A'); Col.
        apply (col_transitivity_1 _ B'); Col.
      apply (col_transitivity_1 _ A); Col.
    apply(par_col_par_2 _ E); Col.
      intro.
      subst D.
      apply H.
      apply(col_transitivity_1 _ C); Col.
    apply par_symmetry.
    apply(par_col_par_2 _ E'); Col.
      intro.
      subst D'.
      apply H.
      apply(col_transitivity_1 _ C'); Col.
      apply (col_par_par_col D E C); Par.
      Col.
    Par.
Qed.
l13_19
Proof.
    intros.
    induction (eq_dec_points A A').
      subst A'.
      assert(B = B').
        apply(l6_21 A B O B); Col.
        induction H14.
          apply False_ind.
          apply H14.
          exists A.
          split; Col.
        spliter.
        Col.
      subst B'.
      assert(D = D').
        apply(l6_21 A D O B); Col.
          intro.
          apply H.
          apply (col_transitivity_1 _ D); Col.
          induction H15.
            apply False_ind.
            apply H15.
            exists A.
            split; Col.
          spliter.
          Col.
      subst D'.
      assert(C = C').
        apply(l6_21 B C O A); Col.
          intro.
          apply H.
          apply (col_transitivity_1 _ C); Col.
          induction H16.
            apply False_ind.
            apply H16.
            exists B.
            split; Col.
          spliter.
          Col.
      subst C'.
      apply par_reflexivity.
      intro.
      subst D.
      apply H.
      apply (col_transitivity_1 _ C); Col.
    induction(eq_dec_points A C).
      subst C.
      assert(A' = C').
        assert(Par A' B' B' C').
          apply (par_trans _ _ A B); Par.
        induction H18.
          apply False_ind.
          apply H18.
          exists B'.
          split; Col.
        spliter.
        eapply (l6_21 B' C' O A); Col.
        intro.
        apply H.
        apply (col_transitivity_1 _ B'); Col.
        apply (col_transitivity_1 _ C'); Col.
      subst C'.
      auto.
    induction(eq_dec_points A' C').
      subst C'.
      assert(A = C).
        assert(Par A B B C).
          apply (par_trans _ _ A' B'); Par.
        induction H19.
          apply False_ind.
          apply H19.
          exists B.
          split; Col.
        spliter.
        eapply (l6_21 B C O A'); Col.
          intro.
          apply H.
          apply (col_transitivity_1 _ C); Col.
          apply (col_transitivity_1 _ A); Col.
      contradiction.
    induction(Par_dec C D C' D').
      auto.
    assert(HH:=not_par_one_not_par C D C' D' A' B' H20).
    induction HH.
      assert(~ Par C D A B).
        intro.
        apply H21.
        apply (par_trans _ _ A B); Par.
      (*assert(HH:= not_par_inter C D C' D' A B H19).
      ex_and HH E.
      induction H21.*)
      apply (l13_19_aux A B C D A' B' C' D' O); Col.
      intro.
      apply H21.
      apply (par_trans _ _ A B); Par.
    apply par_symmetry.
    apply (l13_19_aux A' B' C' D' A B C D O); Par.
      intro.
      apply H.
      apply (col_transitivity_1 _ A'); Col.
      apply (col_transitivity_1 _ B'); Col.
      apply (col_transitivity_1 _ A); Col.
      Col.
      apply (col_transitivity_1 _ A); Col.
      apply (col_transitivity_1 _ B); Col.
      Col.
    apply (col_transitivity_1 _ B); Col.
Qed.
l13_19_par_aux
Proof.
    intros.
    assert(HH := not_par_inter_exists A B C D H17).
    ex_and HH E.
    assert(HH:= parallel_existence1 X A E H).
    ex_and HH Z.
    assert(~Par A B E Z).
      intro.
      assert(Par Y B E Z).
        apply (par_trans _ _ X A); Par.
      induction H24.
        apply H24.
        exists E.
        split; Col.
      spliter.
      induction H23.
        apply H23.
        exists A.
        split; Col.
      spliter.
      induction H25.
        apply H25.
        exists B.
        split; Col.
      spliter.
      apply H16.
      exists E.
      split;ColR.
    assert(~Par A' B' E Z).
      intro.
      apply H24.
      apply (par_trans _ _ A' B'); Par.
    assert(HH:= not_par_inter_exists A' B' E Z H25).
    ex_and HH E'.
    assert(~Col A D E).
      intro.
      induction (eq_dec_points A E).
        subst E.
        apply H13.
        apply (l6_21 X A D A); Col.
          intro.
          apply H16.
          exists D.
          split; Col.
        apply par_distincts in H19.
        spliter.
        auto.
      assert(Col A B D) by ColR.
      apply H16.
      exists A.
      split; Col.
      ColR.
    assert(Par_strict X A E Z).
      induction H23.
        Par.
      spliter.
      apply False_ind.
      assert(Col E X A) by ColR.
      assert(Col A C E) by ColR.
      apply H13.
      apply (l6_21 A E D C); Col.
        intro.
        subst D.
        contradiction.
        apply col_permutation_2.
        apply (col_transitivity_1  _ E); Col.
        intro.
        subst E.
        clean_trivial_hyps.
        apply H16.
        exists B.
        split; Col.
        apply col_permutation_1.
        apply (col_transitivity_1  _ C); Col.
    assert(Par Y B E Z).
      apply (par_trans _ _ X A); Par.
    assert(Par_strict Y B E Z).
      induction H30.
        Par.
      spliter.
      apply False_ind.
      assert(Col E Y B) by ColR.
      assert(Col B D E) by ColR.
      apply H14.
      apply (l6_21 B E C D); Col.
        intro.
        apply H16.
        exists C.
        split; Col.
        apply col_permutation_1.
        apply (col_transitivity_1  _ E); Col.
        intro.
        subst E.
        apply H16.
        exists C.
        split; Col.
        clean_trivial_hyps.
        apply col_permutation_1.
        apply (col_transitivity_1  _ D); Col.
      intro.
      subst D.
      apply H16.
      exists C.
      split; Col.
      assert_diffs; ColR.
    assert(~Col A' D' E').
      intro.
      assert(Col A' B' D').
        apply (col_transitivity_1  _ E'); Col.
        intro.
        subst E'.
        apply H29.
        exists A'.
        split; Col.
      apply H16.
      exists A'.
      split; Col.
      assert(Col Y B' D').
        apply (col_transitivity_1  _ B); Col.
      assert(Col B' A' Y).
        apply (col_transitivity_1  _ D'); Col.
        intro.
        subst D'.
        assert(Par A D A B).
          apply(par_trans _ _ A' B'); Par.
        induction H35.
          apply H35.
          exists A.
          split; Col.
        spliter.
        apply H16.
        exists A.
        split; Col.
        apply col_permutation_1.
        apply (col_transitivity_1  _ D); Col.
      apply col_permutation_2.
      apply (col_transitivity_1  _ B'); Col.
    assert(~ Col X A B).
      intro.
      apply H16.
      exists B.
      split; Col.
    assert(~ Col Y A B).
      intro.
      apply H16.
      exists A.
      split; Col.
    assert(B <> B').
      intro.
      subst B'.
      apply H15.
      apply(l6_21 X A B A); Col.
        intro.
        subst B.
        apply H33.
        Col.
        induction H18.
          apply False_ind.
          apply H18.
          exists B.
          split; Col.
        spliter.
        Col.
    assert(C <> C').
      intro.
      subst C'.
      induction H20.
        apply H20.
        exists C.
        split; Col.
      spliter.
      apply H16.
      exists C.
      split; Col.
      apply col_permutation_1.
      apply (col_transitivity_1  _ B'); Col.
    assert(D <> D').
      intro.
      subst D'.
      induction H19.
        apply H19.
        exists D.
        split; Col.
      spliter.
      apply H16.
      exists D.
      split; Col.
      apply col_permutation_1.
      apply (col_transitivity_1  _ A'); Col.
    assert(A' <> C').
      intro.
      subst C'.
      assert(Par B C A B).
        apply (par_trans _ _ A' B'); Par.
      induction H38.
        apply H38.
        exists B.
        split; Col.
      spliter.
      apply H16.
      exists B.
      split; ColR.
    assert(B' <> D').
      intro.
      subst D'.
      assert(Par A D A B).
        apply (par_trans _ _ A' B'); Par.
      induction H39.
        apply H39.
        exists A.
        split; Col.
      spliter.
      apply H16.
      exists A.
      split; Col.
      apply col_permutation_1.
      apply (col_transitivity_1  _ D); Col.
    assert(A <> E).
      intro.
      subst E.
      apply H28.
      Col.
    assert(A' <> E').
      intro.
      subst E'.
      apply H32.
      Col.
    assert(B <> E).
      intro.
      subst E.
      apply H31.
      exists B.
      split; Col.
    assert(B' <> E').
      intro.
      subst E'.
      apply H31.
      exists B'.
      split; Col.
    (*-------------------*)
    assert(Par A E A' E').
      apply (par_col_par_2 _ B); Col.
      apply par_symmetry.
      apply (par_col_par_2 _ B'); Col.
      Par.
    assert(Par_strict A E A' E').
      induction H44.
        Par.
      spliter.
      apply False_ind.
      apply H45.
      apply (l6_21 X A' B' E'); Col.
        intro.
        apply H16.
        exists B'.
        split; Col.
        apply col_permutation_2.
        apply (col_transitivity_1  _ A'); Col.
      apply col_permutation_2.
      apply (col_transitivity_1  _ A); Col.
    assert(Par D E D' E').
      apply(l13_15_par A D E A' D' E'); Par.
        induction H19.
          Par.
        spliter.
        apply False_ind.
        apply H16.
        exists D.
        split; Col.
        apply col_permutation_1.
        apply (col_transitivity_1  _ A'); Col.
        apply col_permutation_2.
        apply (col_transitivity_1  _ D'); Col.
        apply (par_col_par_2 _ X); Col.
        apply par_symmetry.
        apply (par_col_par_2 _ Y); Col.
          apply col_permutation_2.
          apply (col_transitivity_1  _ B); Col.
        apply par_comm.
        apply (par_col_par_2 _ B); Col.
        apply (par_trans _ _ E Z); Par.
      apply (par_col_par_2 _ X); Par; Col.
      apply par_symmetry.
      apply (par_col_par_2 _ Z); Col.
        intro.
        subst E'.
        apply H45.
        exists E.
        split; Col.
      Par.
    assert(Par C E C' E').
      eapply(l13_15_par B C E B' C' E'); Par.
        intro.
        assert(Col B A C) by ColR.
        apply H16.
        exists B.
        split; ColR.
        induction H20.
          Par.
        spliter.
        apply False_ind.
        apply H16.
        exists B'.
        split; Col.
        assert(Col X C C').
          apply (col_transitivity_1  _ A); Col.
        assert(Col C B' X).
          apply (col_transitivity_1  _ C'); Col.
        apply col_permutation_2.
        apply (col_transitivity_1  _ C); Col.
        assert(Par B E B' E').
          apply (par_col_par_2 _ A); Col.
          apply par_symmetry.
          apply (par_col_par_2 _ A'); Col.
          Par.
        induction H47.
          Par.
        spliter.
        apply False_ind.
        assert(Col B' A' B) by ColR.
        apply H16.
        exists A'.
        split; sfinish.
        apply (par_col_par_2 _ Y); Col.
        apply par_symmetry.
        apply (par_col_par_2 _ X); Col.
          apply col_permutation_2.
          apply (col_transitivity_1  _ A); Col.
        apply par_left_comm.
        apply (par_col_par_2 _ A); Col.
        apply (par_trans _ _ E Z); Par.
      apply (par_col_par_2 _ Y); Col.
      apply par_symmetry.
      apply (par_col_par_2 _ Z); Col.
        intro.
        subst E'.
        apply H45.
        exists E.
        split; Col.
      Par.
    apply (par_col_par_2 _ E); Col.
      intro.
      subst D.
      apply H16.
      exists C.
      split; Col.
    apply par_symmetry.
    apply (par_col_par_2 _ E'); Col.
      intro.
      subst D'.
      apply H16.
      exists C'.
      split; Col.
      apply (col_par_par_col C E D); Col ; Par.
    Par.
Qed.
l13_19_par
Proof.
    intros.
    induction(eq_dec_points A C).
      subst C.
      assert(Par A' B' B' C').
        apply(par_trans _ _ A B); Par.
      induction H17.
        apply False_ind.
        apply H17.
        exists B'.
        split; Col.
      spliter.
      assert(A' = C').
        apply (l6_21 X A B' A'); Col.
        intro.
        apply H13.
        exists B'.
        split; Col.
      subst C'.
      Par.
    induction(eq_dec_points B D).
      subst D.
      assert(Par A' B' A' D').
        apply(par_trans _ _ A B); Par.
      induction H18.
        apply False_ind.
        apply H18.
        exists A'.
        split; Col.
      spliter.
      assert(B' = D').
        apply (l6_21 Y B A' B'); Col.
        intro.
        apply H13.
        exists A'.
        split; Col.
      subst D'.
      Par.
    induction(eq_dec_points A A').
      subst A'.
      induction H14.
        apply False_ind.
        apply H14.
        exists A.
        split; Col.
      spliter.
      assert(B = B').
        apply (l6_21 Y B A B); Col.
        intro.
        apply H13.
        exists A.
        split; Col.
      subst B'.
      assert(C = C').
        induction H16.
          apply False_ind.
          apply H16.
          exists B.
          split; Col.
        spliter.
        apply (l6_21 X A B C); Col.
        intro.
        apply H13.
        exists B.
        split; Col.
      subst C'.
      assert(D = D').
        induction H15.
          apply False_ind.
          apply H15.
          exists A.
          split; Col.
        spliter.
        apply (l6_21 Y B A D); Col.
        intro.
        apply H13.
        exists A.
        split; Col.
      subst D'.
      auto.
      apply par_reflexivity.
      intro.
      subst D.
      clean_trivial_hyps.
      apply H13.
      exists C.
      split; Col.
    induction(Par_dec C D C' D').
      auto.
    assert(HH:=not_par_one_not_par C D C' D' A B H20).
    induction HH.
      eapply (l13_19_par_aux A B C D A' B' C' D' X Y); Col.
      intro.
      apply H21.
      Par.
    apply par_distincts in H14.
    spliter.
    apply par_symmetry.
    eapply (l13_19_par_aux A' B' C' D' A B C D X Y); sfinish.
      intro.
      subst C'.
      apply H17.
      apply (l6_21 X A B A); finish.
        intro.
        apply H13.
        exists B.
        split; Col.
        assert(Par B C B A).
          apply(par_trans _ _ A' B');finish.
        induction H24.
          apply False_ind.
          apply H24.
          exists B.
          split; Col.
        spliter.
        Col.
      intro.
      apply H18.
      subst D'.
      assert(Par A D A B).
        apply(par_trans _ _ A' B'); Par.
      apply (l6_21 Y B A B); Col.
        intro.
        apply H13.
        exists A.
        split; Col.
        induction H24.
          apply False_ind.
          apply H24.
          exists A.
          split; Col.
        spliter.
        Col.
      unfold Par_strict in H13.
      spliter.
      unfold Par_strict.
      repeat split; auto; try apply all_coplanar.
      intro.
      apply H26.
      ex_and H27 P.
      exists P.
      split.
        ColR.
      ColR.
    intro.
    apply H21.
    apply (par_trans _ _ A' B'); Par.
Qed.
Pj_exists
Proof.
    intros.
    unfold Pj in *.
    elim (eq_dec_points A B);intro.
      subst.
      exists C.
      tauto.
    assert (T:=parallel_existence A B C H).
    decompose [and ex] T;clear T.
    exists x0.
    induction (eq_dec_points C x0).
      tauto.
    eauto using par_col2_par with col.
Qed.
sum_to_sump
Proof.
    intros.
    unfold Sum in H.
    unfold Ar2 in H.
    spliter.
    repeat split; Col.
    ex_and H0 A'.
    ex_and H4 C'.
    exists A'.
    exists C'.
    assert(O <> E /\ O <> E').
      repeat split; intro; subst O; apply H; Col.
    spliter.
    assert(HH:=parallel_existence1 O E A' H8).
    ex_and HH P'.
    exists P'.
    assert( E <> E').
      intro.
      subst E'.
      apply H.
      Col.
    repeat split; Col.
      intro.
      induction H12.
        apply H12.
        exists E'.
        split; Col.
      spliter.
      contradiction.
      unfold Pj in H0.
      induction H0.
        left.
        apply par_symmetry.
        assumption.
      right.
      auto.
      apply par_distincts in H10.
      spliter.
      auto.
      intro.
      assert(Par O E O E').
        apply (par_trans _ _ A' P'); auto.
      induction H13.
        apply H13.
        exists O.
        split; Col.
      spliter.
      apply H.
      Col.
      unfold Pj in H5.
      induction H5.
        assert(Par A' C' A' P').
          apply (par_trans _ _ O E).
            apply par_symmetry.
            auto.
          auto.
        induction H12.
          apply False_ind.
          apply H12.
          exists A'.
          split; Col.
        spliter.
        Col.
      subst C'.
      Col.
      unfold Pj in H6.
      induction H6.
        left.
        apply par_symmetry.
        auto.
      right.
      auto.
      intro.
      induction H12.
        apply H12.
        exists E.
        split; Col.
      spliter.
      contradiction.
    unfold Pj in H7.
    induction H7.
      left.
      apply par_symmetry.
      apply par_left_comm.
      auto.
    tauto.
Qed.
sump_to_sum
Proof.
    intros.
    unfold Sump in H.
    spliter.
    ex_and H1 A'.
    ex_and H2 C'.
    ex_and H1 P'.
    unfold Sum.
    split.
      repeat split; Col.
        intro.
        unfold Proj in H1.
        spliter.
        apply H7.
        right.
        repeat split; Col.
      unfold Proj in H4.
      spliter.
      Col.
    exists A'.
    exists C'.
    unfold Pj.
    repeat split.
      unfold Proj in H1.
      spliter.
      induction H8.
        left.
        apply par_symmetry.
        auto.
      tauto.
      unfold Proj in H1.
      tauto.
      induction(eq_dec_points A' C').
        tauto.
      left.
      unfold Proj in H3.
      spliter.
      apply (par_col_par _  _ _ P'); Col.
      unfold Proj in H3.
      spliter.
      induction H8.
        left.
        apply par_symmetry.
        auto.
      tauto.
    unfold Proj in H4.
    spliter.
    induction H8.
      left.
      apply par_symmetry.
      apply par_right_comm.
      auto.
    tauto.
Qed.
project_col_project
Proof.
    intros.
    unfold Proj in *.
    spliter.
    repeat split; auto.
      intro.
      apply H3.
      eapply (par_col_par_2 _ C); Col; Par.
    (*perm_apply (par_col_par X Y A C).*)
    ColR.
Qed.
project_trivial
Proof.
    intros.
    unfold Proj.
    repeat split; Col.
Qed.
pj_col_project
Proof.
    intros.
    unfold Pj in H3.
    induction H3.
      unfold Proj.
      repeat split; Col.
      left.
      apply par_symmetry.
      assumption.
    subst P'.
    apply project_trivial; Col.
Qed.
sum_exists
Proof.
    intros.
    assert(NC:= grid_ok).
    assert(O <> E).
      intro.
      subst E.
      apply NC.
      Col.
    assert(O <> E').
      intro.
      subst E'.
      apply NC.
      Col.
    induction(eq_dec_points O A).
      subst A.
      exists B.
      unfold Sum.
      split.
        unfold Ar2.
        split; Col.
      exists O.
      exists B.
      unfold Pj.
      repeat split.
        right.
        auto.
        Col.
        induction(eq_dec_points O B).
          right; auto.
        left.
        right.
        repeat split; Col.
        right; auto.
      right; auto.
    assert(exists! A' , Proj A A' O E' E E').
      apply(project_existence A O E' E E'); intro; try (subst E' ; apply NC; Col).
      induction H4.
        apply H4.
        exists E'.
        split; Col.
      spliter.
      apply NC.
      Col.
    ex_and H4 A'.
    assert(HH:=parallel_existence1 O E A' H1).
    ex_and HH P.
    unfold unique in H5.
    spliter.
    assert(A <> A').
      intro.
      subst A'.
      apply project_col in H5.
      apply NC.
      apply (col_transitivity_1 _ A); Col.
    induction(eq_dec_points B O).
      subst B.
      exists A.
      unfold Sum.
      split.
        unfold Ar2.
        repeat split; Col.
      exists A'.
      exists A'.
      unfold Pj.
      unfold Proj in H5.
      spliter.
      repeat split.
        spliter.
        induction H11.
          left.
          apply par_symmetry.
          auto.
        contradiction.
        Col.
        right.
        auto.
        left.
        right.
        repeat split; Col.
        intro.
        subst A'.
        induction H11.
          induction H11.
            apply H11.
            exists E.
            split; Col.
          spliter.
          contradiction.
        contradiction.
      induction H11.
        left.
        apply par_symmetry.
        apply par_comm.
        auto.
      contradiction.
    assert(exists! C', Proj B C' A' P O E').
      apply(project_existence B A' P O E'); auto.
      apply par_distincts in H4.
      spliter.
      auto.
      intro.
      assert(Par O E O E').
        apply (par_trans _ _ A' P).
          auto.
        apply par_symmetry.
        auto.
      induction H10.
        apply H10.
        exists O.
        split; Col.
      spliter.
      apply NC.
      Col.
    ex_and H9 C'.
    unfold unique in H10.
    spliter.
    assert(exists! C : Tpoint, Proj C' C O E A A').
      apply(project_existence C' O E A A'); auto.
      intro.
      induction H11.
        apply H11.
        exists A.
        split; Col.
      spliter.
      assert(HH:=project_par_dir A A' O E' E E' H11 H5).
      assert(Col E A A').
        ColR.
      induction HH.
        apply H16.
        exists E.
        split; Col.
      spliter.
      apply NC.
      apply col_permutation_2.
      apply(col_transitivity_1 _ A'); Col.
      intro.
      subst A'.
      clean_trivial_hyps.
      unfold Proj in H5.
      spliter.
      apply NC.
      Col.
    ex_and H11 C.
    unfold unique in H12.
    spliter.
    unfold Proj in *.
    spliter.
    exists C.
    unfold Sum.
    split.
      unfold Ar2.
      repeat split; Col.
    exists A'.
    exists C'.
    unfold Pj.
    repeat split.
      left.
      induction H24.
        apply par_symmetry.
        auto.
      contradiction.
      Col.
      left.
      eapply (par_col_par _ _ _ P).
        intro.
        subst C'.
        induction H16.
          induction H16.
            apply H16.
            exists A'.
            split; Col.
          spliter.
          induction H20.
            induction H20.
              apply H20.
              exists A'.
              split; Col.
            spliter.
            apply NC.
            apply (col_transitivity_1 _ B); Col.
          subst A'.
          apply H14.
          right.
          repeat split; try finish; ColR.
        subst A'.
        apply H14.
        right.
        repeat split; try finish; ColR.
        assumption.
      ColR.
      induction H20.
        left.
        apply par_symmetry.
        auto.
      right; auto.
    induction H24.
      induction H16.
        left.
        apply (par_trans _ _ A A').
          apply par_symmetry.
          apply par_right_comm.
          auto.
        apply par_symmetry.
        auto.
      subst C'.
      right.
      auto.
    contradiction.
Qed.
sum_uniqueness
Proof.
    intros.
    apply sum_to_sump in H.
    apply sum_to_sump in H0.
    unfold Sump in H.
    unfold Sump in H0.
    spliter.
    clean_duplicated_hyps.
    ex_and H4 A'.
    ex_and H0 C'.
    ex_and H1 P'.
    ex_and H2 A''.
    ex_and H6 C''.
    ex_and H2 P''.
    assert(A'=A'').
      apply(project_uniqueness A A' A'' O E' E E');auto.
    subst A''.
    assert(Col A' P' P'').
      assert(Par A' P' A' P'').
        apply (par_trans _ _ O E).
          apply par_symmetry.
          auto.
        auto.
      induction H9.
        apply False_ind.
        apply H9.
        exists A'.
        split; Col.
      spliter.
      Col.
    assert(Proj B C'' A' P' O E').
      eapply (project_col_project _ P''); Col.
      unfold Proj in H4.
      tauto.
    assert(C' = C'').
      apply(project_uniqueness B C' C'' A' P' O E');auto.
    subst C''.
    apply(project_uniqueness C' C1 C2 O E E E');auto.
Qed.
opp_exists
Proof.
    intros.
    assert(NC:= grid_ok).
    induction(eq_dec_points A O).
      subst A.
      exists O.
      unfold Opp.
      unfold Sum.
      split.
        unfold Ar2.
        repeat split; Col.
      exists O.
      exists O.
      repeat split; Col; try right; auto.
    prolong A O MA A O.
    exists MA.
    unfold Opp.
    apply sump_to_sum.
    unfold Sump.
    repeat split.
      apply bet_col in H1.
      apply (col_transitivity_1 _ A);Col.
      Col.
    assert(E <> E' /\ O <> E').
      split; intro; subst E'; apply NC; Col.
    spliter.
    assert(exists! P' : Tpoint, Proj MA P' O E' E E').
      apply(project_existence MA O E' E E'); auto.
      intro.
      induction H5.
        apply H5.
        exists E'.
        split; Col.
      spliter.
      apply NC.
      Col.
    ex_and H5 A'.
    unfold unique in H6.
    spliter.
    exists A'.
    assert(O <> E).
      intro.
      subst E.
      apply NC.
      Col.
    assert(HH:= parallel_existence1 O E A' H7).
    ex_and HH P'.
    assert(exists! C' : Tpoint, Proj A C' A' P' O E').
      apply(project_existence A A' P' O E'); auto.
      apply par_distincts in H8.
      spliter.
      auto.
      intro.
      assert(Par O E O E').
        apply (par_trans _ _ A' P').
          auto.
        apply par_symmetry; auto.
      induction H10.
        apply H10.
        exists O.
        split; Col.
      spliter.
      apply NC.
      Col.
    ex_and H9 C'.
    unfold unique in H10.
    spliter.
    exists C'.
    exists P'.
    split; auto.
    split; auto.
    split; auto.
    unfold Proj in H5.
    spliter.
    unfold Proj.
    repeat split; Col.
      intro.
      induction H15.
        apply H15.
        exists E.
        split; Col.
      apply NC.
      tauto.
    left.
    unfold Proj in H9.
    spliter.
    assert(Par O E' O A').
      right.
      repeat split; Col.
      intro.
      subst A'.
      clean_trivial_hyps.
      induction H14.
        induction H13.
          apply H13.
          exists E.
          split; Col.
          apply col_permutation_1.
          apply bet_col in H1.
          apply(col_transitivity_1 _ A); Col.
        apply NC.
        tauto.
      subst MA.
      apply cong_symmetry in H2.
      apply cong_identity in H2.
      contradiction.
    assert(Plg A C' A' O).
      apply pars_par_plg.
        induction H18.
          assert(Par A C' A' O).
            apply (par_trans _ _ O E').
              Par.
            Par.
          induction H20.
            auto.
          spliter.
          apply False_ind.
          apply NC.
          apply (col_transitivity_1 _ A'); Col.
          apply (col_transitivity_1 _ A); Col.
        subst C'.
        apply False_ind.
        induction H8.
          apply H8.
          exists A.
          split; Col.
        spliter.
        apply NC.
        apply (col_transitivity_1 _ A'); Col.
          intro.
          subst A'.
          apply par_distincts in H19.
          tauto.
        apply col_permutation_2.
        apply (col_transitivity_1 _ P'); Col.
      apply par_comm.
      apply (par_col_par _ _ _ P').
        intro.
        subst C'.
        induction H18.
          induction H18.
            apply H18.
            exists A'.
            split; Col.
          spliter.
          apply NC.
          apply (col_transitivity_1 _ A); Col.
        subst A'.
        induction H19.
          apply H18.
          exists O.
          split; Col.
        spliter.
        apply NC.
        apply (col_transitivity_1 _ A); Col.
        apply par_symmetry.
        apply (par_col_par _ _ _ E); Col.
        apply par_symmetry.
        Par.
      Col.
    assert(Parallelogram A O MA O).
      right.
      unfold Parallelogram_flat.
      repeat split; Col; Cong.
      left.
      intro.
      subst MA.
      apply between_identity in H1.
      contradiction.
    apply plg_to_parallelogram in H20.
    apply plg_permut in H20.
    apply plg_comm2 in H21.
    assert(Parallelogram C' A' MA O).
      assert(HH:= plg_pseudo_trans C' A' O A O MA H20 H21).
      induction HH.
        auto.
      spliter.
      subst MA.
      apply cong_symmetry in H2.
      apply cong_identity in H2.
      contradiction.
    apply plg_par in H22.
      spliter.
      induction H14.
        apply (par_trans _ _ A' MA).
          auto.
        Par.
      subst MA.
      apply par_distincts in H23.
      tauto.
      intro.
      subst C'.
      unfold Parallelogram in H20.
      induction H20.
        unfold Parallelogram_strict in H20.
        spliter.
        apply par_distincts in H23.
        tauto.
      unfold Parallelogram_flat in H20.
      spliter.
      apply cong_symmetry in H24.
      apply cong_identity in H24.
      subst A.
      tauto.
    intro.
    subst MA.
    unfold Parallelogram in H21.
    induction H21.
      unfold Parallelogram_strict in H21.
      spliter.
      unfold TS in H21; unfold Parallelogram.
      spliter; Col.
    unfold Parallelogram_flat in H21.
    spliter.
    apply NC.
    apply (col_transitivity_1 _ A); Col.
    apply (col_transitivity_1 _ A'); Col.
    intro.
    subst A'.
    apply cong_identity in H24.
    subst A.
    tauto.
Qed.
opp0
Proof.
    assert(NC:=grid_ok).
    assert(O <> E' /\ E <> E').
      split; intro ; subst E'; apply NC; Col.
    spliter.
    assert(O <> E).
      intro.
      subst E.
      apply NC; Col.
    unfold Opp.
    apply sump_to_sum.
    unfold Sump.
    repeat split; Col.
    exists O.
    exists O.
    exists E.
    split.
      apply project_trivial; Col.
      intro.
      induction H2.
        apply H2.
        exists E'.
        split; Col.
      spliter.
      contradiction.
    split.
      apply par_reflexivity; auto.
    split.
      apply project_trivial; Col.
      intro.
      induction H2.
        apply H2.
        exists O.
        split; Col.
      spliter.
      apply NC.
      Col.
    apply project_trivial; Col.
    intro.
    induction H2.
      apply H2.
      exists E.
      split; Col.
    spliter.
    contradiction.
Qed.
pj_trivial
Proof.
    intros.
    unfold Pj.
    right.
    auto.
Qed.
sum_O_O
Proof.
    unfold Sum.
    assert(O <> E' /\ E <> E').
      split; intro ; subst E'; apply grid_ok; Col.
    split.
      spliter.
      unfold Ar2.
      repeat split; Col.
    exists O.
    exists O.
    repeat split;try (apply pj_trivial).
    Col.
Qed.
sum_A_O
Proof.
    intros.
    unfold Sum.
    split.
      repeat split; Col.
    assert(O <> E' /\ E <> E').
      split; intro; subst E'; apply grid_ok; Col.
    spliter.
    induction (eq_dec_points A O).
      exists O.
      exists O.
      repeat split;  Col; unfold Pj ; try auto.
    assert(~ Par E E' O E').
      intro.
      induction H3.
        apply H3.
        exists E'.
        split; Col.
      spliter.
      apply grid_ok.
      Col.
    assert(HH:= project_existence A O E' E E' H1 H0 H3).
    ex_and HH A'.
    unfold unique in H4.
    spliter.
    exists A'.
    exists A'.
    unfold Proj in H4.
    spliter.
    repeat split; Col.
      unfold Pj.
      induction H9.
        left.
        apply par_symmetry.
        Par.
      tauto.
      unfold Pj.
      tauto.
      unfold Pj.
      left.
      right.
      repeat split; Col.
      intro.
      subst A'.
      induction H9.
        induction H9.
          apply H9.
          exists E.
          split; Col.
        spliter.
        contradiction.
      contradiction.
    unfold Pj.
    induction H9.
      left.
      apply par_symmetry.
      Par.
    right.
    auto.
Qed.
sum_O_B
Proof.
    intros.
    induction(eq_dec_points B O).
      subst B.
      apply sum_O_O.
    unfold Sum.
    split.
      repeat split; Col.
    assert(O <> E' /\ E <> E').
      split; intro; subst E'; apply grid_ok; Col.
    spliter.
    assert(~ Par E E' O E').
      intro.
      induction H3.
        apply H3.
        exists E'.
        split; Col.
      spliter.
      apply grid_ok.
      Col.
    exists O.
    exists B.
    repeat split; try(apply pj_trivial).
      Col.
    left.
    right.
    repeat split; Col.
    intro.
    subst E.
    apply grid_ok.
    Col.
Qed.
opp0_uniqueness
Proof.
    intros.
    assert(NC:= grid_ok).
    unfold Opp in H.
    apply sum_to_sump in H.
    unfold Sump in H.
    spliter.
    ex_and H1 A'.
    ex_and H2 C'.
    ex_and H1 P'.
    unfold Proj in *.
    spliter.
    induction H8.
      induction H12.
        assert(Par O E' E E').
          apply (par_trans _ _ C' O).
            apply par_symmetry.
            Par.
          Par.
        apply False_ind.
        induction H17.
          apply H17.
          exists E'.
          split; Col.
        spliter.
        contradiction.
      subst C'.
      apply par_distincts in H8.
      tauto.
    subst C'.
    assert( A' = O).
      apply (l6_21 O E E' O); Col.
      induction H2.
        apply False_ind.
        apply H2.
        exists O.
        split; Col.
      spliter.
      apply col_permutation_1.
      apply(col_transitivity_1 _ P'); Col.
    subst A'.
    induction H16.
      induction H8.
        apply False_ind.
        apply H8.
        exists E.
        split; Col.
      spliter.
      contradiction.
    assumption.
Qed.
proj_pars
Proof.
    intros.
    unfold Par_strict.
    assert(HH:=grid_ok).
    repeat split; try apply all_coplanar.
      intro.
      subst E.
      apply HH.
      Col.
      apply par_distincts in H1.
      tauto.
    intro.
    ex_and H3 X.
    unfold Proj in H2.
    spliter.
    induction H1.
      apply H1.
      exists X.
      split; Col.
    spliter.
    assert(Col A' O E).
      apply (col_transitivity_1 _ C'); Col.
    induction(eq_dec_points A' O).
      subst A'.
      clean_trivial_hyps.
      induction H8.
        induction H7.
          apply H7.
          exists E.
          split; Col.
        spliter.
        contradiction.
      contradiction.
    apply grid_ok.
    apply(col_transitivity_1 _ A'); Col.
Qed.
proj_col
Proof.
    intros.
    assert(HH:=grid_ok).
    unfold Proj in H2.
    spliter.
    subst A.
    induction H6.
      apply False_ind.
      apply H4.
      apply par_symmetry.
      eapply (par_col_par _ _ _ A'); Col.
      apply par_symmetry.
      Par.
    auto.
Qed.
grid_not_par
Proof.
    repeat split.
      intro.
      unfold Par in H.
      induction H.
        apply H.
        exists E.
        split; Col.
      spliter.
      contradiction.
      intro.
      induction H.
        apply H.
        exists O.
        split; Col.
      spliter.
      apply grid_ok.
      Col.
      intro.
      induction H.
        apply H.
        exists E'.
        split; Col.
      spliter.
      contradiction.
      intro.
      subst E.
      apply grid_ok.
      Col.
      intro.
      subst E'.
      apply grid_ok.
      Col.
    intro.
    subst E'.
    apply grid_ok.
    Col.
Qed.
proj_id
Proof.
    intros.
    assert(HH:=grid_not_par).
    spliter.
    unfold Proj in H.
    spliter.
    induction H11.
      apply(l6_21 O E E' O); Col.
        assert(Col O A' A).
          apply(col_transitivity_1 _ E); Col.
        apply col_permutation_2.
        apply (col_transitivity_1 _ A'); Col.
        intro.
        subst A'.
        induction H11.
          apply H11.
          exists E.
          split; Col.
        spliter.
        contradiction.
    subst.
    apply(l6_21 O E E' O); Col.
Qed.
sum_O_B_eq
Proof.
    intros.
    assert (HS:=H).
    unfold Sum in H.
    spliter.
    unfold Ar2 in H.
    spliter.
    assert(HH:=sum_O_B B H2).
    apply (sum_uniqueness O B); auto.
Qed.
sum_A_O_eq
Proof.
    intros.
    assert (HS:=H).
    unfold Sum in H.
    spliter.
    unfold Ar2 in H.
    spliter.
    assert(HH:=sum_A_O A H1).
    apply (sum_uniqueness A O); auto.
Qed.
sum_par_strict
Proof.
    intros.
    assert(Sum O E E' A B C).
      unfold Sum.
      split.
        auto.
      exists A'.
      exists C'.
      repeat split; auto.
    unfold Ar2 in H.
    unfold Pj in *.
    spliter.
    assert(A' <> O).
      intro.
      subst A'.
      induction H3.
        induction H3.
          apply H3.
          exists O.
          split; Col.
        spliter.
        induction H1.
          induction H1.
            apply H1.
            exists E.
            split; Col.
          spliter.
          apply grid_ok.
          apply(col_transitivity_1 _ A); Col.
        contradiction.
      subst C'.
      induction H1.
        induction H1.
          apply H1.
          exists E.
          split; Col.
        spliter.
        apply grid_ok.
        apply(col_transitivity_1 _ A); Col.
      contradiction.
    split.
      auto.
    induction(eq_dec_points B O).
      tauto.
    left.
    induction H3.
      induction H3.
        assumption.
      spliter.
      apply False_ind.
      apply grid_ok.
      assert(Col A' O E ).
        apply(col_transitivity_1 _ C'); Col.
      apply(col_transitivity_1 _ A'); Col.
    subst C'.
    apply False_ind.
    induction H4.
      induction H3.
        apply H3.
        exists A'.
        split; Col.
      spliter.
      assert(Col O B E').
        apply (col_transitivity_1 _ A'); Col.
      apply grid_ok.
      apply (col_transitivity_1 _ B); Col.
    subst A'.
    assert(HH:= grid_not_par).
    spliter.
    induction H5.
      apply H3.
      apply par_symmetry.
      apply (par_col_par _ _ _ B); Col.
      apply par_right_comm.
      apply (par_col_par _ _ _ C); Par.
      apply col_permutation_1.
      apply(col_transitivity_1 _ E); Col.
    subst C.
    apply grid_ok.
    apply(col_transitivity_1 _ B); Col.
Qed.
sum_A_B_A
Proof.
    intros.
    unfold Sum in H.
    spliter.
    ex_and H0 A'.
    ex_and H1 C'.
    assert(HH:= grid_not_par).
    spliter.
    induction(eq_dec_points A O).
      subst A.
      unfold Pj in *.
      unfold Ar2 in H.
      spliter.
      induction H0.
        induction H0.
          apply False_ind.
          apply H0.
          exists E'.
          split; Col.
        spliter.
        apply False_ind.
        apply grid_ok.
        ColR.
      subst A'.
      induction H2.
        induction H4.
          apply False_ind.
          apply H5.
          apply (par_trans _ _ O C') ; Par.
        subst C'.
        apply par_distincts in H0.
        tauto.
      subst C'.
      induction H3.
        induction H0.
          apply False_ind.
          apply H0.
          exists O.
          split; Col.
        spliter.
        induction(eq_dec_points B O).
          auto.
        apply False_ind.
        apply grid_ok.
        ColR.
      assumption.
    assert(A' <> O /\ (Par_strict O E A' C' \/ B = O)).
      apply(sum_par_strict A B A A' C');auto.
    spliter.
    induction(eq_dec_points B O).
      auto.
    induction H13.
      unfold Pj in *.
      unfold Ar2 in H.
      spliter.
      induction H0.
        induction H4.
          assert(Par A A' A C').
            apply (par_trans _ _ E E'); Par.
          apply False_ind.
          induction H18.
            apply H18.
            exists A.
            split; Col.
          spliter.
          apply H13.
          exists A.
          split; Col.
        subst C'.
        apply False_ind.
        apply H13.
        exists A.
        split; Col.
      subst A'.
      apply False_ind.
      apply grid_ok.
      apply(col_transitivity_1 _ A);Col.
    contradiction.
Qed.
sum_A_B_B
Proof.
    intros.
    unfold Sum in H.
    spliter.
    ex_and H0 A'.
    ex_and H1 C'.
    assert(HH:= grid_not_par).
    spliter.
    unfold Pj in *.
    unfold Ar2 in H.
    spliter.
    induction H3.
      induction H4.
        apply False_ind.
        apply H7.
        apply(par_trans _ _ B C'); Par.
      subst C'.
      apply par_distincts in H3.
      tauto.
    subst C'.
    induction(eq_dec_points A O).
      auto.
    assert(A' <> O /\ (Par_strict O E A' B \/ B = O)).
      apply(sum_par_strict A B B A' B);auto.
        repeat split; auto.
      unfold Pj.
      auto.
    spliter.
    induction H15.
      apply False_ind.
      apply H15.
      exists B.
      split; Col.
    subst B.
    induction H2.
      induction H2.
        apply False_ind.
        apply H2.
        exists O.
        split; Col.
      spliter.
      apply False_ind.
      apply H.
      ColR.
    subst A'.
    tauto.
Qed.
sum_uniquenessB
Proof.
    intros.
    induction (eq_dec_points A O).
      subst A.
      assert(X = C).
        apply(sum_O_B_eq X C H).
      assert(Y = C).
        apply(sum_O_B_eq Y C H0).
      subst X.
      subst Y.
      auto.
    assert(HSx:= H).
    assert(HSy:= H0).
    unfold Sum in H.
    unfold Sum in H0.
    spliter.
    assert(Hx:=H).
    assert(Hy:=H0).
    unfold Ar2 in H.
    unfold Ar2 in H0.
    spliter.
    ex_and H2 A''.
    ex_and H10 C''.
    ex_and H3 A'.
    ex_and H14 C'.
    clean_duplicated_hyps.
    assert(A' <> O /\ (Par_strict O E A' C' \/ X = O)).
      apply(sum_par_strict A X C A' C'); auto.
    assert(A'' <> O /\ (Par_strict O E A'' C'' \/ Y = O)).
      apply(sum_par_strict A Y C A'' C''); auto.
    spliter.
    unfold Pj in *.
    induction(eq_dec_points X O).
      subst X.
      assert(HH:=sum_A_O A H7).
      assert(C = A).
        apply (sum_uniqueness A O); auto.
      subst C.
      assert(Y=O).
        apply (sum_A_B_A A ); auto.
      subst Y.
      auto.
    induction H2.
      induction H3.
        assert(Par A A' A A'').
          apply (par_trans _ _ E E'); Par.
        induction H19.
          apply False_ind.
          apply H19.
          exists A.
          split; Col.
        spliter.
        assert(A' = A'').
          apply (l6_21 O E' A A'); Col.
          intro.
          apply grid_ok.
          apply(col_transitivity_1 _ A); Col.
        subst A''.
        induction H4.
          induction H6.
            assert(Par A' C' A' C'').
              apply(par_trans _ _ O E); left; Par.
            induction H23.
              apply False_ind.
              apply H23.
              exists A'.
              split; Col.
            spliter.
            induction H13.
              induction H17.
                assert(Par C C' C C'').
                  apply(par_trans _ _ E' E); Par.
                induction H27.
                  apply False_ind.
                  apply H27.
                  exists C.
                  split; Col.
                spliter.
                assert(C' = C'').
                  apply (l6_21 A' C' C C'); Col.
                  intro.
                  apply H6.
                  exists C.
                  split; Col.
                subst C''.
                clean_trivial_hyps.
                induction H12.
                  induction H16.
                    assert(Par Y C' X C').
                      apply (par_trans _ _ O E'); Par.
                    induction H21.
                      apply False_ind.
                      apply H21.
                      exists C'.
                      split; Col.
                    spliter.
                    apply(l6_21 O E C' X); Col.
                    intro.
                    apply H4.
                    exists C'.
                    split; Col.
                  subst X.
                  clean_duplicated_hyps.
                  apply False_ind.
                  apply H6.
                  exists C'.
                  split; Col.
                subst Y.
                apply False_ind.
                apply H6.
                exists C'.
                split; Col.
              subst C'.
              clean_duplicated_hyps.
              clean_trivial_hyps.
              apply False_ind.
              apply H6.
              exists C.
              split; Col.
            subst C''.
            apply False_ind.
            apply H4.
            exists C.
            split; Col.
          subst X.
          tauto.
        subst Y.
        assert(A = C).
          apply(sum_A_O_eq A C HSy).
        subst C.
        clean_duplicated_hyps.
        clean_trivial_hyps.
        apply(sum_A_B_A A); auto.
      subst A'.
      clean_duplicated_hyps.
      induction H15.
        induction H6.
          apply False_ind.
          apply H3.
          exists A.
          split; Col.
        subst X.
        tauto.
      subst C'.
      induction H6.
        apply False_ind.
        apply H.
        exists A.
        split; Col.
      contradiction.
    subst A''.
    induction H4.
      apply False_ind.
      apply H2.
      exists A.
      split; Col.
    subst Y.
    assert(A = C).
      apply (sum_A_O_eq A C HSy).
    subst C.
    apply (sum_A_B_A A _ HSx).
Qed.
sum_uniquenessA
Proof.
    intros.
    induction (eq_dec_points B O).
      subst B.
      assert(X = C).
        apply(sum_A_O_eq X C H).
      subst X.
      assert(Y = C).
        apply(sum_A_O_eq Y C H0).
      subst Y.
      auto.
    assert(HSx:= H).
    assert(HSy:= H0).
    unfold Sum in H.
    unfold Sum in H0.
    spliter.
    assert(Hx:=H).
    assert(Hy:=H0).
    unfold Ar2 in H.
    unfold Ar2 in H0.
    spliter.
    ex_and H2 A''.
    ex_and H10 C''.
    ex_and H3 A'.
    ex_and H14 C'.
    clean_duplicated_hyps.
    unfold Pj in *.
    induction(eq_dec_points X O).
      subst X.
      assert(HH:=sum_O_B B H8).
      assert(B = C).
        apply (sum_uniqueness O B); auto.
      subst C.
      apply sym_equal.
      apply (sum_A_B_B Y B); auto.
    induction(eq_dec_points Y O).
      subst Y.
      assert(HH:=sum_O_B B H8).
      assert(B = C).
        apply (sum_uniqueness O B); auto.
      subst C.
      apply (sum_A_B_B X B); auto.
    assert(A' <> O /\ (Par_strict O E A' C' \/ B = O)).
      apply(sum_par_strict X B C A' C'); auto.
    assert(A'' <> O /\ (Par_strict O E A'' C'' \/ B = O)).
      apply(sum_par_strict Y B C A'' C''); auto.
    spliter.
    induction H12.
      induction H16.
        assert(Par B C' B C'').
          apply (par_trans _ _ O E'); Par.
        induction H20.
          apply False_ind.
          apply H20.
          exists B.
          split; Col.
        spliter.
        clean_trivial_hyps.
        induction H13.
          induction H17.
            assert(Par C C' C C'').
              apply (par_trans _ _ E E'); Par.
            induction H22.
              apply False_ind.
              apply H22.
              exists C.
              split; Col.
            spliter.
            assert(C' = C'').
              apply(l6_21 C C' B C'); Col.
              intro.
              induction H19.
                apply H19.
                exists C'.
                split.
                  assert(Col O B C).
                    apply (col_transitivity_1 _ E); Col.
                    intro.
                    apply grid_ok.
                    subst E.
                    Col.
                  assert(Col E B C).
                    apply (col_transitivity_1 _ O); Col.
                    intro.
                    apply grid_ok.
                    subst E.
                    Col.
                  apply(col3 B C); Col.
                  intro.
                  subst C.
                  clean_trivial_hyps.
                  apply(sum_A_B_B) in HSx.
                  contradiction.
                Col.
              contradiction.
            subst C''.
            clean_trivial_hyps.
            induction H19.
              induction H18.
                assert(Par A' C' A'' C').
                  apply (par_trans _ _ O E);left; Par.
                induction H23.
                  apply False_ind.
                  apply H23.
                  exists C'.
                  split; Col.
                spliter.
                assert(A'= A'').
                  apply (l6_21 O E' C' A'); Col.
                  intro.
                  induction H16.
                    apply H16.
                    exists C'.
                    split; Col.
                  spliter.
                  apply H1.
                  apply (l6_21 O E C' O); Col.
                    intro.
                    apply grid_ok.
                    ColR.
                  intro.
                  subst C'.
                  clean_trivial_hyps.
                  apply H18.
                  exists O.
                  split; Col.
                subst A''.
                clean_trivial_hyps.
                clean_duplicated_hyps.
                induction H2.
                  induction H3.
                    assert(Par Y A' X A').
                      apply(par_trans _ _ E E'); Par.
                    induction H6.
                      apply False_ind.
                      apply H6.
                      exists A'.
                      split; Col.
                    spliter.
                    apply (l6_21 O E A' X); Col.
                    intro.
                    apply H19.
                    exists A'.
                    split; Col.
                  subst X.
                  apply False_ind.
                  apply H19.
                  exists A'.
                  split; Col.
                subst Y.
                apply False_ind.
                apply H19.
                exists A'.
                split; Col.
              contradiction.
            contradiction.
          subst C'.
          apply False_ind.
          induction H16.
            apply H16.
            exists O.
            split.
              Col.
            apply(col3 O E); Col.
            intro.
            subst E.
            apply grid_ok; Col.
          spliter.
          assert(Col E B C).
            apply (col3 O E); Col.
            intro.
            subst E.
            apply grid_ok; Col.
          apply grid_ok.
          apply(col3 B C); Col.
        subst C''.
        apply False_ind.
        induction H12.
          apply H12.
          exists O.
          split.
            Col.
          apply(col3 O E); Col.
          intro.
          subst E.
          apply grid_ok; Col.
        spliter.
        assert(Col E B C).
          apply (col3 O E); Col.
          intro.
          subst E.
          apply grid_ok; Col.
        apply grid_ok.
        apply(col3 B C); Col.
      apply False_ind.
      subst C'.
      induction H19.
        apply H16.
        exists B.
        split; Col.
      contradiction.
    subst C''.
    apply False_ind.
    induction H18.
      apply H12.
      exists B.
      split; Col.
    contradiction.
Qed.
sum_B_null
Proof.
    intros.
    assert(HS:=H).
    unfold Sum in H.
    spliter.
    unfold Ar2 in H.
    spliter.
    assert(HP:= sum_A_O A H1).
    apply(sum_uniquenessB A B O A); auto.
Qed.
sum_A_null
Proof.
    intros.
    assert(HS:=H).
    unfold Sum in H.
    spliter.
    unfold Ar2 in H.
    spliter.
    assert(HP:= sum_O_B B H2).
    apply(sum_uniquenessA B A O B); auto.
Qed.
sum_plg
Proof.
    intros.
    assert(HS:=H).
    unfold Sum in H.
    spliter.
    ex_and H1 A'.
    ex_and H2 C'.
    exists A'.
    exists C'.
    unfold Pj in *.
    unfold Ar2 in H.
    assert(HH:= grid_not_par).
    spliter.
    induction(eq_dec_points O B).
      subst B.
      assert(HH:=sum_A_O A H12).
      assert(HP:=sum_uniqueness A O C A HS HH).
      subst C.
      induction H4.
        induction H4.
          apply False_ind.
          apply H4.
          exists O.
          split; Col.
        spliter.
        induction H3.
          induction H3.
            apply False_ind.
            apply H3.
            exists O.
            split.
              Col.
            apply (col_transitivity_1 _ E'); Col.
          spliter.
          apply False_ind.
          apply grid_ok.
          assert(Col C' O E).
            ColR.
          ColR.
        subst C'.
        split; apply parallelogram_to_plg; apply plg_trivial1.
          auto.
        intro.
        subst A'.
        apply H.
        ColR.
      subst C'.
      apply False_ind.
      induction H5.
        apply H6.
        apply par_symmetry.
        apply (par_col_par _ _ _ A); Col; Par.
      subst A.
      induction H0; tauto.
    induction(eq_dec_points A O).
      subst A.
      assert(HH:=sum_O_B B H13 ).
      assert(HP:=sum_uniqueness O B C B HS HH).
      subst C.
      clean_trivial_hyps.
      induction H1.
        induction H1.
          apply False_ind.
          apply H1.
          exists E'.
          split; Col.
        spliter.
        apply False_ind.
        apply H.
        apply (col_transitivity_1 _ A'); Col.
      subst A'.
      clean_trivial_hyps.
      induction H5.
        induction H4.
          apply False_ind.
          apply H8.
          apply (par_trans _ _ B C'); Par.
        subst C'.
        split; apply parallelogram_to_plg; apply plg_trivial; auto.
      subst C'.
      split; apply parallelogram_to_plg; apply plg_trivial; auto.
    assert(A' <> O).
      intro.
      subst A'.
      induction H1.
        apply H6.
        apply par_symmetry.
        apply (par_col_par _ _ _ A); Col;Par.
      contradiction.
    assert(A' <> O /\ (Par_strict O E A' C' \/ B = O)).
      apply(sum_par_strict A B C A' C');auto.
      repeat split; auto.
    spliter.
    induction H19.
      assert(Par O B C' A').
        apply par_symmetry.
        apply (par_col_par _ _ _ E); finish.
      assert(Par_strict O B C' A').
        induction H20.
          auto.
        spliter.
        apply False_ind.
        apply H19.
        exists O.
        split; Col.
      (*Par O A' B C'*)
      induction H4.
        assert(Par O A' B C').
          apply par_symmetry.
          apply (par_col_par _ _ _ E'); Par; Col.
        assert(HX:= pars_par_plg O B C' A' H21 H22).
        assert(Par C' A' A C).
          apply(par_col_par _ _ _ O).
            intro.
            subst C.
            apply H15.
            apply sym_equal.
            apply(sum_A_B_A A); auto.
            apply par_right_comm.
            apply(par_col_par _ _ _ B).
              auto.
              Par.
            ColR.
          ColR.
        assert(Par_strict C' A' A C).
          induction H23.
            auto.
          spliter.
          apply False_ind.
          apply H19.
          exists C'.
          split.
            ColR.
          Col.
        induction H1.
          induction H5.
            assert(Par C' C A' A).
              apply (par_trans _ _ E E'); Par.
            assert(HY:= pars_par_plg C' A' A C H24 H25).
            split; auto.
          subst C'.
          assert_diffs;contradiction.
        split; Col.
        subst A'.
        assert_diffs.
        contradiction.
      subst C'.
      assert_diffs.
      contradiction.
    subst B.
    tauto.
Qed.
sum_cong
Proof.
    intros.
    induction(eq_dec_points A O).
      subst A.
      assert(HP:= (sum_O_B_eq B C H)).
      subst C.
      induction H0.
        tauto.
      assert(Parallelogram O O B B).
        apply plg_trivial1; auto.
      induction H1.
        apply False_ind.
        unfold Parallelogram_strict in H1.
        spliter.
        apply par_distincts in H2.
        tauto.
      assumption.
    assert(exists A' C' : Tpoint, Plg O B C' A' /\ Plg C' A' A C).
      apply(sum_plg A B C); auto.
    ex_and H2 A'.
    ex_and H3 C'.
    apply plg_to_parallelogram in H2.
    apply plg_to_parallelogram in H3.
    apply plgf_permut.
    assert(HH:=plg_pseudo_trans O B C' A' A C H2 H3).
    induction HH.
      induction H4.
        apply False_ind.
        apply H4.
        unfold Sum in H.
        spliter.
        unfold Ar2 in H.
        spliter.
        assert_diffs.
        ColR.
      apply plgf_comm2.
      auto.
    spliter.
    subst A.
    apply False_ind.
    subst C.
    tauto.
Qed.
sum_cong2
Proof.
intros.
apply sum_cong in H.
unfold Parallelogram_flat in *.
spliter;split;Cong.
assumption.
Qed.
sum_comm
Proof.
    intros.
    induction (eq_dec_points B O).
      subst B.
      assert(Col O E A).
        unfold Sum in H.
        spliter.
        unfold Ar2 in H.
        tauto.
      assert(C = A).
        apply (sum_uniqueness A O).
          auto.
        apply sum_A_O.
        auto.
      subst C.
      apply sum_O_B.
      auto.
    induction(eq_dec_points A O).
      subst A.
      assert(Col O E B).
        unfold Sum in H.
        spliter.
        unfold Ar2 in H.
        tauto.
      assert(B = C).
        apply (sum_uniqueness O B).
          apply sum_O_B.
          Col.
        auto.
      subst C.
      apply sum_A_O.
      Col.
    assert(A <> O \/ B <> O).
      left.
      auto.
    assert(HH:=grid_not_par).
    spliter.
    assert(HH := sum_plg A B C H H2).
    ex_and HH A'.
    ex_and H9 C'.
    assert(exists ! P' : Tpoint, Proj B P' O E' E E').
      apply(project_existence B O E' E E'); auto.
      intro.
      apply H5.
      Par.
    unfold unique in H11.
    ex_and H11 B'.
    clear H12.
    assert(HH:= parallel_existence1 O E B' H6).
    ex_and HH P'.
    assert(exists! P : Tpoint, Proj A P B' P' O E').
      apply(project_existence A B' P' O E'); auto.
      apply par_distincts in H12.
      spliter.
      auto.
      intro.
      apply H4.
      apply(par_trans _ _ B' P'); Par.
    unfold unique in H13.
    ex_and H13 D'.
    clear H14.
    assert( Ar2 O E E' A B C).
      unfold Sum in H.
      tauto.
    assert(HH:= sum_to_sump O E E' A B C H).
    unfold Sump in H13.
    apply sump_to_sum.
    unfold Sump.
    unfold Ar2 in H14.
    spliter.
    repeat split; Col.
    exists B'.
    exists D'.
    exists P'.
    split; auto.
    split; auto.
    split; auto.
    assert(Par_strict O E B' P').
      induction H12.
        auto.
      spliter.
      apply False_ind.
      assert(HA:=H11).
      unfold Proj in H11.
      spliter.
      assert(Col B' O E).
        apply (col_transitivity_1 _ P'); Col.
      assert(B' <> O).
        intro.
        subst B'.
        apply project_id in HA.
          contradiction.
        induction H24.
          induction H24.
            apply False_ind.
            apply H24.
            exists E.
            split; Col.
          spliter.
          contradiction.
        contradiction.
      apply grid_ok.
      apply (col_transitivity_1 _ B'); Col.
    assert(Par O A B' D').
      apply (par_col_par _ _ _ P').
        intro.
        subst D'.
        unfold Proj in *.
        spliter.
        induction H22.
          induction H22.
            apply H22.
            exists B'.
            split; Col.
          spliter.
          apply grid_ok.
          apply (col_transitivity_1 _ A); Col.
        subst B'.
        apply H18.
        exists A.
        split; Col.
        apply par_symmetry.
        apply (par_col_par _ _ _ E); Col; Par.
      unfold Proj in H13.
      spliter.
      Col.
    assert(Par_strict O A B' D').
      induction H19.
        auto.
      spliter.
      apply False_ind.
      apply H18.
      unfold Proj in H13.
      spliter.
      exists O.
      split.
        Col.
      apply col_permutation_2.
      apply (col_transitivity_1 _ D'); Col.
    assert(Par O B' A D').
      unfold Proj in H13.
      spliter.
      induction H24.
        apply par_symmetry.
        apply(par_col_par _ _ _ E'); Par.
          intro.
          subst B'.
          apply H20.
          exists O.
          split;Col.
        unfold Proj in H11.
        spliter.
        auto.
      subst D'.
      apply False_ind.
      apply H20.
      exists A.
      split; Col.
    assert(Plg O A D' B').
      apply(pars_par_plg O A D' B' ); Par.
    assert(HT:=sum_cong A B C H H2).
    assert(Parallelogram D' B' B C \/ D' = B' /\ O = A /\ C = B /\ D' = C).
      apply(plg_pseudo_trans D' B' O A C B).
        apply plg_to_parallelogram in H22.
        apply plg_permut in H22.
        apply plg_permut in H22.
        auto.
      right.
      auto.
    induction H23.
      repeat split; auto.
      apply plg_permut in H23.
      apply plg_par in H23.
        unfold Proj in *.
        spliter.
        induction H32.
          left.
          apply (par_trans _ _ B B'); Par.
        subst B'.
        apply par_distincts in H23.
        tauto.
        intro.
        subst B'.
        apply H20.
        exists B.
        split.
          ColR.
        Col.
      intro.
      subst C.
      assert(HN:= sum_A_null A B H).
      contradiction.
    spliter.
    subst A.
    tauto.
Qed.
cong_sum
Proof.
    intros A B C.
    intro Hor.
    intros.
    induction (eq_dec_points A O).
      subst A.
      unfold Ar2 in H.
      spliter.
      apply cong_symmetry in H0.
      apply cong_identity in H0.
      subst C.
      apply sum_O_B; Col.
    induction (eq_dec_points B O).
      subst B.
      unfold Ar2 in H.
      spliter.
      apply cong_symmetry in H1.
      apply cong_identity in H1.
      subst C.
      apply sum_A_O; Col.
    unfold Sum.
    split; auto.
    unfold Ar2 in H.
    assert(HH:=grid_not_par).
    spliter.
    assert(exists ! P' : Tpoint, Proj A P' O E' E E').
      apply(project_existence A O E' E E'); auto.
      intro.
      apply H6.
      Par.
    ex_and H13 A'.
    unfold unique in H14.
    spliter.
    clear H14.
    unfold Proj in H13.
    spliter.
    clean_duplicated_hyps.
    assert(HH:=parallel_existence1 O E A' H7).
    ex_and HH P'.
    assert(exists ! C' : Tpoint, Proj B C' A' P' O E').
      apply(project_existence B A' P' O E'); auto.
      apply par_distincts in H.
      spliter.
      auto.
      intro.
      apply H5.
      apply(par_trans _ _ A' P'); Par.
    ex_and H13 C'.
    unfold unique in H14.
    spliter.
    clear H14.
    unfold Proj in H13.
    spliter.
    exists A'.
    exists C'.
    assert(A' <> O).
      intro.
      subst A'.
      induction H17.
        induction H17.
          apply H17.
          exists E.
          split; Col.
        spliter.
        contradiction.
      contradiction.
    assert(Par_strict O E A' P').
      unfold Par_strict.
      repeat split; auto; try apply all_coplanar.
      intro.
      ex_and H21 X.
      induction H.
        apply H.
        exists X.
        split; Col.
      spliter.
      apply grid_ok.
      ColR.
    assert(A <> A').
      intro.
      subst A'.
      apply H21.
      exists A.
      split; Col.
    repeat split; Col.
      induction H17.
        left; Par.
      right; auto.
      left.
      apply (par_col_par _ _ _ P').
        intro.
        subst C'.
        induction H19.
          induction H19.
            apply H19.
            exists A'.
            split; Col.
          spliter.
          apply grid_ok.
          ColR.
        subst A'.
        apply H21.
        exists B.
        split; Col.
        Par.
      Col.
      induction H19.
        left.
        Par.
      right.
      auto.
    assert(A' <> C').
      intro.
      subst C'.
      induction H19.
        induction H19.
          apply H19.
          exists A'.
          split; Col.
        spliter.
        apply grid_ok.
        ColR.
      subst A'.
      apply H21.
      exists B.
      split; Col.
    assert(Plg O B C' A').
      apply(pars_par_plg O B C' A').
        apply par_strict_right_comm.
        apply(par_strict_col_par_strict _ _ _ P').
          auto.
          apply par_strict_symmetry.
          apply(par_strict_col_par_strict _ _ _ E).
            auto.
            Par.
          Col.
        Col.
      induction H19.
        apply par_symmetry.
        apply(par_col_par _ _ _ E').
          auto.
          Par.
        Col.
      subst C'.
      apply False_ind.
      apply H21.
      exists B.
      split; Col.
    assert(Plg O B C A).
      apply(parallelogram_to_plg).
      right.
      unfold Parallelogram_flat.
      repeat split; try ColR.
        Cong.
        Cong.
      auto.
    apply plg_to_parallelogram in H24.
    apply plg_to_parallelogram in H25.
    assert(Parallelogram A C C' A').
      assert(Parallelogram C A A' C' \/ C = A /\ O = B /\ C' = A' /\ C = C').
        apply(plg_pseudo_trans C A O B C' A').
          apply plg_permut.
          apply plg_permut.
          assumption.
        assumption.
      induction H26.
        apply plg_comm2.
        assumption.
      spliter.
      subst C'.
      subst A'.
      tauto.
    apply plg_par in H26.
      spliter.
      induction H17.
        left.
        apply(par_trans _ _ A A'); Par.
      contradiction.
      intro.
      subst C.
      apply cong_identity in H1.
      subst B.
      tauto.
    intro.
    subst C'.
    apply plg_permut in H26.
    induction H19.
      induction H19.
        apply H19.
        exists O.
        split; Col.
        ColR.
      spliter.
      apply grid_ok.
      ColR.
    subst C.
    apply H21.
    exists B.
    split; Col.
Qed.
sum_iff_cong
Proof.
intros.
split.
intros.
apply cong_sum;intuition idtac.
intros.
apply sum_cong2.
assumption.
destruct H.
elim (eq_dec_points A O); intro.
subst.
right.
intro.
subst.
assert (T:= sum_O_O).
destruct H0.
apply H0.
eauto using sum_uniqueness.
intuition.
intuition.
Qed.
opp_comm
Proof.
    intros.
    unfold Opp in *.
    apply sum_comm.
    auto.
Qed.
opp_uniqueness
Proof.
    intros.
    unfold Opp in *.
    apply sum_comm in H.
    apply sum_comm in H0.
    induction(eq_dec_points A O).
      subst A.
      assert(HH:=sum_uniquenessB O MA1 MA2 O H H0).
      assumption.
    apply sum_plg in H.
      apply sum_plg in H0.
        ex_and H A'.
        ex_and H2 C'.
        ex_and H0 A''.
        ex_and H3 C''.
        apply plg_to_parallelogram in H.
        apply plg_to_parallelogram in H0.
        apply plg_to_parallelogram in H2.
        apply plg_to_parallelogram in H3.
        assert(Parallelogram C' A' A'' C'' \/ C' = A' /\ A = O /\ C'' = A'' /\ C' = C'').
          apply(plg_pseudo_trans C' A' A O C'' A''); auto.
          apply plg_permut.
          apply plg_permut.
          auto.
        induction H4.
          assert(Parallelogram O MA1 C'' A'' \/ O = MA1 /\ C' = A' /\ A'' = C'' /\ O = A'').
            apply(plg_pseudo_trans O MA1 C' A' A'' C''); auto.
          induction H5.
            assert(Parallelogram O MA1 MA2 O \/ O = MA1 /\ C'' = A'' /\ O = MA2 /\ O = O).
              apply(plg_pseudo_trans O MA1 C'' A'' O MA2); auto.
              apply plg_permut.
              apply plg_permut.
              assumption.
            induction H6.
              unfold Parallelogram in H6.
              induction H6.
                unfold Parallelogram_strict in H6.
                spliter.
                unfold TS in H6.
                spliter.
                apply False_ind.
                apply H9.
                Col.
              unfold Parallelogram_flat in H6.
              spliter.
              apply cong_symmetry in H9.
              apply cong_identity in H9.
              auto.
            spliter.
            subst MA1.
            subst MA2.
            auto.
          spliter.
          subst MA1.
          subst C''.
          subst A''.
          subst C'.
          unfold Parallelogram in H0.
          induction H0.
            unfold Parallelogram_strict in H0.
            spliter.
            apply par_distincts in H5.
            tauto.
          unfold Parallelogram_flat in H0.
          spliter.
          apply cong_identity in H6.
          auto.
        spliter.
        contradiction.
      left; auto.
    left; auto.
Qed.
pj_uniqueness
Proof.
    intros.
    unfold Pj in *.
    induction(eq_dec_points A O).
      subst A.
      assert(HH:= grid_not_par O E E' H).
      spliter.
      induction H3.
        apply False_ind.
        apply H7.
        apply par_symmetry.
        apply (par_col_par _ _ _ A'); Col.
      subst A'.
      induction H4.
        apply False_ind.
        apply H7.
        apply par_symmetry.
        apply (par_col_par _ _ _ A''); Col.
      auto.
    induction H3; induction H4.
      assert(Par A A' A A'').
        apply (par_trans _ _ E E'); Par.
      induction H6.
        apply False_ind.
        apply H6.
        exists A.
        split; Col.
      spliter.
      apply(l6_21 O E' A A'); Col.
      intro.
      apply H.
      ColR.
      auto.
      subst A''.
      apply False_ind.
      apply H.
      ColR.
      auto.
      subst A'.
      apply False_ind.
      apply H.
      ColR.
    congruence.
Qed.
pj_right_comm
Proof.
    intros.
    unfold Pj in *.
    induction H.
      left.
      Par.
    right.
    auto.
Qed.
pj_left_comm
Proof.
    intros.
    unfold Pj in *.
    induction H.
      left.
      Par.
    right.
    auto.
Qed.
pj_comm
Proof.
    intros.
    apply pj_left_comm.
    apply pj_right_comm.
    auto.
Qed.
proj_preserves_sum
Proof.
    intros.
    assert(HH:= H).
    unfold Sum in HH.
    spliter.
    ex_and H5 A0.
    ex_and H6 C0.
    unfold Ar2 in H4.
    spliter.
    assert(HH:= grid_not_par O E E' H4).
    unfold Ar1 in H0.
    spliter.
    induction(eq_dec_points A O).
      subst A.
      unfold Pj in H1.
      induction H1.
        apply False_ind.
        apply H15.
        apply par_symmetry. (* TODO ameliorier perm apply pour gerer les _ *)
        apply (par_col_par _ _ _ A');Col.
      subst A'.
      assert(B = C).
        apply (sum_O_B_eq O E E'); auto.
      subst C.
      assert(B' = C').
        apply (pj_uniqueness O E E' B); Col.
      subst C'.
      apply sum_O_B; Col.
    induction(eq_dec_points B O).
      subst B.
      unfold Pj in H2.
      induction H2.
        apply False_ind.
        apply H15.
        apply par_symmetry.
        apply (par_col_par _ _ _ B'); Col.
      subst B'.
      assert(A = C).
        apply (sum_A_O_eq O E E'); auto.
      subst C.
      assert(A' = C').
        apply (pj_uniqueness O E E' A); Col.
      subst C'.
      apply sum_A_O; Col.
    assert(A' <> O).
      intro.
      subst A'.
      unfold Pj in H1.
      induction H1.
        apply H13.
        apply par_symmetry.
        apply (par_col_par _ _ _ A);finish.
      contradiction.
    assert(B' <> O).
      intro.
      subst B'.
      unfold Pj in H2.
      induction H2.
        apply H13.
        apply par_symmetry.
        apply (par_col_par _ _ _ B); Par.
        Col.
      contradiction.
    unfold Sum.
    spliter.
    split.
      repeat split; Col.
    assert(HH:=plg_existence A O B' H22).
    ex_and HH D.
    exists A.
    exists D.
    assert(HP:= H26).
    apply plg_par in H26.
      spliter.
      repeat split; Col.
        apply pj_comm; auto.
        left.
        apply par_symmetry.
        apply(par_col_par _ _ _ B'); finish.
        left.
        apply par_symmetry.
        apply(par_col_par _ _ _ A); finish.
      assert(Parallelogram_flat O A C B).
        apply(sum_cong O E E' H4 A B C H).
        left; auto.
      assert(Parallelogram B' D C B \/ B' = D /\ A = O /\ B = C /\ B' = B).
        apply(plg_pseudo_trans B' D A O B C).
          apply plg_permut.
          apply plg_permut.
          auto.
        apply plg_comm2.
        right.
        auto.
      induction H29.
        apply plg_par in H29.
          spliter.
          induction H2.
            induction H3.
              assert(Par B B' C C').
                apply (par_trans _ _ E E'); Par.
              assert(Par C D C C').
                apply(par_trans _ _ B B'); Par.
              induction H32.
                apply False_ind.
                apply H32.
                exists C.
                split; Col.
              spliter.
              left.
              apply par_right_comm.
              apply (par_col_par _ _ _ C); Col; Par.
              intro.
              subst D.
              induction H29.
                apply H29.
                exists O.
                split; ColR.
              spliter.
              apply H25.
              apply(l6_21 O E E' O);sfinish.
            subst C'.
            left.
            apply (par_trans _ _ B B'); Par.
          subst B'.
          apply par_distincts in H30.
          tauto.
          intro.
          subst D.
          apply par_distincts in H26.
          tauto.
        intro.
        subst D.
        induction H27.
          apply H27.
          exists O.
          split; ColR.
        spliter.
        apply H4.
        apply (col_transitivity_1 _ A).
          auto.
          Col.
        apply (col_transitivity_1 _ B'); Col.
      spliter.
      contradiction.
      intro.
      subst.
      intuition.
    intuition.
Qed.
sum_assoc_1
Proof.
    intros.
    assert(HS1:=H).
    assert(HS2:=H0).
    assert(HS3:=H1).
    unfold Sum in H.
    unfold Sum in H0.
    unfold Sum in H1.
    spliter.
    assert(HA1:= H).
    assert(HA2:= H0).
    assert(HA3 := H1).
    unfold Ar2 in H.
    unfold Ar2 in H0.
    unfold Ar2 in H1.
    clear H2.
    clear H3.
    clear H4.
    spliter.
    clean_duplicated_hyps.
    induction (eq_dec_points A O).
      subst A.
      assert(HH:= sum_O_B_eq O E E' H B AB HS1).
      subst AB.
      assert(HH:= sum_O_B_eq O E E' H BC ABC HS3).
      subst BC.
      auto.
    induction (eq_dec_points B O).
      subst B.
      assert(HH:= sum_A_O_eq O E E' H A AB HS1).
      subst AB.
      assert(HH:= sum_O_B_eq O E E' H C BC HS2).
      subst BC.
      auto.
    induction (eq_dec_points C O).
      subst C.
      assert(HH:= sum_A_O_eq O E E' H B BC HS2).
      subst BC.
      assert(HH:=sum_uniqueness O E E' A B AB ABC HS1 HS3).
      subst AB.
      apply sum_A_O; Col.
    assert(HH:= grid_not_par O E E' H).
    spliter.
    apply sum_comm in HS1; auto.
    apply sum_comm in HS3; auto.
    assert(S1:=HS1).
    assert(S2:=HS2).
    assert(S3:=HS3).
    unfold Sum in HS1.
    unfold Sum in HS2.
    unfold Sum in HS3.
    spliter.
    ex_and H20 B1'.
    ex_and H21 A1.
    ex_and H18 B1''.
    ex_and H25 C1.
    ex_and H16 BC3'.
    ex_and H29 A3.
    assert(B1'=B1'').
      apply (pj_uniqueness O E E' B B1' B1''); Col.
    subst B1''.
    clean_duplicated_hyps.
    assert(HH:=sum_par_strict O E E' H B A AB B1' A1 H19 H1 H20 H21 H22 H23 H24).
    spliter.
    assert(Par_strict O E B1' A1).
      induction H25.
        auto.
      contradiction.
    clear H25.
    clear H22.
    assert(HH:=grid_not_par O E E' H).
    spliter.
    assert(exists ! P' : Tpoint, Proj AB P' O E' E E').
      apply(project_existence AB O E' E E' H37 H36).
      intro.
      apply H34.
      Par.
    ex_and H38 AB2'.
    unfold unique in H39.
    spliter.
    clear H39.
    unfold Proj in H38.
    spliter.
    clean_duplicated_hyps.
    assert(A <> AB).
      intro.
      subst AB.
      apply sum_A_B_B in S1.
        contradiction.
      auto.
    assert(ABC <> AB).
      intro.
      subst ABC.
      assert(HP := sum_uniquenessA O E E' H A BC B AB S3 S1).
      subst BC.
      apply sum_A_B_A in S2; auto.
    assert(HH:=plg_existence C O AB2' H2).
    ex_and HH C2.
    induction H42.
      assert(AB <> AB2').
        intro.
        subst AB2'.
        apply par_distincts in H35.
        tauto.
      assert(Pl:=H34).
      assert(O <> AB2').
        intro.
        subst AB2'.
        assert(HH:=plg_trivial C O H2).
        assert(HP:= plg_uniqueness C O O C C2 HH Pl).
        subst C2.
        induction H35.
          apply H35.
          exists E.
          split; Col.
        spliter.
        contradiction.
      apply plg_par in H34; auto.
      spliter.
      repeat split; Col.
      exists AB2'.
      exists C2.
      repeat split.
        left; Par.
        Col.
        left.
        apply (par_trans _ _ O C);Par.
        right.
        repeat split; Col.
        left.
        apply (par_trans _ _ O AB2'); Par.
        right.
        repeat split; Col.
      assert(Parallelogram O BC ABC A).
        right.
        apply(sum_cong O E E' H BC A ABC S3);auto.
      assert(Parallelogram O B AB A).
        right.
        apply(sum_cong O E E' H B A AB S1); auto.
      assert(Parallelogram O B BC C ).
        right.
        apply(sum_cong O E E' H B C BC); auto.
      assert( Parallelogram B AB ABC BC \/ B = AB /\ A = O /\ BC = ABC /\ B = BC).
        apply(plg_pseudo_trans B AB A O BC ABC).
          apply plg_permut.
          assumption.
        apply plg_permut.
        apply plg_permut.
        apply plg_permut.
        assumption.
      assert(Parallelogram B AB ABC BC).
        induction H43.
          assumption.
        spliter.
        contradiction.
      clear H43.
      assert(Parallelogram O C ABC AB \/ O = C /\ BC = B /\ AB = ABC /\ O = AB).
        apply(plg_pseudo_trans O C BC B AB ABC).
          apply plg_permut.
          apply plg_comm2.
          assumption.
        apply plg_permut.
        apply plg_permut.
        apply plg_permut.
        assumption.
      assert(Parallelogram O C ABC AB).
        induction H43.
          assumption.
        spliter.
        subst C.
        tauto.
      clear H43.
      assert(Parallelogram ABC AB AB2' C2 \/ ABC = AB /\ O = C /\ C2 = AB2' /\ ABC = C2).
        apply(plg_pseudo_trans ABC AB O C C2 AB2').
          apply plg_permut.
          apply plg_permut.
          assumption.
        apply plg_comm2.
        assumption.
      assert(Parallelogram ABC AB AB2' C2).
        induction H43.
          assumption.
        spliter.
        subst C.
        tauto.
      clear H43.
      apply plg_par in H46; auto.
      spliter.
      left.
      apply(par_trans _ _ AB AB2'); Par.
    subst AB2'.
    assert(AB = O).
      apply(l6_21 O E E' O); Col.
    subst AB.
    assert(HH:= plg_trivial C O H2).
    assert(Hp:= plg_uniqueness C O O C C2 HH H34).
    subst C2.
    assert(Parallelogram_flat O B BC C).
      apply(sum_cong O E E' H B C BC);auto.
    assert(Parallelogram_flat O BC ABC A).
      apply(sum_cong O E E' H BC A ABC);auto.
    assert(Parallelogram_flat O B O A).
      apply(sum_cong O E E' H B A O); auto.
    assert(Parallelogram BC C A O \/ BC = C /\ O = B /\ O = A /\ BC = O).
      apply(plg_pseudo_trans BC C O B O A).
        apply plg_permut.
        apply plg_permut.
        right; assumption.
      right; assumption.
    assert(Parallelogram BC C A O).
      induction H38.
        assumption.
      spliter.
      subst A.
      tauto.
    clear H38.
    assert(Parallelogram O BC ABC A).
      right; assumption.
    apply plg_permut in H38.
    apply plg_permut in H38.
    apply plg_permut in H38.
    apply plg_permut in H39.
    apply plg_permut in H39.
    assert(HP:=plg_uniqueness A O BC C ABC H39 H38).
    subst ABC.
    apply sum_O_B; Col.
Qed.
sum_assoc_2
Proof.
    intros.
    assert(HS1:=H).
    assert(HS2:=H0).
    assert(HS3:=H1).
    unfold Sum in H.
    unfold Sum in H0.
    unfold Sum in H1.
    spliter.
    unfold Ar2 in H.
    spliter.
    clean_duplicated_hyps.
    apply sum_comm; auto.
    apply(sum_assoc_1 O E E' C B A BC AB ABC ).
      apply sum_comm; auto.
      apply sum_comm; auto.
    apply sum_comm; auto.
Qed.
sum_assoc
Proof.
    intros.
    split; intro.
      apply(sum_assoc_1 O E E' A B C AB BC ABC); auto.
    apply(sum_assoc_2 O E E' A B C AB BC ABC); auto.
Qed.
sum_y_axis_change
Proof.
    intros.
    assert(HS:= H).
    assert(Ar2 O E E' A B C).
      unfold Sum in H.
      tauto.
    assert(HA:=H1).
    unfold Ar2 in H1.
    spliter.
    assert(HH:=grid_not_par O E E' H1).
    spliter.
    induction(eq_dec_points A O).
      subst A.
      apply sum_O_B_eq in H; Col.
      subst C.
      apply sum_O_B; Col.
    induction(eq_dec_points B O).
      subst B.
      apply sum_A_O_eq in H; Col.
      subst C.
      apply sum_A_O; Col.
    apply sum_plg in H; auto.
    ex_and H A'.
    ex_and H13 C'.
    assert(exists ! P' : Tpoint, Proj A P' O E'' E E'').
      apply(project_existence A O E'' E E''); intro; try (subst E''; apply H0; Col).
      induction H14.
        apply H14.
        exists E''.
        split; Col.
      spliter.
      apply H0.
      Col.
    ex_and H14 A''.
    unfold unique in H15.
    spliter.
    clear H15.
    unfold Proj in H14.
    spliter.
    assert(Par A A'' E E'').
      induction H18; auto.
      subst A''.
      apply False_ind.
      apply H0.
      ColR.
    clear H18.
    assert(HH:= plg_existence B O A'' H12).
    ex_and HH C''.
    apply plg_to_parallelogram in H.
    apply plg_to_parallelogram in H13.
    assert(A'' <> O).
      intro.
      subst A''.
      induction H19.
        apply H19.
        exists E.
        split; Col.
      spliter.
      contradiction.
    repeat split; Col.
    exists A''.
    exists C''.
    repeat split.
      left.
      Par.
      Col.
      apply plg_par in H18; auto.
      spliter.
      left.
      apply par_symmetry.
      apply (par_col_par _ _ _ B); Par; Col.
      apply plg_par in H18; auto.
      spliter.
      left.
      apply par_symmetry.
      apply (par_col_par _ _ _ A''); Par; Col.
    left.
    assert(Parallelogram_flat O A C B).
      apply(sum_cong O E E' H1 A B C HS).
      left; auto.
    assert(Parallelogram O A C B).
      right; auto.
    assert(Parallelogram C'' A'' A C \/ C'' = A'' /\ O = B /\ C = A /\ C'' = C).
      apply(plg_pseudo_trans C'' A'' O B C A).
        apply plg_comm2.
        apply plg_permut.
        apply plg_permut.
        assumption.
      apply plg_permut in H22.
      apply plg_comm2.
      apply plg_permut.
      apply plg_permut.
      assumption.
    assert(Parallelogram C'' A'' A C).
      induction H23.
        assumption.
      spliter.
      subst B.
      tauto.
    clear H23.
    assert(A <> C).
      intro.
      subst C.
      assert(Parallelogram O A A O).
        apply(plg_trivial O A); auto.
      assert(HH:=plg_uniqueness O A A O B H23 H22).
      subst B.
      tauto.
    assert(A <> A'').
      intro.
      subst A''.
      apply par_distincts in H19.
      tauto.
    assert(A'' <> C'').
      intro.
      subst C''.
      assert(Parallelogram A'' A'' A A).
        apply(plg_trivial1); auto.
      assert(HH:= plg_uniqueness A'' A'' A A C H26 H24).
      contradiction.
    apply plg_par in H24; auto.
    spliter.
    apply(par_trans _ _ A'' A); Par.
Qed.
sum_x_axis_unit_change
Proof.
    intros.
    induction (eq_dec_points U E).
      subst U.
      assumption.
    assert(HS:= H).
    assert(Ar2 O E E' A B C).
      unfold Sum in H.
      tauto.
    assert(HA:=H3).
    unfold Ar2 in H3.
    spliter.
    assert(HH:=grid_not_par O E E' H3).
    spliter.
    assert(~Col O U E').
      intro.
      apply H3.
      ColR.
    assert(HH:=grid_not_par O U E' H13).
    spliter.
    induction(eq_dec_points A O).
      subst A.
      apply sum_O_B_eq in H; Col.
      subst C.
      apply sum_O_B; Col.
      ColR.
    induction(eq_dec_points B O).
      subst B.
      apply sum_A_O_eq in H; Col.
      subst C.
      apply sum_A_O; Col.
      ColR.
    apply sum_plg in H; auto.
    ex_and H A'.
    ex_and H22 C'.
    apply plg_to_parallelogram in H.
    apply plg_to_parallelogram in H22.
    assert(Ar2 O U E' A B C).
      repeat split ; auto; ColR.
    assert(HB:= H23).
    unfold Ar2 in H23.
    spliter.
    clean_duplicated_hyps.
    assert(exists ! P' : Tpoint, Proj A P' O E' U E').
      apply(project_existence A O E' U E' H19 H11 ).
      intro.
      apply H16.
      Par.
    ex_and H18 A''.
    unfold unique in H23.
    spliter.
    clear H23.
    unfold Proj in H18.
    spliter.
    clean_duplicated_hyps.
    assert(Par A A'' U E').
      induction H29.
        assumption.
      subst A''.
      apply False_ind.
      apply H3.
      ColR.
    clear H29.
    assert(HH:= plg_existence B O A'' H21).
    ex_and HH C''.
    assert(O <> A'').
      intro.
      subst A''.
      assert(HH:=plg_trivial B O H21).
      assert(B = C'').
        apply (plg_uniqueness B O O B C''); auto.
      subst C''.
      induction H18.
        apply H18.
        exists U.
        split; Col.
      spliter.
      apply H3.
      ColR.
    assert(HP1:=H23).
    apply plg_par in H23; auto.
    spliter.
    repeat split; auto.
    exists A''.
    exists C''.
    repeat split.
      left.
      Par.
      Col.
      left.
      assert(Par O U B O).
        right.
        repeat split; Col.
      apply (par_trans _ _ B O); Par.
      left.
      assert(Par O E' O A'').
        right.
        repeat split; Col.
      apply(par_trans _ _ O A''); Par.
    assert(Parallelogram_flat O A C B).
      apply(sum_cong O E E' H3 A B C HS); auto.
    assert(Parallelogram O A C B).
      right.
      assumption.
    assert(Parallelogram A C C'' A'' \/ A = C /\ B = O /\ A'' = C'' /\ A = A'').
      apply(plg_pseudo_trans A C B O A'' C'').
        apply plg_permut.
        assumption.
      assumption.
    assert(Parallelogram A C C'' A'').
      induction H32.
        assumption.
      spliter.
      contradiction.
    clear H32.
    apply plg_par in H33.
      left.
      spliter.
      apply(par_trans _ _ A A''); Par.
      intro.
      subst C.
      apply sum_B_null in HS.
        contradiction.
      auto.
    intro.
    subst C''.
    induction H23.
      apply H23.
      exists C.
      split; Col.
      ColR.
    spliter.
    apply H3.
    ColR.
Qed.
change_grid_sum_0
Proof.
    intros.
    assert(HS:= H6).
    induction H6.
    ex_and H8 A1.
    ex_and H9 C1.
    unfold Ar1 in *.
    unfold Ar2 in H6.
    spliter.
    subst A.
    clean_duplicated_hyps.
    assert(A' = O').
      apply(l6_21 O' E' O O');Col.
        intro.
        apply H.
        exists O.
        split; Col.
        intro.
        apply H.
        subst O'.
        exists O.
        split; Col.
      unfold Pj in H3.
      induction H3.
        induction H3.
          apply False_ind.
          apply H3.
          exists O.
          split; Col.
        spliter.
        Col.
      subst A'.
      Col.
    subst A'.
    assert(Sum O E E' O B B).
      apply sum_O_B. assumption. Col.
    unfold Sum in H7.
      assert(B = C).
        apply(sum_uniqueness O E E' O B); auto.
      subst C.
      assert(B' = C').
        apply(l6_21 O' E' B B'); Col.
          intro.
          apply H.
          exists B.
          split; Col.
          intro.
          subst B'.
          apply H.
          exists B.
          split; Col.
        induction H5.
          induction H4.
            assert(Par B C' B B').
              apply(par_trans _ _ O O'); Par.
            induction H13.
              apply False_ind.
              apply H13.
              exists B.
              split; Col.
            spliter.
            Col.
          subst B'.
          Col.
        subst C'.
        Col.
      subst C'.
      apply sum_O_B;Col.
      assert_diffs. Col.
Qed.
change_grid_sum
Proof.
    intros.
    induction(eq_dec_points A O).
      subst A.
      apply(change_grid_sum_0 O E E' O B C); auto.
    assert(HS:= H6).
    induction H6.
    ex_and H8 A1.
    ex_and H9 C1.
    unfold Ar1 in *.
    unfold Ar2 in H6.
    spliter.
    assert(HG:=grid_not_par O E E' H6).
    spliter.
    assert(~Col O' E' E).
      intro.
      apply H.
      exists E.
      split; Col.
    assert(HG:=grid_not_par O' E' E H28).
    spliter.
    clean_duplicated_hyps.
    induction(eq_dec_points B O).
      subst B.
      apply sum_comm; Col.
      apply sum_comm in HS; Col.
      apply(change_grid_sum_0 O E E' O A C); auto.
        repeat split; auto.
      repeat split; auto.
    assert(A' <> O).
      intro.
      subst A'.
      induction H3.
        induction H3.
          apply H3.
          exists O.
          split; Col.
        spliter.
        apply H.
        exists O'.
        split; Col.
        ColR.
      contradiction.
    assert(~Col O A A').
      intro.
      apply H.
      exists A'.
      split; Col.
      ColR.
    assert(A' <> O').
      intro.
      subst A'.
      induction H3.
        induction H3.
          apply H3.
          exists O'.
          split; Col.
        spliter.
        contradiction.
      subst A.
      apply H15.
      Col.
    assert(Parallelogram_flat O A C B).
      apply(sum_cong O E E' H6 A B C HS).
      left.
      auto.
    unfold Parallelogram_flat in H32.
    spliter.
    assert(Proj O O' O' E' E E').
      unfold Proj.
      repeat split; Col.
        intro.
        apply H29.
        Par.
      induction H2.
        left; Par.
      subst E'.
      tauto.
    assert(Proj A A' O' E' E E').
      unfold Proj.
      repeat split; Col.
        intro.
        apply H29.
        Par.
      induction H3.
        left.
        induction H2.
          apply (par_trans _ _ O O'); Par.
        subst E'.
        tauto.
      subst A'.
      right.
      auto.
    assert(Proj C C' O' E' E E').
      unfold Proj.
      repeat split; Col.
        intro.
        apply H29.
        Par.
      induction H5.
        left.
        induction H2.
          apply (par_trans _ _ O O'); Par.
        subst E'.
        tauto.
      right.
      auto.
    assert(Proj B B' O' E' E E').
      unfold Proj.
      repeat split; Col.
        intro.
        apply H29.
        Par.
      induction H4.
        left.
        induction H2.
          apply (par_trans _ _ O O'); Par.
        subst E'.
        tauto.
      right.
      auto.
    assert(EqV O A B C).
      unfold EqV.
      left.
      right.
      apply plgf_permut.
      unfold Parallelogram_flat.
      repeat split; Col; Cong.
        ColR.
      induction H38.
        right.
        auto.
      left.
      auto.
    assert(HH:=project_preserves_eqv O A B C O' A' B' C' O' E' E E' H43 H39 H40 H42 H41).
    unfold EqV in HH.
    induction HH.
      assert(Parallelogram_flat O' A' C' B').
        induction H44.
          induction H44.
          unfold TS in H44.
          spliter.
          apply False_ind.
          apply H47.
          ColR.
        assumption.
      unfold Parallelogram_flat in H45.
      spliter.
      apply cong_sum; auto.
        induction H49.
          left; auto.
        right; auto.
        repeat split; Col.
        Cong.
      Cong.
    spliter.
    subst A'.
    tauto.
Qed.
double_null_null
Proof.
    intros.
    induction (eq_dec_points A O).
      assumption.
    assert(HS:= H).
    unfold Sum in H.
    spliter.
    unfold Ar2 in H.
    spliter.
    assert(Parallelogram_flat O A O A).
      apply(sum_cong O E E' H A A O HS).
      left; auto.
    unfold Parallelogram_flat in H5.
    tauto.
Qed.
not_null_double_not_null
Proof.
    intros.
    intro.
    subst C.
    apply double_null_null in H.
    contradiction.
Qed.
double_not_null_not_nul
Proof.
    intros.
    intro.
    subst A.
    assert(HS:= H).
    unfold Sum in H.
    spliter.
    unfold Ar2 in H.
    spliter.
    assert(HH:= sum_O_O O E E' H).
    apply H0.
    apply (sum_uniqueness O E E' O O); assumption.
Qed.
diff_ar2
Proof.
    intros.
    unfold Diff in H.
    ex_and H MA.
    unfold Opp in H.
    unfold Sum in *.
    spliter.
    unfold Ar2 in *.
    spliter.
    repeat split; auto.
Qed.
diff_null
Proof.
    intros.
    unfold Diff.
    assert(Hop:=opp_exists O E E' H A H0).
    ex_and Hop MB.
    exists MB.
    split; auto.
    unfold Opp in H1.
    apply sum_comm; auto.
Qed.
diff_exists
Proof.
    intros.
    assert(Hop:=opp_exists O E E' H B H1).
    ex_and Hop MB.
    assert(Col O E MB).
      unfold Opp in H2.
      unfold Sum in H2.
      spliter.
      unfold Ar2 in H2.
      tauto.
    assert(HS:=sum_exists O E E' H A MB H0 H3).
    ex_and HS C.
    exists C.
    unfold Diff.
    exists MB.
    split; assumption.
Qed.
diff_uniqueness
Proof.
    intros.
    assert(Ar2 O E E' A B D1).
      apply (diff_ar2); assumption.
    unfold Ar2 in H1.
    spliter.
    unfold Diff in *.
    ex_and H MB1.
    ex_and H0 MB2.
    assert(MB1 = MB2).
      apply (opp_uniqueness O E E' H1 B); assumption.
    subst MB2.
    apply(sum_uniqueness O E E'  A MB1); assumption.
Qed.
sum_ar2
Proof.
    intros.
    unfold Sum in H.
    tauto.
Qed.
diff_A_O
Proof.
    intros.
    unfold Diff.
    exists O.
    split.
      unfold Opp.
      apply sum_O_O; auto.
    apply sum_A_O;auto.
Qed.
diff_O_A
Proof.
    intros.
    assert (Col O E A) by (unfold Opp, Sum, Ar2 in *; spliter; auto).
    assert (Col O E mA) by (unfold Opp, Sum, Ar2 in *; spliter; auto).
    revert H0; revert H1; revert H2; intros.
    unfold Diff.
    exists mA.
    split.
      assumption.
    apply sum_O_B; auto.
Qed.
diff_O_A_opp
Proof.
    intros.
    assert(Ar2 O E E' O A mA).
      apply diff_ar2;auto.
    unfold Diff in H.
    ex_and H A'.
    assert(Ar2 O E E' O A' mA).
      apply sum_ar2; auto.
    unfold Ar2 in *.
    spliter.
    clean_duplicated_hyps.
    assert(Sum O E E' O A' A').
      apply (sum_O_B); auto.
    assert(mA = A').
      apply(sum_uniqueness O E E' O A'); auto.
    subst A'.
    assumption.
Qed.
diff_uniquenessA
Proof.
    intros.
    assert(Ar2 O E E' A B C).
      apply diff_ar2; auto.
    assert(Ar2 O E E' A' B C).
      apply diff_ar2; auto.
    unfold Ar2 in *.
    spliter.
    clean_duplicated_hyps.
    unfold Diff in *.
    ex_and H mB.
    ex_and H0 mB'.
    assert(mB = mB').
      apply(opp_uniqueness O E E' H1 B); auto.
    subst mB'.
    apply (sum_uniquenessA O E E' H1 mB A A' C); auto.
Qed.
diff_uniquenessB
Proof.
    intros.
    assert(Ar2 O E E' A B C).
      apply diff_ar2; auto.
    assert(Ar2 O E E' A B' C).
      apply diff_ar2; auto.
    unfold Ar2 in *.
    spliter.
    clean_duplicated_hyps.
    unfold Diff in *.
    ex_and H mB.
    ex_and H0 mB'.
    assert(mB = mB').
      apply (sum_uniquenessA O E E' H1 A mB mB' C); apply sum_comm; auto.
    subst mB'.
    apply (opp_uniqueness O E E' H1 mB); apply opp_comm; auto.
Qed.
diff_null_eq
Proof.
    intros.
    assert(Ar2 O E E' A B O).
      apply diff_ar2; auto.
    unfold Ar2 in H0.
    spliter.
    clear H3.
    assert(Diff O E E' A A O).
      apply diff_null; Col.
    apply (diff_uniquenessB O E E' A _ _ O); auto.
Qed.
midpoint_opp:
Proof.
    intros.
    unfold Ar2.
    unfold Ar2 in H.
    spliter.
    clear H1.
    unfold Midpoint in H0.
    spliter.
    induction (eq_dec_points A B).
      subst B.
      apply between_identity in H0.
      subst A.
      apply opp0; auto.
    unfold Opp.
    apply cong_sum; auto.
      unfold Ar2.
      repeat split; Col.
      Cong.
    Cong.
Qed.
sum_diff
Proof.
    intros.
    assert(Ar2 O E E' A B S).
      apply sum_ar2; auto.
    unfold Ar2 in H0.
    spliter.
    assert(HH:=opp_exists O E E' H0 A H1).
    ex_and HH mA.
    exists mA.
    split; auto.
    unfold Opp in H4.
    assert(Ar2 O E E' mA A O).
      apply sum_ar2; auto.
    unfold Ar2 in H5.
    spliter.
    clean_duplicated_hyps.
    clear H8.
    induction(eq_dec_points A O).
      subst A.
      assert(B = S).
        apply (sum_uniqueness O E E' O B); auto.
        apply sum_O_B; auto.
      subst S.
      assert(mA = O).
        apply (sum_uniqueness O E E' mA O); auto.
        apply sum_A_O; auto.
      subst mA.
      apply sum_A_O; auto.
    induction(eq_dec_points B O).
      subst B.
      assert(A = S).
        apply (sum_uniqueness O E E' A O); auto.
        apply sum_A_O; auto.
      subst S.
      apply sum_comm; auto.
    apply sum_cong in H; auto.
    apply sum_cong in H4; auto.
    assert(E <> O).
      intro.
      subst E.
      apply H0.
      Col.
    assert(Parallelogram O mA B S \/ O = mA /\ O = A /\ S = B /\ O = S).
      apply(plg_pseudo_trans O mA O A S B); auto.
        right; auto.
      right; auto.
    induction H9.
      induction H9.
        apply False_ind.
        unfold Parallelogram_strict in H9.
        spliter.
        unfold TS in H9.
        spliter.
        apply H12.
        ColR.
      unfold Parallelogram_flat in H.
      unfold Parallelogram_flat in H4.
      unfold Parallelogram_flat in H9.
      spliter.
      apply cong_sum; auto.
        repeat split; Col.
        Cong.
      Cong.
    spliter.
    subst A.
    tauto.
Qed.
diff_sum
Proof.
intros.
assert(Ar2 O E E' S A B).
apply diff_ar2; auto.
unfold Ar2 in H0.
spliter.
induction(eq_dec_points A O).
subst A.
assert(HH:=diff_A_O O E E' S H0 H1).
assert(S = B).
apply (diff_uniqueness O E E' S O); auto.
subst B.
apply sum_O_B; auto.
unfold Diff in H.
ex_and H mA.
assert(mA <> O).
intro.
subst mA.
assert(HH:=opp0 O E E' H0).
apply H4.
apply (opp_uniqueness O E E' H0 O); auto.
apply opp_comm; auto.
unfold Opp in H.
induction(eq_dec_points S O).
subst S.
assert(mA = B).
apply (sum_O_B_eq O E E'); auto.
subst mA.
apply sum_comm; auto.
apply sum_cong in H; auto.
apply sum_cong in H5; auto.
assert(E <> O).
intro.
subst E.
apply H0.
Col.
assert(Parallelogram O A S B \/ O = A /\ O = mA /\ B = S /\ O = B).
apply(plg_pseudo_trans O A O mA B S).
apply plg_permut.
apply plg_permut.
right.
assumption.
apply plg_comm2.
apply plg_permut.
apply plg_permut.
apply plg_permut.
right.
auto.
induction H9.
induction H9.
apply False_ind.
unfold Parallelogram_strict in H9.
spliter.
unfold TS in H9.
spliter.
apply H12.
ColR.
unfold Parallelogram_flat in H.
unfold Parallelogram_flat in H5.
unfold Parallelogram_flat in H9.
spliter.
apply cong_sum; Cong.
repeat split; Col.
spliter.
subst A.
tauto.
Qed.
diff_opp
Proof.
    intros.
    assert(Ar2 O E E' A B AmB).
      apply diff_ar2; auto.
    assert(Ar2 O E E' B A BmA).
      apply diff_ar2; auto.
    unfold Ar2 in *.
    spliter.
    clean_duplicated_hyps.
    apply diff_sum in H.
    apply diff_sum in H0.
    induction(eq_dec_points A O).
      subst A.
      assert(BmA = B).
        apply(sum_O_B_eq O E E'); auto.
      subst BmA.
      unfold Opp.
      assumption.
    induction(eq_dec_points B O).
      subst B.
      assert(AmB = A).
        apply(sum_O_B_eq O E E'); auto.
      subst AmB.
      unfold Opp.
      apply sum_comm; auto.
    apply sum_cong in H0; auto.
    apply sum_cong in H; auto.
    assert(Parallelogram A O BmA B).
      apply plg_comm2.
      right.
      assumption.
    apply plg_permut in H4.
    apply plg_permut in H4.
    apply plg_permut in H4.
    assert(Parallelogram AmB O BmA O \/ AmB = O /\ B = A /\ O = BmA /\ AmB = O).
      apply(plg_pseudo_trans AmB O  B A O BmA).
        apply plg_permut.
        apply plg_permut.
        apply plg_permut.
        right; assumption.
      assumption.
    assert(E <> O).
      intro.
      subst E.
      apply H1.
      Col.
    induction H9.
      induction H9.
        apply False_ind.
        unfold Parallelogram_strict in H9.
        unfold TS in H9.
        spliter.
        apply H13.
        ColR.
      unfold Parallelogram_flat in H.
      unfold Parallelogram_flat in H0.
      unfold Parallelogram_flat in H9.
      spliter.
      unfold Opp.
      apply cong_sum; Cong.
        right.
        intro.
        subst BmA.
        tauto.
      repeat split; Col.
    spliter.
    subst AmB.
    subst BmA.
    unfold Opp.
    apply sum_O_O; auto.
Qed.
sum_stable
Proof.
    intros.
    subst B.
    apply (sum_uniqueness O E E' A C); auto.
Qed.
diff_stable
Proof.
    intros.
    subst B.
    apply(diff_uniqueness O E E' A C); auto.
Qed.
plg_to_sum
Proof.
    intros.
    induction(eq_dec_points A B).
      subst B.
      unfold Parallelogram_flat in H0.
      spliter.
      assert(O = C \/ Midpoint A O C).
        apply(l7_20 A O C H0).
        Cong.
      induction H5.
        subst C.
        tauto.
      apply cong_sum; auto.
        unfold Ar2 in H.
        tauto.
        unfold Midpoint in H5.
        tauto.
      unfold Midpoint in H5.
      tauto.
    unfold Ar2 in H.
    unfold Parallelogram_flat in H0.
    spliter.
    apply cong_sum; auto.
      repeat split; auto.
      Cong.
    Cong.
Qed.
opp_midpoint
Proof.
    intros.
    unfold Opp in H.
    assert(HS:=H).
    unfold Sum in H.
    spliter.
    unfold Ar2 in H.
    spliter.
    induction (eq_dec_points A O).
      subst A.
      assert(HH:= sum_A_O_eq O E E' H MA O HS).
      subst MA.
      unfold Midpoint.
      split; Cong.
      apply between_trivial.
    assert(Parallelogram_flat O MA O A).
      apply(sum_cong O E E' H MA A O HS).
      tauto.
    unfold Parallelogram_flat in H5.
    spliter.
    assert(A = MA \/ Midpoint O A MA).
      apply(l7_20 O A MA).
        Col.
      Cong.
    induction H10.
      subst MA.
      tauto.
    assumption.
Qed.
diff_to_plg
Proof.
    intros.
    assert(Ar2 O E E' B A dBA).
      apply diff_ar2; auto.
    unfold Ar2 in H1.
    spliter.
    apply diff_sum in H0.
    induction(eq_dec_points A O).
      subst A.
      assert(dBA = B).
        apply(sum_O_B_eq O E E'); auto.
      subst dBA.
      apply plgf_permut.
      apply plgf_trivial.
      induction H; tauto.
    assert(E <> O).
      intro.
      subst E.
      apply H1.
      Col.
    induction(eq_dec_points B O).
      subst B.
      assert(Opp O E E' dBA A).
        unfold Opp.
        auto.
      apply opp_midpoint in H7.
      unfold Midpoint in H7.
      spliter.
      unfold Parallelogram_flat.
      repeat split; try ColR.
        Cong.
        Cong.
    apply sum_cong in H0; auto.
Qed.
sum3_col
Proof.
    intros.
    unfold sum3 in H.
    ex_and H AB.
    assert(Ar2 O E E' A B AB).
      apply sum_ar2; auto.
    assert(Ar2 O E E' AB C S).
      apply sum_ar2; auto.
    unfold Ar2 in *.
    spliter.
    repeat split; auto.
Qed.
sum3_permut
Proof.
    intros.
    assert(~Col O E E' /\ Col O E A /\ Col O E B /\ Col O E C /\ Col O E S).
      apply sum3_col; auto.
    spliter.
    unfold sum3 in H.
    ex_and H AB.
    assert(HH:= sum_exists O E E' H0 A C H1 H3).
    ex_and HH AC.
    unfold sum3.
    exists AC.
    split.
      apply sum_comm; auto.
    apply sum_comm in H5; auto.
    apply sum_comm in H6; auto.
    assert(HH:=sum_assoc O E E' C A B AC AB S H6 H).
    destruct HH.
    apply H7; auto.
Qed.
sum3_comm_1_2
Proof.
    intros.
    assert(~Col O E E' /\ Col O E A /\ Col O E B /\ Col O E C /\ Col O E S).
      apply sum3_col; auto.
    spliter.
    unfold sum3 in H.
    ex_and H AB.
    unfold sum3.
    exists AB.
    split.
      apply sum_comm; auto.
    auto.
Qed.
sum3_comm_2_3
Proof.
    intros.
    apply sum3_permut in H.
    apply sum3_comm_1_2 in H.
    assumption.
Qed.
sum3_exists
Proof.
    intros.
    unfold Ar2 in *.
    spliter.
    assert(HH:=sum_exists O E E' H A B H0 H1).
    ex_and HH AB.
    assert(Ar2 O E E' A B AB).
      apply sum_ar2; auto.
    unfold Ar2 in H4.
    spliter.
    clean_duplicated_hyps.
    assert(HH:=sum_exists O E E' H AB C H7 H2).
    ex_and HH ABC.
    exists ABC.
    unfold sum3.
    exists AB.
    split; auto.
Qed.
sum3_uniqueness
Proof.
    intros.
    unfold sum3 in H.
    unfold sum3 in H0.
    ex_and H AB1.
    ex_and H0 AB2.
    assert(AB1 = AB2).
      apply(sum_uniqueness O E E' A B); auto.
    subst AB2.
    apply (sum_uniqueness O E E' AB1 C); auto.
Qed.
sum4_col
Proof.
    intros.
    unfold Sum4 in H.
    ex_and H ABC.
    assert(HH:=sum3_col O E E' A B C ABC H).
    assert(Ar2 O E E' ABC D S).
      apply sum_ar2; auto.
    unfold Ar2 in *.
    spliter.
    repeat split; auto.
Qed.
sum22_col
Proof.
    intros.
    unfold sum22 in H.
    ex_and H AB.
    ex_and H0 CD.
    assert(Ar2 O E E' A B AB).
      apply sum_ar2; auto.
    assert(Ar2 O E E' C D CD).
      apply sum_ar2; auto.
    assert(Ar2 O E E' AB CD S).
      apply sum_ar2; auto.
    unfold Ar2 in *.
    spliter.
    repeat split; auto.
Qed.
sum_to_sum3
Proof.
    intros.
    unfold sum3.
    exists AB.
    split; auto.
Qed.
sum3_to_sum4
Proof.
    intros.
    assert(~Col O E E' /\ Col O E A /\ Col O E B /\ Col O E C /\ Col O E ABC).
      apply sum3_col; auto.
    assert(Ar2 O E E' ABC X S).
      apply sum_ar2; auto.
    unfold Ar2 in H2.
    spliter.
    clean_duplicated_hyps.
    unfold Sum4.
    exists ABC.
    split; auto.
Qed.
sum_A_exists
Proof.
    intros.
    unfold Ar2 in *.
    spliter.
    assert(HH:=diff_exists O E E' AB A H H1 H0).
    ex_and HH B.
    exists B.
    apply diff_sum in H3.
    assumption.
Qed.
sum_B_exists
Proof.
    intros.
    unfold Ar2 in *.
    spliter.
    assert(HH:=diff_exists O E E' AB B H H1 H0).
    ex_and HH A.
    exists A.
    apply diff_sum in H3.
    apply sum_comm; auto.
Qed.
sum4_equiv
Proof.
    intros.
    split.
      intro.
      assert(~Col O E E' /\ Col O E A /\ Col O E B /\ Col O E C /\ Col O E D /\ Col O E S).
        apply sum4_col; auto.
      spliter.
      assert(HS1:= sum_exists O E E' H0 A B H1 H2).
      assert(HS2:= sum_exists O E E' H0 C D H3 H4).
      ex_and HS1 AB.
      ex_and HS2 CD.
      unfold sum22.
      exists AB.
      exists CD.
      assert(Ar2 O E E' A B AB).
        apply sum_ar2; auto.
      assert(Ar2 O E E' C D CD).
        apply sum_ar2; auto.
      unfold Ar2 in *.
      spliter.
      clean_duplicated_hyps.
      split; auto.
      split; auto.
      unfold Sum4 in H.
      ex_and H ABC.
      unfold sum3 in H.
      ex_and H AB'.
      assert(AB' = AB).
        apply(sum_uniqueness O E E' A B); auto.
      subst AB'.
      assert(HH:= sum_assoc O E E' AB C D ABC CD S H9 H7).
      destruct HH.
      apply H11.
      assumption.
    intro.
    unfold sum22 in H.
    ex_and H AB.
    ex_and H0 CD.
    assert(Ar2 O E E' A B AB).
      apply sum_ar2; auto.
    assert(Ar2 O E E' C D CD).
      apply sum_ar2; auto.
    assert(Ar2 O E E' AB CD S).
      apply sum_ar2; auto.
    unfold Ar2 in *.
    spliter.
    clean_duplicated_hyps.
    unfold Sum4.
    assert(HS:=sum_exists O E E' H2 AB C H13 H8).
    ex_and HS ABC.
    exists ABC.
    split.
      unfold sum3.
      exists AB.
      split; auto.
    assert(HH:= sum_assoc O E E' AB C D ABC CD S H3 H0).
    destruct HH.
    apply H4.
    assumption.
Qed.
sum4_permut:
Proof.
    intros.
    assert( ~Col O E E' /\ Col O E A /\ Col O E B /\ Col O E C /\ Col O E D /\ Col O E S).
      apply sum4_col; auto.
    spliter.
    assert(HH:=sum4_equiv O E E' A B C D S).
    destruct HH.
    assert(sum22 O E E' A B C D S).
      apply H6; auto.
    unfold sum22 in H8.
    ex_and H8 AB.
    ex_and H9 CD.
    apply sum_comm in H9; auto.
    apply sum_comm in H10; auto.
    unfold Sum4 in H.
    ex_and H ABC.
    assert(HH:= sum_assoc O E E' D C AB CD ABC S H9).
    assert(HP:=sum3_permut O E E' A B C ABC H).
    unfold sum3 in HP.
    ex_and HP AC.
    assert(HP:= sum_assoc O E E' C A B AC AB ABC H12 H8).
    destruct HP.
    assert(Sum O E E' C AB ABC).
      apply H15; auto.
    apply HH in H16.
    destruct H16.
    assert(Sum O E E' D ABC S).
      apply H17; auto.
    assert(HP:= sum_exists O E E' H0 D A H4 H1); auto.
    ex_and HP AD.
    assert(Ar2 O E E' D A AD).
      apply sum_ar2; auto.
    unfold Ar2 in H20.
    spliter.
    clean_trivial_hyps.
    assert(HP:= sum_exists O E E' H0 AD B H23 H2); auto.
    ex_and HP ABD.
    assert(HP:= sum_assoc O E E' D A B  AD AB ABD H19 H8).
    destruct HP.
    apply H26 in H24.
    unfold Sum4.
    exists ABD.
    split.
      unfold sum3.
      exists AD.
      split; auto.
    unfold sum3 in H.
    ex_and H AB'.
    assert(AB'=AB).
      apply (sum_uniqueness O E E' A B); auto.
    subst AB'.
    assert(HP:= sum_assoc O E E' D AB C ABD ABC S H24 H27).
    destruct HP.
    apply H28.
    auto.
Qed.
sum22_permut
Proof.
    intros.
    assert(HH:= sum4_equiv O E E' A B C D S).
    destruct HH.
    assert(Sum4 O E E' A B C D S).
      apply H1; auto.
    assert(Sum4 O E E' D A B C S).
      apply sum4_permut; auto.
    assert(HH:= sum4_equiv O E E' D A B C S).
    destruct HH.
    apply H4.
    auto.
Qed.
sum4_comm
Proof.
    intros.
    assert(~Col O E E' /\ Col O E A /\ Col O E B /\ Col O E C /\ Col O E D /\ Col O E S).
      apply sum4_col; auto.
    spliter.
    assert(HH:= sum4_equiv O E E' A B C D S).
    destruct HH.
    apply H6 in H.
    unfold sum22 in H.
    ex_and H AB.
    ex_and H8 CD.
    apply sum_comm in H; auto.
    assert(sum22 O E E' B A C D S).
      unfold sum22.
      exists AB.
      exists CD.
      split; auto.
    assert(HH:= sum4_equiv O E E'  B A C D S).
    destruct HH.
    apply H12; auto.
Qed.
sum22_comm
Proof.
    intros.
    assert(~Col O E E' /\ Col O E A /\ Col O E B /\ Col O E C /\ Col O E D /\ Col O E S).
      apply sum22_col; auto.
    spliter.
    unfold sum22 in H.
    ex_and H AB.
    ex_and H6 CD.
    unfold sum22.
    exists AB.
    exists CD.
    split; auto.
    apply sum_comm; auto.
Qed.
sum_abcd
Proof.
    intros.
    assert(Ar2 O E E' A B AB).
      apply sum_ar2;auto.
    assert(Ar2 O E E' C D CD).
      apply sum_ar2;auto.
    assert(Ar2 O E E' B C BC).
      apply sum_ar2;auto.
    assert(Ar2 O E E' A D AD).
      apply sum_ar2;auto.
    assert(Ar2 O E E' AB CD S).
      apply sum_ar2;auto.
    unfold Ar2 in *.
    spliter.
    clean_duplicated_hyps.
    assert(sum22 O E E' A B C D S).
      unfold sum22.
      exists AB.
      exists CD.
      split; auto.
    apply sum22_permut in H5.
    unfold sum22 in H5.
    ex_and H5 AD'.
    ex_and H6 BC'.
    assert(AD' = AD).
      apply sum_comm in H2; auto.
      apply (sum_uniqueness O E E' D A); auto.
    subst AD'.
    assert(BC' = BC).
      apply (sum_uniqueness O E E' B C); auto.
    subst BC'.
    apply sum_comm; auto.
Qed.
sum_diff_diff_a
Proof.
    intros.
    assert(Ar2 O E E' B A dBA).
      apply diff_ar2; auto.
    assert(Ar2 O E E' C B dCB).
      apply diff_ar2; auto.
    assert(Ar2 O E E' C A dCA).
      apply diff_ar2; auto.
    unfold Ar2 in *.
    spliter.
    clean_duplicated_hyps.
    unfold Diff in H.
    ex_and H mA.
    unfold Diff in H0.
    ex_and H0 mB.
    unfold Diff in H1.
    ex_and H1 mA'.
    assert(mA' = mA).
      apply (opp_uniqueness O E E' H2 A); auto.
    subst mA'.
    assert(HH:=sum_exists O E E' H2 dBA dCB H13 H10).
    ex_and HH Sd.
    assert(sum22 O E E' B mA C mB Sd).
      unfold sum22.
      exists dBA.
      exists dCB.
      split; auto.
    apply sum22_permut in H9.
    unfold sum22 in H9.
    ex_and H9 O'.
    ex_and H14 dCA'.
    assert(O' = O).
      apply (sum_uniqueness O E E' mB B); auto.
    subst O'.
    assert(dCA'=dCA).
      apply (sum_uniqueness O E E' C mA); auto.
      apply sum_comm; auto.
    subst dCA'.
    assert(dCA=Sd).
      apply (sum_O_B_eq O E E'); auto.
    subst Sd.
    apply sum_comm; auto.
Qed.
sum_diff_diff_b
Proof.
    intros.
    assert(Ar2 O E E' B A dBA).
      apply diff_ar2; auto.
    assert(Ar2 O E E' C B dCB).
      apply diff_ar2; auto.
    assert(Ar2 O E E' dCB dBA dCA).
      apply sum_ar2; auto.
    unfold Ar2 in *.
    spliter.
    clean_duplicated_hyps.
    unfold Diff in H.
    ex_and H mA.
    unfold Diff in H0.
    ex_and H0 mB.
    assert(sum22 O E E' B mA C mB dCA).
      unfold sum22.
      exists dBA.
      exists dCB.
      split; auto.
      split; auto.
      apply sum_comm; auto.
    apply sum22_permut in H5.
    unfold sum22 in H5.
    ex_and H5 O'.
    ex_and H6 dCA'.
    assert(O'=O).
      apply (sum_uniqueness O E E' mB B); auto.
    subst O'.
    assert(dCA' = dCA).
      apply(sum_O_B_eq O E E'); auto.
    subst dCA'.
    unfold Diff.
    exists mA.
    split; auto.
    apply sum_comm; auto.
Qed.
sum_diff2_diff_sum2_a
Proof.
    intros.
    assert(Ar2 O E E' A B C).
      apply sum_ar2; auto.
    assert(Ar2 O E E' X Y Z).
      apply sum_ar2; auto.
    assert(Ar2 O E E' dXA dYB dZC).
      apply sum_ar2; auto.
    unfold Ar2 in *.
    spliter.
    clean_duplicated_hyps.
    apply diff_sum in H1.
    apply diff_sum in H2.
    apply sum_diff.
    assert(HH:=sum_exists O E E' H4 C dZC H15 H9); auto.
    ex_and HH Z'.
    assert(sum22 O E E' A B dXA dYB Z').
      unfold sum22.
      exists C.
      exists dZC.
      auto.
    apply sum22_comm in H6.
    apply sum22_permut in H6.
    apply sum22_comm in H6.
    unfold sum22 in H6.
    ex_and H6 Y'.
    ex_and H16 X'.
    assert(X' = X).
      apply(sum_uniqueness O E E' A dXA); auto.
    subst X'.
    assert(Y'=Y).
      apply(sum_uniqueness O E E' B dYB); auto.
    subst Y'.
    assert( Z'= Z).
      apply(sum_uniqueness O E E' X Y); auto.
      apply sum_comm; auto.
    subst Z'.
    assumption.
Qed.
sum_diff2_diff_sum2_b
Proof.
    intros.
    assert(Ar2 O E E' A B C).
      apply sum_ar2; auto.
    assert(Ar2 O E E' X Y Z).
      apply sum_ar2; auto.
    assert(Ar2 O E E' X A dXA).
      apply diff_ar2; auto.
    assert(Ar2 O E E' Y B dYB).
      apply diff_ar2; auto.
    assert(Ar2 O E E' Z C dZC).
      apply diff_ar2; auto.
    unfold Ar2 in *.
    spliter.
    clean_duplicated_hyps.
    assert(HH:=sum_exists O E E' H4 dXA dYB H17 H14).
    ex_and HH dZC'.
    assert(HH:=sum_diff2_diff_sum2_a O E E' A B C X Y Z dXA dYB dZC' H H0 H1 H2 H5).
    assert( dZC' = dZC).
      apply(diff_uniqueness O E E' Z C); auto.
    subst dZC'.
    assumption.
Qed.
sum_opp
Proof.
intros O E E' X MX HSum.
apply diff_O_A_opp; apply sum_diff; auto.
Qed.
sum_diff_diff
Proof.
intros O E E' AX BX CX AXMBX AXMCX BXMCX HAXMBX HAXMCX HBXMCX.
assert (HNC : ~ Col O E E')
  by (unfold Diff, Sum, Ar2 in *; destruct HAXMBX; spliter; auto).
assert (HColAX : Col O E AX)
  by (unfold Diff, Sum, Ar2 in *; destruct HAXMBX; spliter; auto).
assert (HColBX : Col O E BX)
  by (unfold Diff, Sum, Ar2 in *; destruct HBXMCX; spliter; auto).
assert (HColCX : Col O E CX)
  by (unfold Diff, Opp, Sum, Ar2 in *; destruct HBXMCX; spliter; auto).
assert (HColAXMBX : Col O E AXMBX)
  by (unfold Diff, Sum, Ar2 in *; destruct HAXMBX; spliter; auto).
assert (HColAXMCX : Col O E AXMCX)
  by (unfold Diff, Sum, Ar2 in *; destruct HAXMCX; spliter; auto).
assert (HColBXMCX : Col O E BXMCX)
  by (unfold Diff, Sum, Ar2 in *; destruct HBXMCX; spliter; auto).
destruct (opp_exists O E E' HNC BX) as [MBX HMBX]; Col.
assert (HSum1 : Sum O E E' AX MBX AXMBX).
  {
  apply diff_sum in HAXMBX; apply sum_assoc_1 with AXMBX BX O;
  apply sum_comm; auto; apply sum_O_B; Col.
  }
destruct (opp_exists O E E' HNC CX) as [MCX HMCX]; Col.
assert (HSum2 : Sum O E E' BX MCX BXMCX).
  {
  apply diff_sum in HBXMCX; apply sum_assoc_1 with BXMCX CX O;
  apply sum_comm; auto; apply sum_O_B; Col.
  }
apply sum_assoc_1 with AX MBX MCX; auto.

  {
  apply sum_assoc_2 with BX MCX O; auto; apply sum_O_B; Col.
  unfold Opp, Sum, Ar2 in *; spliter; Col.
  }

  {
  apply diff_sum in HAXMCX; apply sum_assoc_1 with AXMCX CX O;
  apply sum_comm; auto; apply sum_O_B; Col.
  }
Qed.
prod_to_prodp
Proof.
    intros.
    unfold Prod in H.
    spliter.
    unfold Prodp.
    ex_and H0 B'.
    unfold Ar2 in H.
    spliter.
    assert(O <> E' /\ E <> E').
      split; intro; apply H; subst E'; Col.
    repeat split; try Col.
    exists B'.
    spliter.
    split.
      apply(pj_col_project B B' O E' E E'); Col.
      intro.
      induction H8.
        apply H8.
        exists E'.
        split; Col.
      apply H.
      tauto.
    apply(pj_col_project B' C O E A E'); Col.
      intro.
      subst E.
      apply H; Col.
      intro.
      subst E'.
      contradiction.
      intro.
      induction(eq_dec_points O A).
        subst A.
        induction H8.
          apply H8.
          exists O.
          split; Col.
        spliter.
        apply H.
        Col.
      induction H8.
        apply H8.
        exists A.
        split; Col.
      spliter.
      apply H.
      apply (col_transitivity_1 _ A); Col.
    unfold Pj in *.
    induction H2.
      left.
      apply par_left_comm.
      assumption.
    right; auto.
Qed.
project_pj
Proof.
    intros.
    unfold Proj in H.
    spliter.
    unfold Pj.
    induction H3.
      left.
      apply par_symmetry.
      auto.
    right.
    auto.
Qed.
prodp_to_prod
Proof.
    intros.
    unfold Prodp in H.
    spliter.
    ex_and H1 B'.
    unfold Prod.
    split.
      unfold Ar2.
      unfold Proj in *.
      spliter.
      repeat split; Col.
      intro.
      apply H8.
      right.
      repeat split; Col.
    exists B'.
    repeat split.
      eapply (project_pj _ _ O E'); auto.
      unfold Proj in H1.
      tauto.
    eapply (project_pj _ _ O E); auto.
    unfold Proj.
    unfold Proj in H2.
    spliter.
    repeat split; Col.
      intro.
      induction H7.
        apply H7.
        exists A.
        split; Col.
      spliter.
      apply H4.
      right.
      repeat split; Col.
    induction H6.
      left.
      apply par_right_comm.
      auto.
    right.
    auto; intro.
Qed.
prod_exists
Proof.
    intros.
    assert(NC:=grid_ok).
    assert(exists! B' : Tpoint, Proj B B' O E' E E').
      apply(project_existence B O E' E E').
        intro.
        subst E'.
        apply NC.
        Col.
        intro.
        subst E'.
        apply NC.
        Col.
      intro.
      induction H1.
        apply H1.
        exists E'.
        split; Col.
      spliter.
      apply NC.
      Col.
    ex_and H1 B'.
    unfold unique in H2.
    spliter.
    assert(exists! C, Proj B' C O E E' A).
      apply(project_existence B' O E E' A).
        intro.
        subst E'.
        apply NC.
        Col.
        intro.
        subst E.
        apply NC.
        Col.
      intro.
      induction H3.
        apply H3.
        exists A.
        split; Col.
      spliter.
      apply NC.
      Col.
    ex_and H3 C.
    unfold unique in H4.
    spliter.
    exists C.
    unfold Prod.
    repeat split; Col.
      unfold Proj in H3.
      tauto.
    exists B'.
    repeat split.
      apply (project_pj B B' O E').
      auto.
      unfold Proj in H1.
      tauto.
    apply (project_pj B' C O E).
    assumption.
Qed.
prod_uniqueness
Proof.
    intros.
    apply prod_to_prodp in H.
    apply prod_to_prodp in H0.
    unfold Prodp in *.
    spliter.
    ex_and H4 B'.
    ex_and H2 B''.
    assert(B'=B'').
      eapply (project_uniqueness B B' B'' O E' E E'); auto; unfold Prod in H.
    subst B''.
    eapply (project_uniqueness B' C1 C2 O E A E'); auto.
Qed.
prod_0_l
Proof.
    intros.
    unfold Prod.
    repeat split; Col.
    assert(HH:=(grid_not_par O E E' H)).
    spliter.
    induction(eq_dec_points A O).
      subst A.
      exists O.
      repeat split; try (apply pj_trivial).
      Col.
    assert(exists ! P' : Tpoint, Proj A P' O E' E E').
      apply(project_existence A O E' E E' H6 H5).
      intro.
      apply H3.
      Par.
    ex_and H8 B'.
    unfold unique in H9.
    spliter.
    clear H9.
    unfold Proj in H8.
    spliter.
    exists B'.
    repeat split.
      induction H12.
        left.
        Par.
      right.
      assumption.
      Col.
    left.
    right.
    repeat split; Col.
    intro.
    subst B'.
    induction H12.
      induction H12.
        apply H12.
        exists E.
        split; Col.
      spliter.
      contradiction.
    contradiction.
Qed.
prod_0_r
Proof.
    intros.
    unfold Prod.
    repeat split; Col.
    exists O.
    repeat split; try (apply pj_trivial).
    Col.
Qed.
prod_1_l
Proof.
    intros.
    unfold Prod.
    repeat split; Col.
    assert(HH:=(grid_not_par O E E' H)).
    spliter.
    assert(exists ! P' : Tpoint, Proj A P' O E' E E').
      apply(project_existence A O E' E E' H6 H5).
      intro.
      apply H3.
      Par.
    ex_and H7 B'.
    unfold unique in H8.
    spliter.
    clear H8.
    unfold Proj in H7.
    spliter.
    exists B'.
    induction H11.
      repeat split.
        left; Par.
        Col.
      left; Par.
    subst B'.
    repeat split; try(apply pj_trivial).
    Col.
Qed.
prod_1_r
Proof.
    intros.
    unfold Prod.
    repeat split; Col.
    exists E'.
    assert(HH:=(grid_not_par O E E' H)).
    spliter.
    repeat split.
      left.
      right.
      repeat split; Col.
      Col.
    left.
    assert(E' <> A).
      intro.
      subst A.
      contradiction.
    right.
    repeat split; Col.
Qed.
inv_exists
Proof.
    intros.
    unfold Prod.
    repeat split; Col.
    assert(HH:=(grid_not_par O E E' H)).
    spliter.
    assert(exists ! P' : Tpoint, Proj A P' O E' E E').
      apply(project_existence A O E' E E' H7 H6).
      intro.
      apply H4.
      Par.
    ex_and H8 B'.
    unfold unique in H9.
    spliter.
    clear H9.
    unfold Proj in H8.
    spliter.
    assert(B' <> O).
      intro.
      subst B'.
      induction H12.
        induction H12.
          apply H12.
          exists E.
          split; Col.
        spliter.
        contradiction.
      contradiction.
    assert(exists ! P' : Tpoint, Proj E' P' O E B' E).
      apply(project_existence E' O E B' E); auto.
        intro.
        subst B'.
        apply H.
        Col.
      intro.
      induction H14.
        apply H14.
        exists E.
        split; Col.
      spliter.
      apply H.
      ColR.
    ex_and H14 IA.
    unfold unique in H15.
    spliter.
    clear H15.
    unfold Proj in H14.
    spliter.
    exists IA.
    repeat split; Col.
    exists B'.
    assert(Par A B' E E').
      induction H12.
        Par.
      subst B'.
      apply False_ind.
      apply H16.
      right.
      repeat split; Col.
    clear H12.
    repeat split.
      left.
      Par.
      Col.
    induction H18.
      left.
      Par.
    subst IA.
    contradiction.
Qed.
prod_null
Proof.
    intros.
    unfold Prod in H.
    spliter.
    ex_and H0 B'.
    induction(eq_dec_points B O).
      right.
      assumption.
    left.
    unfold Ar2 in H.
    spliter.
    unfold Pj in *.
    induction H0; induction H2.
      induction H2.
        apply False_ind.
        apply H2.
        exists E'.
        split; Col.
      spliter.
      apply(l6_21 O E B' O); Col.
      intro.
      apply H.
      ColR.
      subst B'.
      induction H0.
        apply False_ind.
        apply H0.
        exists E.
        split; Col.
      spliter.
      apply False_ind.
      apply H3.
      apply (l6_21 O E E' O); Col.
      intro.
      subst E'.
      apply H.
      Col.
      subst B'.
      induction H2.
        apply False_ind.
        apply H0.
        exists A.
        split; Col.
        apply (col3 O E); Col.
        intro.
        subst E.
        apply H; Col.
      spliter.
      apply False_ind.
      apply H2.
      apply (l6_21 O E E' O); Col.
      intro.
      subst E'.
      apply H.
      Col.
    subst B'.
    contradiction.
Qed.
prod_y_axis_change
Proof.
    intros.
    assert(HP:=H).
    unfold Prod in H.
    spliter.
    unfold Ar2 in H.
    spliter.
    assert(HH:=grid_not_par O E E' H ).
    spliter.
    ex_and H1 B'.
    induction(eq_dec_points B O).
      subst B.
      assert(Prod O E E' A O O).
        apply(prod_0_r); Col.
      assert(HH:= prod_uniqueness O E E' A O C O HP H13).
      subst C.
      apply prod_0_r; Col.
    induction(eq_dec_points A O).
      subst A.
      assert(Prod O E E' O B O).
        apply(prod_0_l); Col.
      assert(HH:= prod_uniqueness O E E' O B O C H14 HP).
      subst C.
      apply(prod_0_l); Col.
    assert(C <> O).
      intro.
      subst C.
      apply prod_null in HP.
      induction HP; contradiction.
    assert(exists ! P' : Tpoint, Proj B P' O E'' E E'').
      apply(project_existence B O E'' E E'').
        intro.
        subst E''.
        apply H0; Col.
        intro.
        subst E''.
        apply H0; Col.
      intro.
      induction H16.
        apply H16.
        exists E''.
        split; Col.
      spliter.
      apply H0.
      Col.
    ex_and H16 B''.
    unfold unique in H17.
    spliter.
    clear H17.
    unfold Proj in H16.
    spliter.
    assert(Par B B'' E E'').
      induction H20.
        Par.
      subst B''.
      apply False_ind.
      apply H0.
      ColR.
    clear H20.
    repeat split; auto.
    exists B''.
    repeat split.
      left; Par.
      Col.
    assert(Par E' A B' C).
      induction H12.
        assumption.
      subst B'.
      apply False_ind.
      apply H.
      ColR.
    clear H12.
    induction(eq_dec_points B E).
      subst B.
      assert(B'' = E'').
        induction H21.
          apply False_ind.
          apply H12.
          exists E.
          split; Col.
        spliter.
        apply(l6_21 O E'' E E''); Col.
      subst B''.
      assert(C = A).
        assert(Prod O E E' A E A).
          apply(prod_1_r); Col.
        eapply (prod_uniqueness O E E' A E); auto.
      subst C.
      left.
      right.
      repeat split; Col.
        intro.
        subst E''.
        apply H18.
        right.
        repeat split; Col.
      intro.
      subst E''.
      apply H18.
      right.
      repeat split; Col.
    assert(Par_strict B B'' E E'').
      induction H21.
        assumption.
      spliter.
      apply False_ind.
      apply H0.
      ColR.
    assert(Par  E E' B B').
      induction H1.
        assumption.
      subst B'.
      apply False_ind.
      apply H.
      ColR.
    clear H1.
    assert(Par_strict E E' B B').
      induction H23.
        assumption.
      spliter.
      apply False_ind.
      apply H.
      ColR.
    assert(Par_strict E' A B' C).
      induction H20.
        assumption.
      spliter.
      apply False_ind.
      assert(B' <> E').
        intro.
        subst B'.
        apply H1.
        exists E'.
        split; Col.
      apply H.
      ColR.
    induction(eq_dec_points A E).
      subst A.
      assert(Prod O E E' E B B).
        apply prod_1_l; Col.
      assert(B = C).
        apply (prod_uniqueness O E E' E B); auto.
      subst C.
      left.
      Par.
    assert(B' <> O).
      intro.
      subst B'.
      apply H5.
      apply par_symmetry.
      apply(par_col_par _ _ _ B); Par.
      Col.
    induction(eq_dec_points E' E'').
      subst E''.
      assert(Par B B' B B'').
        apply (par_trans _ _ E E'); Par.
      induction H27.
        apply False_ind.
        apply H27.
        exists B.
        split; Col.
      spliter.
      assert(B' = B'').
        apply (l6_21 B B' O E'); Col.
        intro.
        apply H.
        ColR.
      subst B''.
      left.
      Par.
    induction(Col_dec E E' E'').
      assert(~Col E' E'' A).
        intro.
        apply H25.
        apply (l6_21 O E E' E''); Col.
      assert(B' <> B'').
        intro.
        subst B''.
        apply H27.
        apply(l6_21 O E' B B'); try ColR.
          intro.
          apply H.
          ColR.
        intro.
        subst B'.
        apply par_distinct in H21.
        tauto.
      assert(Par E' E'' B' B'').
        apply par_comm.
        apply (par_col_par _ _ _ B); Col.
          apply par_symmetry.
          apply (par_col_par _ _ _ E); Col.
          Par.
        assert(Par E E' E E'').
          right.
          repeat split; Col.
        assert(Par E E' B B'').
          apply (par_trans _ _ E E''); Par.
        assert(Par B B' B B'').
          apply (par_trans _ _ E E'); Par.
        induction H33.
          apply False_ind.
          apply H33.
          exists B.
          split; Col.
        spliter.
        Col.
      assert(B' <> E').
        intro.
        subst B'.
        apply H1.
        exists E'.
        split; Col.
      assert(Par_strict E' E'' B' B'').
        induction H31.
          assumption.
        spliter.
        apply False_ind.
        apply H31.
        apply(l6_21 O E' E E');Col.
        ColR.
      left.
      apply(l13_15 E' E'' A B' B'' C O H29 H33 H24); Col.
      ColR.
    assert(Par E'' E' B'' B').
      apply(l13_15 E E'' E' B B'' B' O ); Par.
      Col.
    induction(Col_dec A E' E'').
      assert(Par B' C E' E'').
        apply (par_col_par _ _ _ A); Par.
        Col.
      assert(Par B' C B' B'').
        apply (par_trans _ _ E' E''); Par.
      induction H32.
        apply False_ind.
        apply H32.
        exists B'.
        split; Col.
      spliter.
      left.
      apply par_comm.
      apply(par_col_par _ _ _ B'); Par.
        intro.
        subst B''.
        apply H22.
        exists E.
        split; ColR.
      apply par_symmetry.
      apply(par_col_par _ _ _ E'); Par.
      intro.
      subst E''.
      apply H22.
      exists B.
      split; ColR.
    assert(B' <> E').
      intro.
      subst B'.
      apply H24.
      exists E'.
      split; Col.
    assert(B'' <> E'').
      intro.
      subst B''.
      apply H22.
      exists E''.
      split; Col.
    induction H29.
      left.
      apply(l13_15 E' E'' A B' B'' C O ); Par.
        intro.
        apply H30.
        Col.
      ColR.
    spliter.
    induction(Col_dec O E' E'').
      left.
      apply par_comm.
      apply (l13_19 E E' A E'' B B' C B'' O); Col.
        intro.
        subst B''.
        apply H22.
        exists E.
        split; Col.
        ColR.
      left.
      Par.
    apply False_ind.
    apply H31.
    apply (l6_21 O E' E'' E'); Col.
    ColR.
Qed.
proj_preserves_prod
Proof.
    intros.
    assert(Ar2 O E E' A B C).
      unfold Prod in H.
      tauto.
    assert(AR2:= H4).
    destruct H4.
    spliter.
    unfold Ar1 in H0.
    spliter.
    induction(eq_dec_points A O).
      subst A.
      assert(A' = O).
        eapply (pj_uniqueness O E E' O); Col.
        apply pj_trivial.
      subst A'.
      assert(C = O).
        assert(HH:= prod_0_l O E E' B H4 H6).
        apply(prod_uniqueness O E E' O B); auto.
      subst C.
      induction H3.
        apply False_ind.
        induction H3.
          apply H3.
          exists E'.
          spliter.
          split; Col.
        spliter.
        apply H4.
        ColR.
      subst C'.
      apply prod_0_l; Col.
    induction(eq_dec_points B O).
      subst B.
      assert(B' = O).
        apply (pj_uniqueness O E E' O); Col.
        apply pj_trivial.
      subst B'.
      assert(C = O).
        assert(HH:= prod_0_r O E E' A H4 H5).
        apply(prod_uniqueness O E E' A O); auto.
      subst C.
      induction H3.
        apply False_ind.
        induction H3.
          apply H3.
          exists E'.
          spliter.
          split; Col.
        spliter.
        apply H4.
        ColR.
      subst C'.
      apply prod_0_r; Col.
    induction(eq_dec_points C O).
      subst C.
      apply prod_null in H.
      induction H; contradiction.
    induction(eq_dec_points A' O).
      subst A'.
      apply False_ind.
      induction H1.
        induction H1.
          apply H1.
          exists E.
          split; Col.
        spliter.
        apply H4.
        ColR.
      contradiction.
    induction(eq_dec_points B' O).
      subst B'.
      apply False_ind.
      induction H2.
        induction H2.
          apply H2.
          exists E.
          split; Col.
        spliter.
        apply H4.
        ColR.
      contradiction.
    induction(eq_dec_points C' O).
      subst C'.
      apply False_ind.
      induction H3.
        induction H3.
          apply H3.
          exists E.
          split; Col.
        spliter.
        apply H4.
        ColR.
      contradiction.
    unfold Ar1 in H0.
    spliter.
    unfold Prod in *.
    spliter.
    unfold Ar2 in H.
    spliter.
    repeat split; Col.
    ex_and H17 B''.
    assert(B' = B'').
      apply(pj_uniqueness O  E E' B B' B''); Col.
    subst B''.
    exists B.
    repeat split; Col.
      apply pj_comm.
      assumption.
    left.
    apply par_comm.
    assert(HH:= grid_not_par O E E' H4).
    spliter.
    apply(l13_19 E' A A' E B' C C' B O); Col.
      intro.
      apply H4.
      ColR.
      ColR.
      ColR.
      induction H22.
        assumption.
      subst B'.
      apply False_ind.
      apply H4.
      ColR.
      induction H2.
        Par.
      subst B'.
      apply False_ind.
      apply H4.
      ColR.
    induction H1.
      induction H3.
        apply (par_trans _ _ E E'); Par.
      subst C'.
      apply False_ind.
      apply H4.
      ColR.
    subst A'.
    apply False_ind.
    apply H4.
    ColR.
Qed.
prod_assoc1
Proof.
    intros.
    assert(Ar2 O E E' A B AB).
      unfold Prod in H.
      tauto.
    assert(Ar2 O E E' B C BC).
      unfold Prod in H0.
      tauto.
    assert(Ar2 O E E' A BC ABC).
      unfold Prod in H1.
      tauto.
    unfold Ar2 in *.
    spliter.
    clean_duplicated_hyps.
    induction(eq_dec_points A O).
      subst A.
      assert(HH:=prod_0_l O E E' B H2 H12).
      assert(AB = O).
        apply(prod_uniqueness O E E' O B); assumption.
      subst AB.
      assert(HP:=prod_0_l O E E' BC H2 H10).
      assert(ABC=O).
        apply(prod_uniqueness O E E' O BC); assumption.
      subst ABC.
      apply prod_0_l; assumption.
    induction(eq_dec_points B  O).
      subst B.
      assert(HH:=prod_0_r O E E' A H2  H11).
      assert(AB = O).
        apply(prod_uniqueness O E E' A O); assumption.
      subst AB.
      assert(HP:=prod_0_l O E E' C H2 H9).
      assert(BC=O).
        apply(prod_uniqueness O E E' O C); assumption.
      subst BC.
      assert(ABC=O).
        apply(prod_uniqueness O E E' A O); assumption.
      subst ABC.
      apply prod_0_l; assumption.
    induction(eq_dec_points C O).
      subst C.
      assert(HH:=prod_0_r O E E' B H2  H12).
      assert(BC = O).
        apply(prod_uniqueness O E E' B O); assumption.
      subst BC.
      assert(HP:=prod_0_r O E E' A H2 H11).
      assert(ABC=O).
        apply(prod_uniqueness O E E' A O); assumption.
      subst ABC.
      apply prod_0_r; assumption.
    assert(P1:=H).
    assert(P2:= H0).
    assert(P3:=H1).
    unfold Prod in H.
    unfold Prod in H0.
    unfold Prod in H1.
    spliter.
    repeat split; auto.
    assert(HH:=grid_not_par O E E' H2).
    spliter.
    assert(exists ! P', Proj C P' O E' E E').
      apply(project_existence C O E' E E' H20 H19); Par.
    ex_and H21 C'.
    unfold unique in H22.
    spliter.
    clear H22.
    unfold Proj in H21.
    spliter.
    clean_duplicated_hyps.
    assert(Par C C' E E').
      induction H25.
        assumption.
      subst C'.
      apply False_ind.
      apply H2.
      ColR.
    clear H25.
    exists C'.
    repeat split.
      left.
      Par.
      Col.
    ex_and H14 B'.
    ex_and H8 C''.
    assert(C' = C'').
      apply(pj_uniqueness O E E' C); Col.
      left.
      Par.
    subst C''.
    ex_and H6 BC'.
    assert(B' <> O).
      intro.
      subst B'.
      induction H14.
        apply H15.
        apply par_symmetry.
        apply(par_col_par _ _ _ B); finish.
      contradiction.
    assert(BC <> O).
      intro.
      subst BC.
      assert(HH:=prod_null O E E' B C P2).
      induction HH; contradiction.
    left.
    apply(l13_19 B' B E' AB BC' BC C' ABC O); Col.
      intro.
      apply H2.
      ColR.
      intro.
      subst BC'.
      induction H6.
        apply H15.
        apply par_symmetry.
        apply (par_col_par _ _ _ BC); finish.
      contradiction.
      intro.
      subst C'.
      apply H15.
      apply par_symmetry.
      apply (par_col_par _ _ _ C); finish.
      intro.
      subst AB.
      assert(HH:=prod_null O E E' A B P1).
      induction HH; contradiction.
      intro.
      subst ABC.
      assert(HH:=prod_null O E E' A BC P3).
      induction HH; contradiction.
      ColR.
      ColR.
      ColR.
      ColR.
      ColR.
      induction H14.
        induction H6.
          apply (par_trans _ _ E E'); Par.
        subst BC'.
        apply False_ind.
        apply H2.
        ColR.
      subst B'.
      apply False_ind.
      apply H2.
      ColR.
      induction H23.
        induction H28.
          apply (par_trans _ _ E' A); Par.
        subst BC'.
        apply False_ind.
        apply H2.
        assert(ABC <> O).
          intro.
          subst ABC.
          assert(HH:=prod_null O E E' A BC P3).
          induction HH; contradiction.
        ColR.
      subst AB.
      apply False_ind.
      apply H2.
      ColR.
    induction H26.
      Par.
    subst BC.
    apply False_ind.
    apply H2.
    ColR.
Qed.
prod_assoc2
Proof.
    intros.
    assert(Ar2 O E E' A B AB).
      unfold Prod in H.
      tauto.
    assert(Ar2 O E E' B C BC).
      unfold Prod in H0.
      tauto.
    assert(Ar2 O E E' AB C ABC).
      unfold Prod in H1.
      tauto.
    unfold Ar2 in *.
    spliter.
    clean_duplicated_hyps.
    induction(eq_dec_points A O).
      subst A.
      assert(HH:=prod_0_l O E E' B H2 H12).
      assert(AB = O).
        apply(prod_uniqueness O E E' O B); assumption.
      subst AB.
      assert(HP:=prod_0_l O E E' C H2 H9).
      assert(ABC=O).
        apply(prod_uniqueness O E E' O C); assumption.
      subst ABC.
      apply prod_0_l; assumption.
    induction(eq_dec_points B  O).
      subst B.
      assert(HH:=prod_0_l O E E' C H2  H9).
      assert(BC = O).
        apply(prod_uniqueness O E E' O C); assumption.
      subst BC.
      assert(HP:=prod_0_r O E E' A H2 H11).
      assert(AB=O).
        apply(prod_uniqueness O E E' A O); assumption.
      subst AB.
      assert(ABC=O).
        apply(prod_uniqueness O E E' O C); assumption.
      subst ABC.
      apply prod_0_r; assumption.
    induction(eq_dec_points C O).
      subst C.
      assert(HH:=prod_0_r O E E' B H2  H12).
      assert(ABC=O).
        assert(HP:=prod_0_r O E E' AB H2  H13).
        apply(prod_uniqueness O E E' AB O); assumption.
      subst ABC.
      assert(BC=O).
        apply(prod_uniqueness O E E' B O); assumption.
      subst BC.
      apply prod_0_r; assumption.
    assert(P1:=H).
    assert(P2:= H0).
    assert(P3:=H1).
    unfold Prod in H.
    unfold Prod in H0.
    unfold Prod in H1.
    spliter.
    repeat split; auto.
    assert(HH:=grid_not_par O E E' H2).
    spliter.
    assert(BC <> O).
      intro.
      subst BC.
      apply prod_null in P2.
      induction P2; contradiction.
    assert(exists ! P', Proj BC P' O E' E E').
      apply(project_existence BC O E' E E' H20 H19); Par.
    ex_and H22 BC'.
    unfold unique in H23.
    spliter.
    clear H23.
    unfold Proj in H22.
    spliter.
    clean_duplicated_hyps.
    assert(Par BC BC' E E').
      induction H26.
        assumption.
      subst BC'.
      apply False_ind.
      apply H2.
      ColR.
    clear H26.
    exists BC'.
    repeat split.
      left.
      Par.
      Col.
    ex_and H14 B'.
    ex_and H8 C'.
    ex_and H6 C''.
    assert(C' = C'').
      apply(pj_uniqueness O E E' C); Col.
    left.
    Par.
    subst C''.
    assert(B' <> O).
      intro.
      subst B'.
      induction H14.
        apply H15.
        apply par_symmetry.
        apply(par_col_par _ _ _ B); finish.
      contradiction.
    apply(par_trans _ _ B' AB).
      induction H24.
        Par.
      subst B'.
      apply False_ind.
      apply H2.
      ColR.
    apply(l13_19 E' B  B' AB C' BC BC' ABC O); auto.
      intro.
      apply H2.
      ColR.
      intro.
      subst C'.
      apply H15.
      apply par_symmetry.
      induction H6.
        apply(par_col_par _ _ _ C); Par.
        Col.
      contradiction.
      intro.
      subst BC'.
      apply H15.
      apply par_symmetry.
      apply(par_col_par _ _ _ BC); Par.
      Col.
      intro.
      subst AB.
      apply prod_null in P1.
      induction P1; contradiction.
      intro.
      subst ABC.
      apply prod_null in P3.
      induction P3.
        subst AB.
        apply prod_null in P1.
        induction P1; contradiction.
      contradiction.
      ColR.
      ColR.
      ColR.
      induction H27.
        Par.
      subst C'.
      apply False_ind.
      apply H15.
      apply par_symmetry.
      apply(par_col_par _ _ _ C); auto.
        apply par_comm.
        apply(par_col_par _ _ _ BC); auto.
          induction H6.
            Par.
          subst BC.
          apply False_ind.
          apply H2.
          ColR.
        ColR.
      Col.
      induction  H29.
        Par.
      subst C'.
      apply False_ind.
      apply H2.
      assert(ABC <> O).
        intro.
        subst ABC.
        apply H15.
        apply par_symmetry.
        apply(par_col_par _ _ _ C); auto.
          induction H6.
            Par.
          contradiction.
        ColR.
      ColR.
    induction H14.
      apply (par_trans _ _ E E'); Par.
    subst B'.
    apply False_ind.
    apply H2.
    ColR.
Qed.
prod_assoc
Proof.
    intros.
    split.
      intro.
      apply (prod_assoc1 O E E' A B  _ _ BC); auto.
    intro.
    eapply (prod_assoc2 O E E' A B C AB  ); auto.
Qed.
prod_comm
Proof.
    intros.
    assert(Ar2 O E E' A B C).
      unfold Prod in H.
      tauto.
    unfold Ar2 in H0.
    spliter.
    induction(eq_dec_points A O).
      subst A.
      assert(HH:=prod_0_l O E E' B H0 H2).
      assert(C = O).
        apply(prod_uniqueness O E E' O B); auto.
      subst C.
      eapply (prod_0_r O E E'); Col.
    induction(eq_dec_points B O).
      subst B.
      assert(HH:=prod_0_r O E E' A H0 H1).
      assert(C = O).
        apply(prod_uniqueness O E E' A O); auto.
      subst C.
      apply (prod_0_l O E E'); Col.
    induction(eq_dec_points C O).
      subst C.
      apply prod_null in H.
      induction H;  contradiction.
    unfold Prod in *.
    repeat split; auto.
    spliter.
    ex_and H7 B'.
    assert(HG:=grid_not_par O E E' H0).
    spliter.
    assert(exists ! P' : Tpoint, Proj A P' O E' E E').
      apply(project_existence A O E' E E'); Col.
      intro.
      apply H12.
      Par.
    ex_and H16 A'.
    unfold unique in H17.
    spliter.
    clear H17.
    unfold Proj in H16.
    spliter.
    clean_duplicated_hyps.
    assert(Par A A' E E').
      induction H20.
        Par.
      subst A'.
      apply False_ind.
      apply H0.
      ColR.
    clear H20.
    exists A'.
    repeat split.
      left.
      Par.
      Col.
    left.
    apply par_comm.
    apply par_symmetry.
    apply (l13_11 C B A E' A' B' O); Col.
      intro.
      apply H0.
      ColR.
      ColR.
      ColR.
      intro.
      subst A'.
      apply H10.
      apply par_symmetry.
      apply(par_col_par _ _ _ A); finish.
      induction H7.
        intro.
        subst B'.
        apply H10.
        apply par_symmetry.
        apply(par_col_par _ _ _ B); finish.
      subst B'.
      intro.
      contradiction.
      ColR.
      induction H7.
        apply(par_trans _ _ E E'); Par.
      subst B'.
      apply False_ind.
      apply H0.
      ColR.
    induction H9.
      Par.
    subst B'.
    apply False_ind.
    apply H0.
    ColR.
Qed.
prod_O_l_eq
Proof.
    intros.
    assert(HH:=H).
    unfold Prod in HH.
    spliter.
    unfold Ar2 in H0.
    spliter.
    assert(HH:=prod_0_l O E E' B H0 H3).
    apply (prod_uniqueness O E E' O B); auto.
Qed.
prod_O_r_eq
Proof.
    intros.
    assert(HH:=H).
    unfold Prod in HH.
    spliter.
    unfold Ar2 in H0.
    spliter.
    assert(HH:=prod_0_r O E E' A H0 H2).
    apply (prod_uniqueness O E E' A O); auto.
Qed.
prod_uniquenessA
Proof.
    intros.
    assert(HP1:= H0).
    assert(HP2:= H1).
    unfold Prod in H0.
    unfold Prod in H1.
    spliter.
    unfold Ar2 in *.
    spliter.
    clean_duplicated_hyps.
    induction(eq_dec_points A' O).
      subst A'.
      assert(C = O).
        assert(HH:= prod_0_l O E E' B H0 H8).
        apply(prod_uniqueness O E E' O B); auto.
      subst C.
      apply prod_null in HP1.
      induction HP1.
        assumption.
      contradiction.
    ex_and H3 B'.
    ex_and H2 B''.
    assert(B' = B'').
      induction H3; induction H2.
        assert(Par B B' B B'').
          apply (par_trans _ _ E E'); Par.
        induction H12.
          apply False_ind.
          apply H12.
          exists B.
          split; Col.
        spliter.
        apply(l6_21 O E' B B'); Col.
        intro.
        apply H0.
        ColR.
        subst B''.
        apply False_ind.
        apply H0.
        ColR.
        subst B'.
        apply False_ind.
        apply H0.
        ColR.
      subst B.
      assumption.
    subst B''.
    assert(HH:= grid_not_par O E E' H0).
    spliter.
    induction H6; induction H11.
      assert(Par E' A' E' A).
        apply(par_trans _ _ B' C); Par.
      induction H18.
        apply False_ind.
        apply H18.
        exists E'.
        split; Col.
      spliter.
      apply(l6_21 O E E' A); Col.
      subst B'.
      apply par_distincts in H6.
      tauto.
      subst B'.
      apply par_distincts in H11.
      tauto.
    subst B'.
    induction(eq_dec_points C O).
      subst C.
      apply prod_null in HP1.
      apply prod_null in HP2.
      induction HP1; induction HP2; try contradiction.
    apply False_ind.
    apply H0.
    ColR.
Qed.
prod_uniquenessB
Proof.
    intros.
    apply prod_comm in H0.
    apply prod_comm in H1.
    apply (prod_uniquenessA O E E' B B' A C); auto.
Qed.
distr_l
Proof.
    intros.
    assert(HS:=H).
    unfold Sum in H.
    spliter.
    ex_and H3 B'.
    ex_and H4 C1.
    assert(HP1:=H0).
    assert(HP2:=H1).
    assert(HPS:=H2).
    unfold Prod in H0.
    spliter.
    ex_and H8 B''.
    assert(~Col O E E' /\ Col O E A /\ Col O E B /\ Col O E C /\ Col O E D).
      unfold Ar2 in *.
      spliter.
      repeat split; Col.
    spliter.
    assert(HH:=grid_not_par O E E' H11).
    spliter.
    assert(B' = B'').
      apply(pj_uniqueness O E E' B); Col.
    subst B''.
    unfold Prod in H1.
    spliter.
    ex_and H22 C'.
    unfold Prod in H2.
    spliter.
    ex_and H25 D'.
    assert(Sum O E' E B' C' D').
      apply(proj_preserves_sum O E E' B C D B' C' D'); auto.
      repeat split; Col.
    (* case A = O) *)
    induction(eq_dec_points A O).
      subst A.
      assert(HH1:= prod_0_l O E E' B H11 H13).
      assert( AB = O).
        apply (prod_uniqueness O E E' O B); auto.
      subst AB.
      assert(HH2:= prod_0_l O E E' C H11 H14).
      assert( AC = O).
        apply (prod_uniqueness O E E' O C); auto.
      subst AC.
      assert(HH3:= prod_0_l O E E' D H11 H15).
      assert( AD = O).
        apply (prod_uniqueness O E E' O D); auto.
      subst AD.
      apply sum_O_O; Col.
    assert(Sum O E' A B' C' D').
      apply(sum_y_axis_change O E' E A B' C' D'); auto.
      intro.
      apply H11.
      ColR.
    assert(Sum O A E' AB AC AD).
      unfold Ar2 in *.
      spliter.
      apply(proj_preserves_sum O E' A B' C' D' AB AC AD); auto.
      repeat split; auto.
        ColR.
        ColR.
      ColR.
    apply(sum_x_axis_unit_change O A E' E AB AC AD); Col.
Qed.
distr_r
Proof.
    intros.
    apply prod_comm in H0.
    apply prod_comm in H1.
    apply prod_comm in H2.
    apply(distr_l O E E' C A B  D AC BC DC); auto.
Qed.
prod_1_l_eq
Proof.
    intros.
    assert(HP:=H).
    unfold Prod in H.
    spliter.
    unfold Ar2 in H.
    spliter.
    clear H0.
    assert(HH:= prod_1_l O E E' B H H2).
    induction(eq_dec_points B O).
      right; assumption.
    left.
    apply (prod_uniquenessA O E E' A E B B H0); assumption.
Qed.
prod_1_r_eq
Proof.
    intros.
    apply prod_comm in H.
    apply (prod_1_l_eq O E E').
    assumption.
Qed.
change_grid_prod_l_O
Proof.
    intros.
    assert(HP:= H6).
    unfold Prod in H6.
    spliter.
    unfold Ar2 in H6.
    clear H7.
    spliter.
    assert(C = O).
      apply prod_O_l_eq in HP.
      assumption.
    subst C.
    assert(Par O O' O A').
      induction H3.
        Par.
      subst A'.
      unfold Ar1 in H1.
      spliter.
      apply False_ind.
      apply H.
      exists O.
      split; Col.
    induction H10.
      apply False_ind.
      apply H10.
      exists O.
      split; Col.
    spliter.
    assert(A' = O').
      apply (l6_21 O O' E' O'); Col.
        intro.
        apply H.
        exists O.
        split; Col.
        unfold Ar1 in H1.
        spliter.
        auto.
      unfold Ar1 in H1.
      spliter.
      Col.
    subst A'.
    clean_trivial_hyps.
    assert(Par O O' O C').
      induction H5.
        Par.
      subst C'.
      apply False_ind.
      unfold Ar1 in H1.
      spliter.
      apply H.
      exists O.
      split; Col.
    induction H7.
      apply False_ind.
      apply H7.
      exists O.
      split; Col.
    spliter.
    assert(C' = O').
      apply (l6_21 O O' E' O'); Col.
        intro.
        apply H.
        exists O.
        split; Col.
        unfold Ar1 in H1.
        spliter.
        auto.
      unfold Ar1 in H1.
      spliter.
      Col.
    subst C'.
    apply(prod_0_l).
      intro.
      apply H.
      exists E.
      split; Col.
    unfold Ar1 in H1.
    spliter.
    Col.
Qed.
change_grid_prod1
Proof.
    intros.
    induction (eq_dec_points B O).
      subst B.
      apply prod_comm.
      unfold Ar1 in *.
      spliter.
      apply(change_grid_prod_l_O O E E' E C O' B' A' C'); auto.
        repeat split; Col.
        repeat split; Col.
      apply prod_comm.
      assumption.
    induction(eq_dec_points C O).
      subst C.
      apply prod_null in H6.
      induction H6.
        subst E.
        apply par_strict_distinct in H.
        tauto.
      subst B.
      tauto.
    assert(HP:= H6).
    unfold Prod in H6.
    spliter.
    unfold Ar2 in H6.
    spliter.
    clear H9.
    unfold Ar1 in H1.
    spliter.
    assert(HH:=prod_1_l O E E' B H6 H11).
    assert(B = C).
      apply (prod_uniqueness O E E' E B); auto.
    subst C.
    assert(A' = E').
      apply(l6_21 E E' O' E'); Col.
        intro.
        apply H.
        exists E.
        split; Col.
      induction H2; induction H3.
        assert(Par E A' E E').
          apply(par_trans _ _ O O'); Par.
        induction H15.
          apply False_ind.
          apply H15.
          exists E.
          split; Col.
        spliter.
        Col.
        subst A'.
        Col.
        subst E'.
        Col.
      subst A'.
      Col.
    subst A'.
    assert(C' = B').
      apply(l6_21 B' B O' E'); Col.
        intro.
        apply H.
        exists B.
        split; Col.
        assert(B' <> O').
          intro.
          subst B'.
          induction H4.
            induction H4.
              apply H4.
              exists O'.
              split; Col.
            spliter.
            apply H.
            exists O'.
            split; Col.
            ColR.
          subst B.
          apply H.
          exists O'.
          split; Col.
        ColR.
      induction H4; induction H5.
        assert(Par B C' B B').
          apply(par_trans _ _ O O'); Par.
        induction H15.
          apply False_ind.
          apply H15.
          exists B.
          split; Col.
        spliter.
        Col.
        subst C'.
        Col.
        subst B'.
        Col.
      subst C'.
      Col.
    subst C'.
    apply (prod_1_l O' E' E); Col.
    intro.
    apply H.
    exists E.
    split; Col.
Qed.
change_grid_prod
Proof.
    intros.
    induction (eq_dec_points A O).
      subst A.
      apply(change_grid_prod_l_O O E E' B C O' A' B' C'); auto.
    induction (eq_dec_points B O).
      subst B.
      apply prod_comm.
      unfold Ar1 in *.
      spliter.
      apply(change_grid_prod_l_O O E E' A C O' B' A' C'); auto.
        repeat split; Col.
        repeat split; Col.
      apply prod_comm.
      assumption.
    induction(eq_dec_points C O).
      subst C.
      apply prod_null in H6.
      induction H6;contradiction.
    induction(eq_dec_points A E).
      subst A.
      apply (change_grid_prod1 O E E' B C); auto.
    rename H10 into ANE.
    assert(HP:=H6).
    unfold Prod in H6.
    spliter.
    clear H10.
    unfold Ar1 in *.
    unfold Ar2 in H6.
    spliter.
    clean_duplicated_hyps.
    prolong O O' E'' O O'.
    assert(E''<> O).
      intro.
      subst E''.
      apply between_identity in H10.
      subst O'.
      apply H.
      exists O.
      split; Col.
    assert(~Col O E E'').
      intro.
      apply H.
      exists O'.
      apply bet_col in H10.
      split; Col.
      ColR.
    assert(HH:= prod_y_axis_change O E E' E'' A B C  HP H19).
    assert(HP1:= HH).
    unfold Prod in HH.
    spliter.
    ex_and H21 B''.
    assert(~Col O E'' E).
      intro.
      apply H19.
      Col.
    assert(exists C : Tpoint, Sum O E'' E E'' O' C).
      apply(sum_exists O E'' E H24 E'' O'); Col.
    ex_and H25 C2.
    assert(~ Col O E'' A).
      intro.
      apply H24.
      ColR.
    assert(HH:= sum_y_axis_change O E'' E A  E'' O' C2 H26 H25).
    assert(HS1:= HH).
    unfold Sum in HH.
    spliter.
    unfold Ar2 in H27.
    spliter.
    clear H27.
    ex_and H28 A0.
    ex_and H27 A0'.
    assert(A = A0).
      apply(l6_21 O E E'' A); Col.
        intro.
        subst A.
        apply H25.
        Col.
        ColR.
        induction H27.
          induction H27.
            apply False_ind.
            apply H27.
            exists E''.
            split; Col.
          spliter.
          Col.
        subst A0.
        Col.
    subst A0.
    assert(Par O O' E E').
      induction H2.
        Par.
      subst E'.
      apply False_ind.
      apply H6.
      Col.
    assert(Par O O' A A').
      induction H3.
        Par.
      subst A'.
      apply False_ind.
      apply H.
      exists A.
      split; Col.
    assert(Par O O' B B').
      induction H4.
        Par.
      subst B'.
      apply False_ind.
      apply H.
      exists B.
      split; Col.
    assert(Par O O' C C').
      induction H5.
        Par.
      subst C'.
      apply False_ind.
      apply H.
      exists C.
      split; Col.
    assert(O <> O').
      intro.
      subst O'.
      apply par_distinct in H35.
      tauto.
    clear H2 H3 H4 H5.
    assert(A0'=A').
      apply (l6_21 O' E' A A'); Col.
        intro.
        apply H.
        exists A.
        split; Col.
        intro.
        subst A'.
        apply par_distinct in H36.
        tauto.
        induction H33.
          assert(Par O' E' O' A0').
            apply(par_trans _ _ O A); Par.
            apply(par_col_par _ _ _ E); Col.
            left.
            Par.
          induction H3.
            apply False_ind.
            apply H3.
            exists O'.
            split; Col.
          spliter.
          Col.
        subst A0'.
        Col.
        induction H32.
          assert(Par A A' A A0').
            apply(par_trans _ _ O O'); Par.
            apply par_symmetry.
            apply(par_col_par _ _ _ E''); Col.
            Par.
          induction H3.
            apply False_ind.
            apply H3.
            exists A.
            split; Col.
          spliter.
          Col.
        subst A0'.
        Col.
    subst A0'.
    assert(Par O E'' A A').
      induction H32.
        Par.
      subst A'.
      apply par_distinct in H36.
      tauto.
    assert(Par O A O' A').
      induction H33.
        Par.
      subst A'.
      apply False_ind.
      induction H2.
        apply H2.
        exists O'.
        split; Col.
      spliter.
      apply H.
      exists O'.
      split; Col.
      ColR.
    assert(Par A E'' A' C2).
      induction H34.
        Par.
      subst C2.
      apply False_ind.
      induction H2.
        apply H2.
        exists A'.
        split; Col.
      spliter.
      apply H.
      exists A'.
      split; Col.
      ColR.
    clear H33 H34 H32.
    assert(HS0:= H26).
    induction H26.
    unfold Ar2 in H5.
    spliter.
    clean_duplicated_hyps.
    ex_and H26 E0.
    ex_and H5 E0'.
    assert(E0 = E).
      apply (l6_21 E'' E O E); Col.
      induction H5.
        induction H5.
          apply False_ind.
          apply H5.
          exists E''.
          split; Col.
        spliter.
        Col.
      subst E0.
      Col.
    subst E0.
    assert(E0' = E').
      apply(l6_21 O' E' E E'); Col.
        intro.
        apply H.
        exists E.
        split; Col.
        intro.
        subst E'.
        apply H6.
        Col.
        induction H30.
          assert(Par O' E' O' E0').
            apply(par_trans _ _ O E); Par.
          induction H40.
            apply False_ind.
            apply H40.
            exists O'.
            split; Col.
          spliter.
          Col.
        subst E0'.
        Col.
        induction H29.
          assert(Par E E' E E0').
            apply(par_trans _ _ O E''); Par.
            apply (par_col_par _ _ _ O'); Col.
            Par.
          induction H40.
            apply False_ind.
            apply H40.
            exists E.
            split; Col.
          spliter.
          Col.
        subst E0'.
        Col.
    subst E0'.
    clean_trivial_hyps.
    clean_duplicated_hyps.
    assert(Par E E'' E' C2).
      induction H31.
        Par.
      subst C2.
      apply False_ind.
      assert(Col O O' E').
        ColR.
      apply H.
      exists O.
      split; Col.
    clear H31.
    clear H5.
    clear H30.
    clear H29.
    assert(Par E E'' B B'').
      induction H21.
        Par.
      subst B''.
      apply False_ind.
      apply H19.
      ColR.
    clear H21.
    assert(exists C : Tpoint, Sum O E'' E B'' O' C).
      apply(sum_exists O E'' E H24 B'' O'); Col.
    ex_and H21 C3.
    assert(HS2:= H28).
    induction H28.
    ex_and H28 B0.
    ex_and H29 B0'.
    assert(B'' <> O).
      intro.
      subst B''.
      induction H5.
        apply H5.
        exists E.
        split; Col.
      spliter.
      apply H19.
      ColR.
    assert(B0 = B).
      apply (l6_21 O E B'' B); Col.
        intro.
        apply H24.
        ColR.
        intro.
        subst B''.
        apply par_distinct in H5.
        tauto.
        induction H28.
          assert(Par B'' B0 B B'').
            apply(par_trans _ _ E E''); Par.
          induction H41.
            apply False_ind.
            apply H41.
            exists B''.
            split; Col.
          spliter.
          Col.
        subst B0.
        Col.
    subst B0.
    assert(B0' = B').
      apply (l6_21 O' E' B B'); Col.
        intro.
        apply H.
        exists B.
        split; Col.
        intro.
        subst B'.
        apply par_distinct in H37.
        tauto.
        induction H31.
          assert(Par O' E' O' B0').
            apply(par_trans _ _ O E); Par.
          induction H41.
            apply False_ind.
            apply H41.
            exists O'.
            split; Col.
          spliter.
          Col.
        subst B0'.
        Col.
        induction H30.
          assert(Par B B' B B0').
            apply(par_trans _ _ O E''); Par.
            apply (par_col_par _ _ _ O'); Col.
            Par.
          induction H41.
            apply False_ind.
            apply H41.
            exists B.
            split; Col.
          spliter.
          Col.
        subst B0'.
        Col.

    subst B0'.
    unfold Ar2 in H21.
    spliter.
    clean_duplicated_hyps.
    assert(E'' <> O).
      intro.
      subst E''.
      apply H25.
      Col.
    assert(B' <> O').
      intro.
      subst B'.
      induction H37.
        apply H29.
        exists O'.
        split; Col.
      spliter.
      apply H.
      exists O'.
      split; Col.
      ColR.
    assert(Par E E'' B' C3).
      induction H32.
        Par.
      subst C3.
      apply False_ind.
      assert(Col O O' B').
        ColR.
      apply H.
      exists O.
      split; Col.
      ColR.
    clear H32.
    assert(Par E'' E B'' B).
      induction H28.
        Par.
      subst B''.
      apply par_distinct in H5.
      tauto.
    clear H28.
    assert(HH:= sum_y_axis_change O E'' E A  B'' O' C3 HS2 H25).
    assert(HS3 := HH).
    unfold Sum in HH.
    spliter.
    unfold Ar2 in H28.
    spliter.
    clean_duplicated_hyps.
    ex_and H42 C0.
    ex_and H21 C0'.
    assert(Par E'' A B'' C).
      induction H23.
        Par.
      subst B''.
      apply False_ind.
      induction H32.
        apply H23.
        exists E.
        split; Col.
        ColR.
      spliter.
      apply H19.
      ColR.
    clear H23.
    assert(C0 = C).
      apply (l6_21 O E B'' C); Col.
        intro.
        apply H19.
        ColR.
        intro.
        subst B''.
        apply par_distinct in H46.
        tauto.
        ColR.
        induction H21.
          assert(Par B'' C B'' C0).
            apply(par_trans _ _ E'' A); Par.
          induction H23.
            apply False_ind.
            apply H23.
            exists B''.
            split; Col.
          spliter.
          Col.
        subst C0.
        Col.
    subst C0.
    assert(C0' = C').
      apply (l6_21 O' E' C C'); Col.
        intro.
        apply H.
        exists C.
        split; Col.
        intro.
        subst C'.
        apply par_distincts in H38.
        tauto.
        induction H44.
          assert(Par O' C' O' C0').
            apply(par_trans _ _ O E); Par.
              apply par_symmetry.
              apply(par_col_par _ _ _ E'); Col.
                intro.
                subst C'.
                induction H38.
                  apply H38.
                  exists O'.
                  split; Col.
                spliter.
                apply H.
                exists O'.
                split; Col.
                ColR.
              left.
              Par.
            apply par_symmetry.
            apply(par_col_par _ _ _ A); Col.
            Par.
          induction H44.
            apply False_ind.
            apply H44.
            exists O'.
            split; Col.
          spliter.
          Col.
          ColR.
        subst C0'.
        Col.
        induction H42.
          assert(Par C C' C C0').
            apply(par_trans _ _ O O'); Par.
            apply par_symmetry.
            apply (par_col_par _ _ _ E''); Col.
            Par.
          induction H42.
            apply False_ind.
            apply H42.
            exists C.
            split; Col.
          spliter.
          Col.
        subst C0'.
        induction H44.
          induction H23.
            apply False_ind.
            apply H23.
            exists C.
            split;Col.
          spliter.
          apply False_ind.
          apply H.
          exists O'.
          split; Col.
          ColR.
        Col.
    subst C0'.
    assert(Par B B'' B' C3).
      apply(par_trans _ _ E E''); Par.
    assert(Par C B'' C' C3).
      apply(par_trans _ _ A E''); Par.
      induction H45.
        Par.
      subst C3.
      assert(Par E E'' O E).
        apply(par_trans _ _ O' E'); Par.
          apply(par_col_par _ _ _ C'); Col.
          apply par_comm.
          apply(par_col_par _ _ _ B'); Col.
            intro.
            subst C'.
            induction H38.
              apply H38.
              exists O'.
              split; Col.
            spliter.
            apply H.
            exists O'.
            split; Col.
            ColR.
            Par.
          ColR.
      apply False_ind.
      induction H45.
        apply H45.
        exists E.
        split; Col.
      spliter.
      apply H24.
      Col.
    (*  *)
    assert(Prod O' E' C2 A' B' C').
      repeat split; Col.
        intro.
        assert(C2 <> O').
          intro.
          subst C2.
          assert(Par O E E E'').
            apply(par_trans _ _ O' E'); Par.
          induction H49.
            apply H49.
            exists E.
            split; Col.
          spliter.
          contradiction.
        assert(Col O O' C2).
          ColR.
        assert(Col O O' E').
          ColR.
        apply H.
        exists O.
        split; Col.
      exists C3.
      split.
        left.
        apply (par_trans _ _ B B''); Par.
        apply (par_trans _ _  E E''); Par.
      split.
        ColR.
      left.
      apply(par_trans _ _ C B''); Par.
      apply(par_trans _ _ A E''); Par.
    apply(prod_y_axis_change O' E' C2 E A' B' C' H48).
    intro.
    apply H.
    exists E.
    split; Col.
Qed.
prod_sym
Proof.
    intros.
    apply (prod_comm O E E').
    assumption.
Qed.
l14_31_1
Proof.
    intros.
    ex_and H1 X.
    spliter.
    unfold Ar2_4 in H.
    spliter.
    induction(eq_dec_points A O).
      subst A.
      assert(HH:= prod_0_l O E E' B H H4).
      assert(X=O).
        apply (prod_O_l_eq O E E' B); assumption.
      subst X.
      apply (prod_null)in H2.
      induction H2.
        contradiction.
      subst D.
      apply(prod_0_l O C E' B).
        intro.
        apply H.
        ColR.
      assert(HG:=grid_not_par O E E' H).
      spliter.
      ColR.
    induction(eq_dec_points B O).
      subst B.
      assert(HH:= prod_0_r O E E' A H H3).
      assert(X=O).
        apply (prod_O_r_eq O E E' A); assumption.
      subst X.
      apply (prod_null)in H2.
      induction H2.
        contradiction.
      subst D.
      apply(prod_0_r O C E' A).
        intro.
        apply H.
        ColR.
      assert(HG:=grid_not_par O E E' H).
      spliter.
      ColR.
    induction(eq_dec_points D O).
      subst D.
      assert(HH:= prod_0_r O E E' C H H5).
      assert(X=O).
        apply (prod_O_r_eq O E E' C); assumption.
      subst X.
      apply (prod_null)in H1.
      induction H1.
        contradiction.
      contradiction.
    assert(HG:=grid_not_par O E E' H).
    spliter.
    assert(exists ! P' : Tpoint, Proj B P' O E' E' C).
      apply(project_existence B O E' E' C).
        intro.
        subst C.
        contradiction.
        auto.
      intro.
      induction H16.
        apply H16.
        exists E'.
        split; Col.
      spliter.
      apply H.
      ColR.
    ex_and H16 B''.
    unfold unique in H17.
    spliter.
    clear H17.
    unfold Proj in H16.
    spliter.
    assert(Par B B'' E' C).
      induction H20.
        Par.
      subst B''.
      apply False_ind.
      apply H.
      ColR.
    clear H20.
    unfold Prod.
    repeat split; try ColR.
      intro.
      apply H.
      ColR.
    exists B''.
    split.
      left.
      Par.
    split.
      Col.
    assert(HP1:=H1).
    assert(HP2:=H2).
    unfold Prod in H1.
    unfold Prod in H2.
    spliter.
    ex_and H22 B'.
    ex_and H20 D'.
    assert(B' <> O).
      intro.
      subst B'.
      induction H22.
        induction H22.
          apply H22.
          exists E.
          split; Col.
        spliter.
        apply H.
        ColR.
      contradiction.
    assert(Par E B'' C B').
      apply(l13_11 E C B  B'  B'' E' O); Col.
        intro.
        apply H.
        ColR.
        ColR.
        intro.
        subst B''.
        induction H21.
          apply H21.
          exists C.
          split; Col.
          ColR.
        spliter.
        apply H.
        ColR.
        ColR.
        Par.
      induction H22.
        Par.
      subst B'.
      apply False_ind.
      apply H.
      ColR.
    assert(X <> O).
      intro.
      subst X.
      apply prod_null in HP1.
      induction HP1; contradiction.
    assert(Par A D' C B').
      apply(l13_11 A C X  B'  D' E' O); Col.
        intro.
        apply H.
        ColR.
        ColR.
        unfold Ar2 in *.
        spliter.
        ColR.
        intro.
        subst D'.
        induction H20.
          induction H20.
            apply H20.
            exists E.
            split; Col.
          spliter.
          apply H.
          ColR.
        contradiction.
        ColR.
        induction H26.
          Par.
        subst D'.
        apply False_ind.
        apply H.
        unfold Ar2 in *.
        spliter.
        ColR.
      induction H24.
        Par.
      subst B'.
      apply False_ind.
      unfold Ar2 in *.
      spliter.
      apply H.
      ColR.
    left.
    apply par_symmetry.
    apply par_comm.
    unfold Ar2 in *.
    spliter.
    apply(l13_11 D A E E' B'' D' O); Col.
      intro.
      apply H.
      ColR.
      ColR.
      intro.
      subst B''.
      induction H28.
        apply H28.
        exists C.
        split; Col.
      spliter.
      apply H.
      ColR.
      intro.
      subst D'.
      induction H30.
        apply H30.
        exists C.
        split; Col.
        ColR.
      spliter.
      apply H.
      ColR.
      ColR.
      apply (par_trans _ _ C B'); Par.
    induction H20.
      Par.
    subst D'.
    apply False_ind.
    apply H.
    ColR.
Qed.
l14_31_2
Proof.
    intros.
    unfold Ar2_4 in H.
    spliter.
    assert(HG:= grid_not_par O E E' H).
    spliter.
    induction(eq_dec_points A O).
      subst A.
      assert(D = O).
        apply(prod_O_l_eq O C E' B); auto.
      subst D.
      exists O.
      split.
        apply(prod_0_l O E E' B); Col.
      apply(prod_0_r O E E' C); Col.
    induction(eq_dec_points B O).
      subst B.
      assert(D = O).
        apply(prod_O_r_eq O C E' A); auto.
      subst D.
      exists O.
      split.
        apply(prod_0_r O E E' A); Col.
      apply(prod_0_r O E E' C); Col.
    induction(eq_dec_points D O).
      subst D.
      exists O.
      apply prod_null in H1.
      induction H1.
        subst A.
        split.
          apply(prod_0_l O E E' B); Col.
        apply(prod_0_r O E E' C); Col.
      subst B.
      split.
        apply(prod_0_r O E E' A); Col.
      apply(prod_0_r O E E' C); Col.
    assert(exists ! P' : Tpoint, Proj B P' O E' E E').
      apply(project_existence B O E' E E'); auto.
      intro.
      apply H8.
      Par.
    ex_and H15 B'.
    unfold unique in H16.
    spliter.
    clear H16.
    unfold Proj in H15.
    spliter.
    assert(Par B B' E E').
      induction H19.
        Par.
      subst B'.
      apply False_ind.
      apply H.
      ColR.
    clear H19.
    assert(exists ! P' : Tpoint, Proj B' P' O E E' A).
      apply(project_existence B' O E E' A); auto.
        intro.
        subst A.
        contradiction.
      intro.
      induction H19.
        apply H19.
        exists A.
        split; Col.
      spliter.
      apply H.
      Col.
    ex_and H19 X.
    unfold unique in H21.
    spliter.
    clear H21.
    unfold Proj in H19.
    spliter.
    clean_duplicated_hyps.
    assert(X <> O).
      intro.
      subst X.
      induction H24.
        induction H15.
          apply H15.
          exists E'.
          split; Col.
        spliter.
        apply H.
        ColR.
      subst B'.
      induction H20.
        apply H15.
        exists E.
        split; Col.
      spliter.
      contradiction.
    assert(Par B' X E' A).
      induction H24.
        Par.
      subst B'.
      apply False_ind.
      apply H.
      ColR.
    clear H24.
    exists X.
    unfold Prod in *.
    spliter.
    ex_and H17 B''.
    repeat split; Col.
      exists B'.
      split.
        left.
        Par.
      split.
        Col.
      induction H24.
        left.
        Par.
      subst B''.
      apply False_ind.
      apply H.
      ColR.
    assert(exists ! P' : Tpoint, Proj D P' O E' E E').
      apply(project_existence D O E' E E'); Col.
      intro.
      apply H8.
      Par.
    ex_and H25 D'.
    unfold unique in H26.
    spliter.
    clear H26.
    unfold Proj in H25.
    spliter.
    clean_duplicated_hyps.
    assert(Par D D' E E').
      induction H29.
        Par.
      subst D'.
      apply False_ind.
      apply H.
      ColR.
    clear H29.
    exists D'.
    split.
      left.
      Par.
    split.
      Col.
    left.
    assert(Par X D' B B'').
      apply(l13_11 X B D B'' D' B' O); auto.
        intro.
        assert(B''<>O).
          intro.
          subst B''.
          induction H17.
            induction H17.
              apply H17.
              exists C.
              split; Col.
              ColR.
            spliter.
            apply H.
            ColR.
          contradiction.
        apply H.
        ColR.
        ColR.
        ColR.
        intro.
        subst D'.
        induction H25.
          apply H25.
          exists E.
          split; Col.
        spliter.
        contradiction.
        intro.
        subst B'.
        induction H20.
          apply H20.
          exists E.
          split; Col.
        spliter.
        contradiction.
        ColR.
        ColR.
        Par.
        apply(par_trans _ _ E E'); Par.
      induction H24.
        apply(par_trans _ _ E' A); Par.
      subst B''.
      apply False_ind.
      apply H.
      ColR.
    induction H17.
      apply (par_trans _ _ B B''); Par.
    subst B''.
    apply par_distincts in H26.
    tauto.
Qed.
prod_x_axis_unit_change
Proof.
    intros.
    ex_and H2 X.
    unfold Ar2_4 in H.
    spliter.
    assert(HG:= grid_not_par O E E' H).
    spliter.
    induction(eq_dec_points A O).
      subst A.
      assert(X = O).
        apply(prod_O_l_eq O E E' B); assumption.
      subst X.
      apply prod_null in H3.
      induction H3.
        subst C.
        exists O.
        split.
          apply(prod_0_l).
            intro.
            apply H.
            ColR.
          ColR.
        apply(prod_0_l).
          intro.
          apply H.
          ColR.
        ColR.
      subst D.
      exists O.
      split.
        apply(prod_0_l).
          intro.
          apply H.
          ColR.
        ColR.
      apply(prod_0_r).
        intro.
        apply H.
        ColR.
      ColR.
    induction(eq_dec_points B O).
      subst B.
      assert(X = O).
        apply(prod_O_r_eq O E E' A); assumption.
      subst X.
      apply prod_null in H3.
      induction H3.
        subst C.
        exists O.
        split.
          apply(prod_0_r).
            intro.
            apply H.
            ColR.
          ColR.
        apply(prod_0_l).
          intro.
          apply H.
          ColR.
        ColR.
      subst D.
      exists O.
      split.
        apply(prod_0_r).
          intro.
          apply H.
          ColR.
        ColR.
      apply(prod_0_r).
        intro.
        apply H.
        ColR.
      ColR.
    induction(eq_dec_points C O).
      subst C.
      assert(X = O).
        apply(prod_O_l_eq O E E' D); assumption.
      subst X.
      apply prod_null in H2.
      induction H2.
        subst A.
        exists O.
        split.
          apply(prod_0_l).
            intro.
            apply H.
            ColR.
          ColR.
        apply(prod_0_l).
          intro.
          apply H.
          ColR.
        ColR.
      subst B.
      exists O.
      split.
        apply(prod_0_r).
          intro.
          apply H.
          ColR.
        ColR.
      apply(prod_0_l).
        intro.
        apply H.
        ColR.
      ColR.
    induction(eq_dec_points D O).
      subst D.
      assert(X = O).
        apply(prod_O_r_eq O E E' C); assumption.
      subst X.
      apply prod_null in H2.
      induction H2.
        subst A.
        exists O.
        split.
          apply(prod_0_l).
            intro.
            apply H.
            ColR.
          ColR.
        apply(prod_0_r).
          intro.
          apply H.
          ColR.
        ColR.
      subst B.
      exists O.
      split.
        apply(prod_0_r).
          intro.
          apply H.
          ColR.
        ColR.
      apply(prod_0_r).
        intro.
        apply H.
        ColR.
      ColR.
    assert(exists ! P' : Tpoint, Proj B P' O E' U E').
      apply(project_existence B O E' U E').
        intro.
        subst U.
        contradiction.
        auto.
      intro.
      induction H18.
        apply H18.
        exists E'.
        split;Col.
      spliter.
      apply H.
      ColR.
    ex_and H18 Bu.
    unfold unique in H19.
    spliter.
    clear H19.
    unfold Proj in H18.
    spliter.
    assert(Par B Bu U E').
      induction H22.
        Par.
      subst Bu.
      apply False_ind.
      apply H.
      ColR.
    clear H22.
    assert(exists ! P' : Tpoint, Proj Bu P' O E A E').
      apply(project_existence Bu O E A E').
        intro.
        subst A.
        contradiction.
        auto.
      intro.
      induction H22.
        apply H22.
        exists A.
        split; Col.
      spliter.
      apply H.
      Col.
    ex_and H22 Xu.
    unfold unique in H24.
    spliter.
    clear H24.
    unfold Proj in H22.
    spliter.
    assert(Par Bu Xu A E').
      induction H27.
        Par.
      subst Bu.
      apply False_ind.
      induction H23.
        apply H23.
        exists U.
        split; Col.
        ColR.
      spliter.
      apply H.
      ColR.
    clear H27.
    exists Xu.
    split.
      unfold Prod.
      repeat split; try ColR.
        intro.
        apply H.
        ColR.
      exists Bu.
      split.
        left.
        Par.
      split.
        ColR.
      left.
      Par.
    assert(exists ! P' : Tpoint, Proj D P' O E' U E').
      apply(project_existence D O E' U E').
        intro.
        subst U.
        apply H.
        ColR.
        auto.
      intro.
      induction H27.
        apply H27.
        exists E'.
        split; Col.
      spliter.
      apply H.
      ColR.
    ex_and H27 Du.
    unfold unique in H29.
    spliter.
    clear H29.
    unfold Proj in H27.
    spliter.
    assert(Par D Du U E').
      induction H32.
        Par.
      subst Du.
      apply False_ind.
      apply H.
      ColR.
    clear H32.
    unfold Prod.
    repeat split; try ColR.
      intro.
      apply H.
      ColR.
    exists Du.
    split.
      left.
      Par.
    split.
      Col.
    assert(Prod O C E' A B D).
      apply(l14_31_1 O E E' A B C D).
        repeat split; Col.
        auto.
      exists X.
      split; Col.
    unfold Prod in H2.
    spliter.
    ex_and H34 B'.
    unfold Prod in H3.
    spliter.
    ex_and H37 D'.
    unfold Prod in H32.
    spliter.
    ex_and H40 D''.
    assert(Xu <> O).
      intro.
      subst Xu.
      induction H28.
        apply H28.
        exists E'.
        split; Col.
      spliter.
      apply H.
      ColR.
    assert(D'' <> O).
      intro.
      subst D''.
      induction H42.
        induction H42.
          apply H42.
          exists A.
          split; Col.
          ColR.
        spliter.
        apply H.
        ColR.
      subst D.
      tauto.
    assert(Par Xu Du B D'').
      apply(l13_11 Xu B D D'' Du Bu O); auto.
        intro.
        apply H.
        ColR.
        ColR.
        ColR.
        intro.
        subst Du.
        induction H33.
          apply H33.
          exists U.
          split; Col.
          ColR.
        spliter.
        apply H.
        ColR.
        intro.
        subst Bu.
        induction H28.
          apply H28.
          exists A.
          split; Col.
          ColR.
        spliter.
        apply H.
        ColR.
        ColR.
        ColR.
        apply(par_trans _ _ U E'); Par.
      induction H42.
        apply (par_trans _ _ E' A); Par.
      subst D''.
      apply False_ind.
      apply H.
      ColR.
    left.
    apply (par_trans _ _ B D''); Par.
    induction H40.
      Par.
    subst D''.
    apply False_ind.
    apply par_distincts in H45.
    tauto.
Qed.
opp_prod
Proof.
intros O E E' ME X MX HOpp1 HOpp2.
assert (HNC : ~ Col O E E')
  by (unfold Opp, Sum, Ar2 in *; spliter; Col).
assert (HCol1 : Col O E ME)
  by (unfold Opp, Sum, Ar2 in *; spliter; Col).
assert (HCol2 : Col O E X)
  by (unfold Opp, Sum, Ar2 in *; spliter; Col).
destruct (sum_exists O E E' HNC E ME) as [EPME HEPME]; Col.
assert (O = EPME)
  by (apply sum_uniqueness with O E E' E ME; auto; apply diff_sum; apply diff_O_A; Col).
treat_equalities; destruct (prod_exists O E E' HNC X E) as [X' HX]; Col.
assert (X = X') by (apply prod_uniqueness with O E E' X E; auto; apply prod_1_r; Col).
treat_equalities; destruct (prod_exists O E E' HNC X O) as [O' HProd]; Col.
assert (O = O') by (apply prod_uniqueness with O E E' X O; auto; apply prod_0_r; Col).
treat_equalities; destruct (prod_exists O E E' HNC X ME) as [MX' HMX]; Col.
assert (HOpp3 : Sum O E E' X MX' O) by (apply distr_l with X E ME O; auto).
apply sum_opp in HOpp3; assert (MX = MX') by (apply opp_uniqueness with O E E' X; Col).
treat_equalities; auto.
Qed.
distr_l_diff
Proof.
intros O E E' A B C BMC AB AC ABMC HBMC HAB HAC HABMC.
apply diff_sum in HBMC; apply sum_diff.
apply distr_l with A C BMC B; auto.
Qed.
diff_of_squares
Proof.
intros O E E' A B A2 B2 A2MB2 APB AMB F HA2 HB2 HA2MB2 HAPB HAMB HF.
assert (HNC : ~ Col O E E')
  by (apply diff_ar2 in HA2MB2; unfold Ar2 in *; spliter; Col).
assert (HColA : Col O E A) by (unfold Prod, Ar2 in *; spliter; Col).
assert (HColB : Col O E B) by (unfold Prod, Ar2 in *; spliter; Col).
assert (HColAMB : Col O E AMB) by (unfold Prod, Ar2 in *; spliter; Col).
destruct (prod_exists O E E' HNC A AMB) as [F1 HF1]; Col.
assert (HColF1 : Col O E F1) by (unfold Prod, Ar2 in *; spliter; Col).
destruct (prod_exists O E E' HNC B AMB) as [F2 HF2]; Col.
assert (HColF2 : Col O E F2) by (unfold Prod, Ar2 in *; spliter; Col).
destruct (sum_exists O E E' HNC F1 F2) as [F' HF']; Col.
assert (F = F').
  {
  apply sum_uniqueness with O E E' F1 F2; auto.
  apply distr_r with A B AMB APB; auto.
  }
treat_equalities; destruct (prod_exists O E E' HNC A B) as [AB HAB]; Col.
assert (HColA2 : Col O E A2) by (unfold Prod, Ar2 in *; spliter; Col).
assert (HColAB : Col O E AB) by (unfold Prod, Ar2 in *; spliter; Col).
destruct (diff_exists O E E' A2 AB) as [A2MAB HA2MAB]; Col.
assert (A2MAB = F1).
  {
  apply diff_uniqueness with O E E' A2 AB; auto.
  apply distr_l_diff with A A B AMB; auto.
  }
destruct (prod_exists O E E' HNC B A) as [BA HBA]; Col.
assert (HColB2 : Col O E B2) by (unfold Prod, Ar2 in *; spliter; Col).
assert (HColBA : Col O E BA) by (unfold Prod, Ar2 in *; spliter; Col).
destruct (diff_exists O E E' BA B2) as [BAMB2 HBAMB2]; Col.
assert (BAMB2 = F2).
  {
  apply diff_uniqueness with O E E' BA B2; auto.
  apply distr_l_diff with B A B AMB; auto.
  }
assert (AB = BA).
  {
  apply prod_uniqueness with O E E' A B; auto.
  apply prod_comm; auto.
  }
treat_equalities; apply diff_uniqueness with O E E' A2 B2; auto.
apply sum_diff_diff_b with AB BAMB2 A2MAB; auto.
Qed.
eq_squares_eq_or_opp
Proof.
intros O E E' A B A2 HA2 HB2.
assert (HNC : ~ Col O E E')
  by (unfold Prod, Ar2 in *; spliter; Col).
assert (HColA : Col O E A) by (unfold Prod, Ar2 in *; spliter; Col).
assert (HColA2 : Col O E A2) by (unfold Prod, Ar2 in *; spliter; Col).
assert (HColB : Col O E B) by (unfold Prod, Ar2 in *; spliter; Col).
destruct (diff_exists O E E' A2 A2) as [O' HA2MA2]; Col.
assert (O = O')
  by (apply diff_uniqueness with O E E' A2 A2; auto; apply diff_null; Col).
destruct (sum_exists O E E' HNC A B) as [APB HAPB]; Col.
assert (HColAPB : Col O E APB) by (unfold Sum, Ar2 in *; spliter; Col).
destruct (diff_exists O E E' A B) as [AMB HAMB]; Col; treat_equalities.
assert (HColAMB : Col O E AMB)
  by (apply diff_sum in HAMB; unfold Sum, Ar2 in *; spliter; Col).
destruct (prod_exists O E E' HNC APB AMB) as [O' H]; Col.
assert (O = O')
  by (apply diff_of_squares with O E E' A B A2 A2 APB AMB; auto).
treat_equalities; apply prod_null in H; induction H; treat_equalities;
[right; apply sum_opp|left; apply diff_null_eq with AMB E E']; auto.
Qed.
diff_2_prod
Proof.
intros O E E' A B AMB BMA ME HOpp HAMB HBMA.
apply opp_prod; auto; apply diff_opp with A B; auto.
Qed.
l14_36_a
Proof.
    intros.
    assert(HS:=H).
    unfold Sum in H.
    spliter.
    unfold Ar2 in H.
    unfold Out in H0.
    spliter.
    assert(Parallelogram_flat O A C B).
      apply(sum_cong O E E' H A B C HS).
      tauto.
    assert(Parallelogram O A C B).
      right.
      auto.
    induction(eq_dec_points A B).
      subst B.
      unfold Parallelogram_flat in H7.
      spliter.
      assert(O = C \/ Midpoint A O C).
        apply(l7_20 A O C).
          ColR.
        Cong.
      induction H13.
        subst C.
        apply False_ind.
        apply HS.
        apply (double_null_null O E E') in HS; auto.
        tauto.
      unfold Midpoint in H13.
      tauto.
    induction H3.
      apply plg_permut in H8.
      apply plg_permut in H8.
      apply plg_permut in H8.
      assert(Bet A B C).
        apply between_symmetry.
        apply(plg_bet1 B O A C).
          assumption.
        apply between_symmetry.
        assumption.
      apply (outer_transitivity_between O A B C); auto.
    assert(Bet B A C).
      apply between_symmetry.
      apply(plg_bet1 A O B C).
        apply plg_comm2.
        assumption.
      apply between_symmetry.
      assumption.
    apply (outer_transitivity_between2 O B A C); auto.
Qed.
l14_36_b
Proof.
    intros.
    assert(HH:= l14_36_a O E E' A B C H H0).
    unfold Out in H0.
    spliter.
    split; auto.
    split.
      intro.
      subst C.
      apply between_identity in HH.
      subst A.
      tauto.
    intro.
    subst C.
    assert(HS:= H).
    unfold Sum in H.
    spliter.
    unfold Ar2 in H.
    spliter.
    assert(Sum O E E' A O A).
      apply (sum_A_O). assumption.
    assumption.
    assert(B = O).
        apply (sum_uniquenessB O E E' H A B O A); auto.
      contradiction.
Qed.
O_not_positive
Proof.
    intros.
    unfold Ps.
    unfold Out.
    intuition.
Qed.
pos_null_neg
Proof.
    intros.
    unfold Opp in H.
    induction (eq_dec_points A O).
      right; left; auto.
    assert(HS:= H).
    unfold Sum in H.
    spliter.
    unfold Ar2 in H.
    spliter.
    assert(Parallelogram_flat O MA O A).
      apply(sum_cong O E E' H MA A O HS); tauto.
    unfold Parallelogram_flat in H5.
    spliter.
    assert(HG:=grid_not_par O E E' H).
    spliter.
    assert(A = MA \/ Midpoint O A MA).
      apply(l7_20 O A MA); try ColR.
      Cong.
    induction H16.
      subst MA.
      tauto.
    induction(out_dec O E A).
      left.
      unfold Ps.
      apply l6_6.
      assumption.
    right; right.
    assert(MA <> O).
      intro.
      subst MA.
      apply is_midpoint_id_2 in H16.
      subst A.
      tauto.
    unfold Midpoint in H16.
    spliter.
    unfold Ps.
    unfold Col in H2.
    induction H2.
      unfold Out.
      repeat split; auto.
    induction H2.
      unfold Out.
      repeat split; Col.
      left.
      apply between_symmetry.
      auto.
    apply False_ind.
    apply H17.
    unfold Out.
    repeat split; auto.
    apply between_symmetry in H16.
    assert(HH:= l5_2 MA O A E H18 H16 H2).
    tauto.
Qed.
sum_pos_pos
Proof.
    intros.
    unfold Ps in *.
    assert(Out O A B).
      apply l6_6 in H0.
      apply(l6_7 O A E B); auto.
    assert(HH:=l14_36_b O E E' A B AB H1 H2).
    spliter.
    assert(HH:=l14_36_a O E E' A B AB H1 H2).
    apply l6_6 in H.
    assert(Out O A AB).
      apply bet_out; auto.
    assert(HP:=l6_7 O E A AB H H6).
    apply l6_6.
    assumption.
Qed.
prod_pos_pos
Proof.
    intros.
    assert(HP:= H1).
    unfold Prod in H1.
    spliter.
    unfold Ar2 in H1.
    spliter.
    ex_and H2 B'.
    assert(HG:= grid_not_par O E E' H1).
    spliter.
    unfold Ps in H.
    unfold Ps in H0.
    unfold Out in *.
    spliter.
    assert(E' <> A).
      intro.
      subst A.
      contradiction.
    assert(~Col O E' A).
      intro.
      apply H1.
      ColR.
    assert(~Par O E E' A).
      intro.
      induction H20.
        apply H20.
        exists A.
        split; Col.
      spliter.
      contradiction.
    assert(Proj E E' O E' E E').
      apply(pj_col_project); Col.
      left; right.
      repeat split; Col.
    assert(Proj B B' O E' E E').
      apply(pj_col_project); Col.
    assert(Proj O O O E' E E').
      apply(pj_col_project); Col.
      right.
      auto.
    assert(Proj E' A O E E' A).
      apply(pj_col_project); Col.
      left; right.
      repeat split; Col.
    assert(Proj B' AB O E E' A).
      apply(pj_col_project); Col.
    assert(Proj O O O E E' A).
      apply(pj_col_project); Col.
      right.
      auto.
    assert(AB <> O).
      intro.
      subst AB.
      apply prod_null in HP.
      induction HP; contradiction.
    unfold Ps.
    repeat split; auto.
    induction H15.
      assert(Bet O B' E').
        apply(project_preserves_bet O E' E E' O B E O B' E'); auto.
      assert(Bet O AB A).
        apply(project_preserves_bet O E E' A O B' E' O AB A); auto.
      induction H17.
        left.
        apply(between_exchange4 _ _ A); auto.
      apply(l5_3 O AB E A); auto.
    assert(Bet O E' B').
      apply(project_preserves_bet O E' E E' O E B O E' B'); auto.
    assert(Bet O A AB).
      apply(project_preserves_bet O E E' A O E' B' O A AB); auto.
    induction H17.
      assert(Bet O E AB \/ Bet O AB E).
        apply(l5_1 O A E AB); auto.
      tauto.
    right.
    apply (between_exchange4 O E A AB); auto.
Qed.
pos_not_neg
Proof.
    intros.
    intro.
    unfold Ps in H.
    unfold Ng in H0.
    unfold Out in H.
    spliter.
    induction H4.
      apply H.
      apply (between_equality _ _ E); Between.
    apply H1.
    apply (between_equality _ _ A); Between.
Qed.
neg_not_pos
Proof.
    intros.
    intro.
    unfold Ps in H0.
    unfold Ng in H.
    unfold Out in H0.
    spliter.
    induction H2.
      apply H0.
      apply (between_equality _ _ E); Between.
    apply H1.
    apply (between_equality _ _ A); Between.
Qed.
opp_pos_neg
Proof.
    intros.
    assert(HH:=opp_midpoint O E E' A MA H0).
    unfold Ng.
    unfold Ps in H.
    unfold Out in H.
    unfold Midpoint in HH.
    spliter.
    repeat split; auto.
      intro.
      subst MA.
      apply cong_identity in H2.
      contradiction.
    induction H4.
      apply(outer_transitivity_between MA O A E); Between.
    apply(between_inner_transitivity MA O E A); Between.
Qed.
opp_neg_pos
Proof.
    intros.
    assert(HH:=opp_midpoint O E E' A MA H0).
    unfold Ng in H.
    unfold Ps.
    unfold Midpoint in HH.
    spliter.
    apply l6_6.
    unfold Out.
    repeat split; auto.
      intro.
      subst MA.
      apply cong_identity in H2.
      contradiction.
    apply (l5_2 A O E MA); auto.
Qed.
ltP_ar2
Proof.
    intros.
    unfold LtP in H.
    ex_and H D.
    apply diff_ar2 in H.
    unfold Ar2 in H.
    spliter.
    repeat split; auto.
Qed.
ltP_neq
Proof.
    intros.
    assert(HH:=ltP_ar2 O E E' A B H).
    unfold Ar2 in HH.
    spliter.
    unfold LtP in H.
    intro.
    subst B.
    ex_and H OO.
    assert(OO=O).
      apply (diff_uniqueness O E E' A A).
        assumption.
      apply diff_null; Col.
    subst OO.
    unfold Ps in H4.
    unfold Out in H4.
    tauto.
Qed.
leP_refl
Proof.
    intros.
    right.
    tauto.
Qed.
ltP_sum_pos
Proof.
    intros.
    unfold LtP.
    exists B.
    split; auto.
    apply sum_diff in H0.
    assumption.
Qed.
pos_opp_neg
Proof.
    intros.
    assert(Ar2 O E E' mA A O).
      unfold Opp in H0.
      apply sum_ar2; auto.
    unfold Ar2 in H1.
    apply opp_midpoint in H0.
    unfold Midpoint in H0.
    unfold Ps in H.
    unfold Out in H.
    spliter.
    unfold Ng.
    repeat split.
      intro.
      subst mA.
      apply H.
      apply cong_identity in H5.
      assumption.
      auto.
    induction H7.
      apply(outer_transitivity_between mA O A E); Between.
    apply between_symmetry.
    apply(between_exchange3 A E O mA); Between.
Qed.
diff_pos_diff_neg
Proof.
    intros.
    assert(Opp O E E' AmB BmA).
      apply (diff_opp O E E' A B); auto.
    eapply (pos_opp_neg O E E' AmB); auto.
Qed.
not_pos_and_neg
Proof.
    intros.
    intro.
    spliter.
    unfold Ps in H.
    unfold Ng in H0.
    unfold Out in H.
    spliter.
    clean_duplicated_hyps.
    induction H4.
      apply H.
      apply (between_equality _  _ E); Between.
    apply H3.
    apply (between_equality _  _ A); Between.
Qed.
leP_asym
Proof.
    intros.
    unfold LeP in *.
    induction H; induction H0.
      unfold LtP in *.
      ex_and H BmA.
      ex_and H0 AmB.
      assert(HH:=diff_pos_diff_neg O E E' A B AmB BmA H0 H H2).
      assert(HT:=diff_pos_diff_neg O E E' B A BmA AmB  H H0 H1).
      apply False_ind.
      assert(HN:=not_pos_and_neg O E AmB).
      apply HN.
      split; auto.
      auto.
      auto.
    auto.
Qed.
leP_trans
Proof.
    intros.
    unfold LeP in *.
    induction H; induction H0.
      left.
      unfold LtP in *.
      ex_and H dBA.
      ex_and H0 dCB.
      assert(Ar2 O E E' B A dBA).
        apply diff_ar2; auto.
      assert(Ar2 O E E' C B dCB).
        apply diff_ar2; auto.
      unfold Ar2 in *.
      spliter.
      clean_duplicated_hyps.
      assert(HH:= sum_exists O E E' H3 dBA dCB H10 H7).
      ex_and HH dCA.
      exists dCA.
      assert(HH:= sum_diff_diff_b O E E' A B C dBA dCB dCA H H0).
      split.
        apply HH.
        apply sum_comm; auto.
      apply(sum_pos_pos O E E' dBA dCB); auto.
      subst C.
      left; auto.
      subst B.
      left; auto.
    subst C.
    subst B.
    right; auto.
Qed.
leP_sum_leP
Proof.
    intros.
    unfold LeP in *.
    assert(Ar2 O E E' A B C).
      apply sum_ar2; auto.
    assert(Ar2 O E E' X Y Z).
      apply sum_ar2; auto.
    unfold Ar2 in *.
    spliter.
    clean_duplicated_hyps.
    induction H; induction H0.
      unfold LtP in *.
      ex_and H dXA.
      ex_and H0 dYB.
      assert(HH:= diff_exists O E E' Z C  H3 H7 H10).
      ex_and HH dZC.
      left.
      exists dZC.
      split; auto.
      assert(Sum O E E' dXA dYB dZC).
        apply(sum_diff2_diff_sum2_b O E E' A B C X Y Z dXA dYB dZC H1 H2 H H0); auto.
      apply(sum_pos_pos O E E' dXA dYB); auto.
      subst Y.
      left.
      unfold LtP in *.
      ex_and H dXA.
      assert(HH:=diff_exists O E E' Z C H3 H7 H10).
      ex_and HH dZC.
      exists dZC.
      split; auto.
      assert(Sum O E E' dXA O dZC).
        apply(sum_diff2_diff_sum2_b O E E' A B C X B Z dXA O dZC); auto.
        apply diff_null; auto.
      assert(dXA = dZC).
        apply(sum_A_O_eq O E E'); auto.
      subst dXA.
      assumption.
      subst X.
      left.
      unfold LtP in *.
      ex_and H0 dYB.
      assert(HH:=diff_exists O E E' Z C H3 H7 H10).
      ex_and HH dZC.
      exists dZC.
      split; auto.
      assert(Sum O E E' O dYB dZC).
        apply(sum_diff2_diff_sum2_b O E E' A B C A Y Z O dYB dZC); auto.
        apply diff_null; auto.
      assert(dYB = dZC).
        apply(sum_O_B_eq O E E'); auto.
      subst dYB.
      assumption.
    subst X.
    subst Y.
    right.
    apply(sum_uniqueness O E E' A B); auto.
Qed.
square_pos
Proof.
intros O E E' A A2 HDiff HA2.
assert (HNC : ~ Col O E E') by (unfold Prod, Ar2 in *; spliter; Col).
assert (HColA : Col O E A) by (unfold Prod, Ar2 in *; spliter; Col).
destruct (opp_exists O E E' HNC A) as [MA HMA]; Col.
assert (HElim := HMA); apply pos_null_neg in HElim.
elim HElim; clear HElim; intro HElim; [apply prod_pos_pos with E' A A; auto|].
elim HElim; clear HElim; intro HPs;
[intuition|apply prod_pos_pos with E' MA MA; auto].
destruct (opp_exists O E E' HNC E) as [ME HME]; Col.
apply prod_assoc1 with A ME A; auto; [|apply prod_comm]; apply opp_prod; auto.
apply opp_comm; Col.
Qed.
col_pos_or_neg
Proof.
intros O E X HOE HOX HCol.
unfold Ps, Ng, Out.
unfold Col in HCol; intuition.
Qed.
ltP_neg
Proof.
intros O E E' A HLt.
destruct HLt as [MA [HDiff HPs]].
apply opp_pos_neg with E' MA; auto.
apply diff_O_A_opp; apply sum_diff; apply sum_comm; try apply diff_sum; auto.
unfold Diff, Opp, Sum, Ar2 in HDiff; destruct HDiff as [MB HXMY]; spliter; Col.
Qed.
ps_le
Proof.
intros O E E' X HNC HBet.
elim (eq_dec_points O X); intro HOX; [right; auto|left].
exists X; split; [apply diff_A_O; induction HBet; Col|].
assert_diffs; repeat (split; Col).
Qed.
lt_diff_ps
Proof.
intros O E E' X Y XMY HCol1 HCol2 HLt HXMY.
destruct HLt as [XMY' [HDiff HPs]].
apply (diff_uniqueness _ _ _ _ _ XMY) in HDiff; treat_equalities; auto.
Qed.
col_2_le_or_ge
Proof.
intros O E E' A B HNC HColA HColB.
assert (HDiff1 : O <> E) by (assert_diffs; auto).
elim (eq_dec_points A B); intro HDiff2; treat_equalities; [left; right; auto|].
destruct (diff_exists O E E' B A) as [D HD]; Col.
assert (HColD : Col O E D) by (apply diff_ar2 in HD; unfold Ar2 in *; spliter; Col).
assert (HDiff3 : O <> D)
  by (intro; treat_equalities; apply diff_null_eq in HD; intuition).
apply col_pos_or_neg in HColD; auto.
elim HColD; clear HColD; intro HNgD; [left; left; exists D; auto|].
destruct (diff_exists O E E' A B) as [MD HMD]; Col.
right; left; exists MD; split; auto; apply opp_neg_pos with E' D; auto.
apply diff_opp with B A; auto.
Qed.
compatibility_of_sum_with_order
Proof.
intros O E E' A B C APC BPC HLe HAPC HBPC.
elim HLe; clear HLe; intro HLe.

  {
  left; destruct HLe as [D [HDiff HPs]]; exists D; split; auto.
  assert (HNC : ~ Col O E E')
    by (apply diff_ar2 in HDiff; unfold Ar2 in *; spliter; Col).
  apply sum_diff; apply diff_sum in HDiff;
  apply sum_assoc_1 with C A B; auto;
  apply sum_comm; auto.
  }

  {
  treat_equalities.
  assert (APC = BPC) by (apply sum_uniqueness with O E E' A C; auto).
  treat_equalities; apply leP_refl.
  }
Qed.
compatibility_of_prod_with_order
Proof.
intros O E E' A B AB HLeA HLeB HAB.
elim HLeA; clear HLeA; intro HLeA;
elim HLeB; clear HLeB; intro HLeB; treat_equalities;
try (apply prod_O_l_eq in HAB); try (apply prod_O_r_eq in HAB);
treat_equalities; try (apply leP_refl).
assert (HNC : ~ Col O E E') by (unfold Prod, Ar2 in *; spliter; Col).
assert (HColA : Col O E A) by (unfold Prod, Ar2 in *; spliter; Col).
assert (HColB : Col O E B) by (unfold Prod, Ar2 in *; spliter; Col).
assert (HColAB : Col O E AB) by (unfold Prod, Ar2 in *; spliter; Col).
left; exists AB; split; try (apply diff_A_O); Col.
destruct HLeA as [A' [HDiff1 HPsA]]; destruct HLeB as [B' [HDiff2 HPsB]].
assert (A = A')
  by (apply diff_uniqueness with O E E' A O; auto; apply diff_A_O; Col).
assert (B = B')
  by (apply diff_uniqueness with O E E' B O; auto; apply diff_A_O; Col).
treat_equalities; apply prod_pos_pos with E' A B; auto.
Qed.
pos_inv_pos
Proof.
intros O E E' A IA HOA HLe HIA.
elim HLe; clear HLe; intro HLe; treat_equalities; [|intuition].
assert (HNC : ~ Col O E E') by (unfold Prod, Ar2 in *; spliter; Col).
assert (HColA : Col O E A) by (unfold Prod, Ar2 in *; spliter; Col).
assert (HColIA : Col O E IA) by (unfold Prod, Ar2 in *; spliter; Col).
destruct (diff_exists O E E' IA O) as [IA' HIA']; Col.
assert (IA = IA') by (apply diff_uniqueness with O E E' IA O; auto; apply diff_A_O; Col).
treat_equalities; left; exists IA; split; auto; clear HIA'.
destruct HLe as [A' [HDiff HPs1]].
assert (A = A') by (apply diff_uniqueness with O E E' A O; auto; apply diff_A_O; Col).
treat_equalities; clear HDiff; destruct (opp_exists O E E' HNC IA) as [MIA HMIA]; Col.
assert (HElim := HMIA); apply pos_null_neg in HElim.
elim HElim; clear HElim; intro HElim; auto.
elim HElim; clear HElim; intro HPs2; treat_equalities.

  {
  assert (O = E)
    by (apply prod_uniqueness with O E E' O A; auto; apply prod_0_l; Col).
  treat_equalities; intuition.
  }

  {
  destruct (opp_exists O E E' HNC E) as [ME HME]; Col.
  assert (HColME : Col O E ME) by (unfold Opp, Sum, Ar2 in *; spliter; Col).
  assert (HProd1 : Prod O E E' IA ME MIA) by (apply opp_prod; auto).
  assert (HProd2 : Prod O E E' MIA A ME).
    {
    apply prod_assoc1 with ME IA E; auto;
    apply prod_comm; auto; apply prod_1_l; Col.
    }
  assert (HFalse : Ps O E ME) by (apply prod_pos_pos with E' MIA A; auto).
  apply opp_pos_neg with O E E' ME E in HFalse; try apply opp_comm; auto.
  exfalso; apply neg_not_pos in HFalse; apply HFalse.
  assert_diffs; repeat (split; Between).
  }
Qed.
le_pos_prod_le
Proof.
intros O E E' A B C AC BC HALeB HPsC HAC HBC.
assert (HNC : ~ Col O E E') by (unfold Prod, Ar2 in *; spliter; Col).
assert (HColA : Col O E A) by (unfold Prod, Ar2 in *; spliter; Col).
assert (HColB : Col O E B) by (unfold Prod, Ar2 in *; spliter; Col).
assert (HColC : Col O E C) by (unfold Prod, Ar2 in *; spliter; Col).
assert (HColAC : Col O E AC) by (unfold Prod, Ar2 in *; spliter; Col).
assert (HColBC : Col O E BC) by (unfold Prod, Ar2 in *; spliter; Col).
destruct (diff_exists O E E' BC AC) as [BCMAC HBCMAC]; Col.
apply compatibility_of_sum_with_order with O BCMAC AC;
try apply sum_O_B; try (apply sum_comm; try apply diff_sum); Col.
destruct (diff_exists O E E' B A) as [BMA HBMA]; Col.
assert (HColBMA : Col O E BMA)
  by (apply diff_ar2 in HBMA; unfold Ar2 in *; spliter; Col).
destruct (prod_exists O E E' HNC BMA C) as [BCMAC' HBCMAC']; Col.
assert (H : Diff O E E' BC AC BCMAC').
  {
  apply sum_diff; apply diff_sum in HBMA;
  apply distr_r with A BMA C B; auto.
  }
assert (BCMAC = BCMAC') by (apply diff_uniqueness with O E E' BC AC; auto).
clear H; treat_equalities;
apply compatibility_of_prod_with_order with BMA C; auto.
destruct (opp_exists O E E' HNC A) as [MA HMA]; Col.
assert (HColMA : Col O E MA) by (unfold Opp, Sum, Ar2 in *; spliter; Col).
apply compatibility_of_sum_with_order with A B MA; auto;
try (apply diff_sum; apply diff_O_A; Col).
apply diff_O_A in HMA; Col; apply diff_sum in HBMA; apply diff_sum in HMA.
apply sum_assoc_1 with BMA A O; auto; try apply sum_A_O; Col.
apply sum_comm; auto.
Qed.
bet_lt12_le23
Proof.
intros O E E' A B C HBet HLt.
assert (HNC : ~ Col O E E')
  by (destruct HLt as [D [H H']]; apply diff_ar2 in H; unfold Ar2 in *; spliter; Col).
assert (HDiff1 : O <> E) by (assert_diffs; auto).
elim (eq_dec_points B C); intro HDiff2; [right; auto|].
assert (HDiff3 : A <> B) by (apply ltP_neq with O E E'; auto).
assert (HColA : Col O E A)
  by (destruct HLt as [D [H H']]; apply diff_ar2 in H; unfold Ar2 in *; spliter; Col).
assert (HColB : Col O E B)
  by (destruct HLt as [D [H H']]; apply diff_ar2 in H; unfold Ar2 in *; spliter; Col).
assert (HColC : Col O E C) by (assert_diffs; assert_cols; ColR).
destruct (diff_exists O E E' C B) as [CMB HCMB]; Col.
elim (eq_dec_points O A); intro HDiff4; elim (eq_dec_points O B); intro HDiff5;
elim (eq_dec_points O C); intro HDiff6; treat_equalities;
[intuition|intuition|intuition| |right; auto| | |].

  {
  destruct HLt as [B' [HB' HPs]].
  assert (B = B') by (apply diff_uniqueness with O E E' B O; auto; apply diff_A_O; Col).
  treat_equalities; left; exists CMB; split; auto.
  split; try (intro; treat_equalities; apply HDiff2; apply eq_sym;
              apply diff_null_eq with CMB E E'; auto).
  split; auto; apply diff_sum in HCMB; apply sum_cong in HCMB;
  Col; apply plgf_bet in HCMB.
  do 3 (try (elim HCMB; clear HCMB; intro HCMB;
             try destruct HCMB as [HBet1 HBet2])).

    {
    exfalso; apply HDiff5; apply between_equality with C; Between.
    }

    {
    exfalso; apply HDiff2; apply between_equality with O; Between.
    }

    {
    destruct HPs as [H [H' HElim]]; clear H; clear H'.
    elim HElim; clear HElim; intro HElim; [eBetween|].
    elim (l5_3 O CMB E B); Between.
    }

    {
    destruct HPs as [H [H' HElim]]; clear H; clear H'.
    elim HElim; clear HElim; intro HElim; [|eBetween].
    elim (l5_2 O B CMB E); eBetween.
    }
  }

  {
  apply ltP_neg in HLt; apply ps_le; Col.
  unfold Ng in *; spliter.
  elim (l5_2 A O C E); Between.
  }

  {
  rename CMB into MB.
  left; exists MB; split; auto; apply opp_neg_pos with E' B;
  try apply diff_O_A_opp; auto.
  apply col_pos_or_neg in HColB; try (intro; treat_equalities; Col).
  elim HColB; clear HColB; intro HPsB; auto; exfalso.
  apply col_pos_or_neg in HColA; try (intro; treat_equalities; Col).
  elim HColA; clear HColA; [intro HPsA|intro HNgA].

    {
    destruct HLt as [BMA [HBMA HPsBMA]]; apply diff_sum in HBMA.
    elim (eq_dec_points A BMA); intro HDiff6; treat_equalities;
    [apply l14_36_a in HBMA; try apply out_trivial; auto;
     apply HDiff3; apply between_equality with O; Between|].
    apply sum_cong in HBMA; Col; apply plgf_bet in HBMA.
    do 3 (try (elim HBMA; clear HBMA; intro HBMA;
               try destruct HBMA as [HBet1 HBet2])).

      {
      apply HDiff5; apply between_equality with A; Between.
      }

      {
      apply not_pos_and_neg with O E BMA; split; auto.
      split; try (intro; treat_equalities; apply O_not_positive with BMA E; auto).
      split; auto; destruct HPsB as [H [H' HElim]]; clear H; clear H'.
      elim HElim; clear HElim; intro HElim; eBetween.
      }

      {
      apply HDiff3; apply between_equality with O; Between.
      apply between_symmetry; apply outer_transitivity_between2 with BMA; auto.
      }

      {
      apply HDiff3; apply between_equality with O; Between.
      apply outer_transitivity_between2 with BMA; Between.
      }
    }

    {
    apply not_pos_and_neg with O E A; split; auto.
    do 2 (split; auto); destruct HPsB as [H [H' HElim]]; clear H; clear H'.
    elim HElim; clear HElim; intro HBet'; [|eBetween].
    elim (l5_2 O B A E); eBetween.
    }
  }

  {
  left; exists CMB; split; auto; apply diff_sum in HCMB; assert (HCMB' := HCMB).
  split; try (intro; treat_equalities; apply HDiff2;
              apply sum_uniqueness with CMB E E' B CMB; auto; apply sum_A_O; Col).
  split; auto; apply sum_cong in HCMB; Col; apply plgf_bet in HCMB.
  apply col_pos_or_neg in HColA; try (intro; treat_equalities; Col).
  apply col_pos_or_neg in HColB; try (intro; treat_equalities; Col).
  elim HColA; clear HColA; [intro HPsA|intro HNgA].

    {
    do 3 (try (elim HCMB; clear HCMB; intro HCMB;
               try destruct HCMB as [HBet1 HBet2])).

      {
      elim HColB; clear HColB; [intro HPsB|intro HNgB].

        {
        destruct HPsA as [H [H' HElim1]]; clear H; clear H'.
        destruct HPsB as [H [H' HElim2]]; clear H; clear H'.
        elim HElim1; clear HElim1; intro HBet3;
        elim HElim2; clear HElim2; intro HBet4.

          {
          elim (l5_3 O A B E); Between; intro HBet5.

            {
            assert (HBet6 : Bet O B C) by eBetween.
            exfalso; apply HDiff5; apply between_equality with C; Between.
            }

            {
            destruct HLt as [BMA [HBMA HPsBMA]]; apply diff_sum in HBMA.
            elim (eq_dec_points A BMA); intro HDiff7; treat_equalities;
            [apply l14_36_a in HBMA; try apply out_trivial; auto; exfalso;
             apply HDiff3; apply between_equality with O; Between|].
            apply sum_cong in HBMA; Col; apply plgf_bet in HBMA.
            do 3 (try (elim HBMA; clear HBMA; intro HBMA;
                       try destruct HBMA as [HBet6 HBet7])).

              {
              exfalso; apply HDiff5; apply between_equality with A; Between.
              }

              {
              destruct HPsBMA as [HDiff8 [H HElim]]; clear H.
              elim HElim; clear HElim; intro HBet8.

                {
                assert (HBet9 : Bet E O B)
                  by (apply outer_transitivity_between2 with BMA; Between).
                exfalso; apply HDiff5; apply between_equality with E; Between.
                }

                {
                assert (HBet9 : Bet E O B) by eBetween.
                exfalso; apply HDiff5; apply between_equality with E; Between.
                }
              }

              {
              assert (HBet8 : Bet O A B)
                by (apply outer_transitivity_between2 with BMA; Between).
              exfalso; apply HDiff3; apply between_equality with O; Between.
              }

              {
              assert (HBet8 : Bet O A B) by eBetween.
              exfalso; apply HDiff3; apply between_equality with O; Between.
              }
            }
          }

          {
          assert (HBet5 : Bet O B C) by eBetween.
          exfalso; apply HDiff5; apply between_equality with C; Between.
          }

          {
          destruct HLt as [BMA [HBMA HPsBMA]]; apply diff_sum in HBMA.
          elim (eq_dec_points A BMA); intro HDiff7; treat_equalities;
          [apply l14_36_a in HBMA; try apply out_trivial; auto; exfalso;
           apply HDiff3; apply between_equality with O; eBetween|].
          apply sum_cong in HBMA; Col; apply plgf_bet in HBMA.
          do 3 (try (elim HBMA; clear HBMA; intro HBMA;
                     try destruct HBMA as [HBet5 HBet6])).

            {
            assert (HBet7 : Bet O B A) by eBetween.
            exfalso; apply HDiff5; apply between_equality with A; Between.
            }

            {
            destruct HPsBMA as [HDiff8 [H' HElim]]; clear H';
            elim HElim; clear HElim; intro HBet7.

              {
              elim (l5_3 O B BMA E); Between; intro HBet8; exfalso;
              [apply HDiff5; apply between_equality with BMA|
               apply HDiff8; apply between_equality with B]; Between.
              }

              {
              assert (HBet8 : Bet O B BMA) by eBetween.
              exfalso; apply HDiff5; apply between_equality with BMA; Between.
              }
            }

            {
            assert (HBet7 : Bet O A B) by eBetween.
            assert (HBet8 : Bet O B A) by eBetween.
            exfalso; apply HDiff3; apply between_equality with O; Between.
            }

            {
            assert (HBet7 : Bet O A B) by eBetween.
            assert (HBet8 : Bet O B A) by eBetween.
            exfalso; apply HDiff3; apply between_equality with O; Between.
            }
          }

          {
          destruct HLt as [BMA [HBMA HPsBMA]]; apply diff_sum in HBMA.
          elim (eq_dec_points A BMA); intro HDiff7; treat_equalities;
          [apply l14_36_a in HBMA; try apply out_trivial; auto; exfalso;
           apply HDiff3; apply between_equality with O; eBetween|].
          apply sum_cong in HBMA; Col; apply plgf_bet in HBMA.
          do 3 (try (elim HBMA; clear HBMA; intro HBMA;
                     try destruct HBMA as [HBet5 HBet6])).

            {
            assert (HBet7 : Bet A O E) by eBetween.
            exfalso; apply HDiff1; apply between_equality with A; Between.
            }

            {
            destruct HPsBMA as [HDiff8 [H' HElim]]; clear H';
            elim HElim; clear HElim; intro HBet7.

              {
              assert (HBet8 : Bet BMA O E) by eBetween.
              exfalso; apply HDiff8; apply between_equality with E; Between.
              }

              {
              assert (HBet8 : Bet BMA O E) by eBetween.
              exfalso; apply HDiff1; apply between_equality with BMA; Between.
              }
            }

            {
            assert (HBet7 : Bet O A B) by eBetween.
            assert (HBet8 : Bet B A C) by eBetween.
            exfalso; apply HDiff3; apply between_equality with C; Between.
            }

            {
            assert (HBet7 : Bet O A B) by eBetween.
            assert (HBet8 : Bet B A C) by eBetween.
            exfalso; apply HDiff3; apply between_equality with C; Between.
            }
          }
        }

        {
        exfalso; apply neg_not_pos in HNgB; apply HNgB; clear HNgB.
        do 2 (split; auto).
        destruct HLt as [BMA [HBMA HPsBMA]]; apply diff_sum in HBMA.
        elim (eq_dec_points A BMA); intro HDiff7; treat_equalities;
        [apply l14_36_a in HBMA; try apply out_trivial; auto; exfalso;
         apply HDiff3; apply between_equality with O; eBetween|].
        apply sum_cong in HBMA; Col; apply plgf_bet in HBMA.
        do 3 (try (elim HBMA; clear HBMA; intro HBMA;
                   try destruct HBMA as [HBet3 HBet4])).

          {
          assert (HBet5 : Bet BMA O A) by eBetween.
          destruct HPsA as [H [H' HElim1]]; clear H; clear H'.
          destruct HPsBMA as [HDiff8 [H' HElim2]]; clear H'.
          elim HElim1; clear HElim1; intro HBet6;
          elim HElim2; clear HElim2; intro HBet7.

            {
            assert (HBet8 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff8; apply between_equality with E; Between.
            }

            {
            assert (HBet8 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff1; apply between_equality with BMA; Between.
            }

            {
            assert (HBet8 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff8; apply between_equality with E; Between.
            }

            {
            assert (HBet8 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff1; apply between_equality with BMA; Between.
            }
          }

          {
          assert (HBet5 : Bet BMA O A) by eBetween.
          destruct HPsA as [H [H' HElim1]]; clear H; clear H'.
          destruct HPsBMA as [HDiff8 [H' HElim2]]; clear H'.
          elim HElim1; clear HElim1; intro HBet6;
          elim HElim2; clear HElim2; intro HBet7.

            {
            assert (HBet8 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff8; apply between_equality with E; Between.
            }

            {
            assert (HBet8 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff1; apply between_equality with BMA; Between.
            }

            {
            assert (HBet8 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff8; apply between_equality with E; Between.
            }

            {
            assert (HBet8 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff1; apply between_equality with BMA; Between.
            }
          }

          {
          destruct HPsA as [H [H' HElim]]; clear H; clear H'.
          elim HElim; clear HElim; intro HBet5; [|eBetween].
          elim (l5_2 O A B E); eBetween.
          }

          {
          destruct HPsA as [H [H' HElim]]; clear H; clear H'.
          elim HElim; clear HElim; intro HBet5; [|eBetween].
          elim (l5_2 O A B E); eBetween.
          }
        }
      }

      {
      elim HColB; clear HColB; [intro HPsB|intro HNgB].

        {
        destruct HPsA as [H [H' HElim1]]; clear H; clear H'.
        destruct HPsB as [H [H' HElim2]]; clear H; clear H'.
        elim HElim1; clear HElim1; intro HBet3;
        elim HElim2; clear HElim2; intro HBet4.

          {
          elim (l5_3 O A B E); Between; intro HBet5.

            {
            assert (HBet6 : Bet O B C) by eBetween.
            exfalso; apply HDiff2; apply between_equality with O; Between.
            }

            {
            destruct HLt as [BMA [HBMA HPsBMA]]; apply diff_sum in HBMA.
            elim (eq_dec_points A BMA); intro HDiff7; treat_equalities;
            [apply l14_36_a in HBMA; try apply out_trivial; auto; exfalso;
             apply HDiff3; apply between_equality with O; Between|].
            apply sum_cong in HBMA; Col; apply plgf_bet in HBMA.
            do 3 (try (elim HBMA; clear HBMA; intro HBMA;
                       try destruct HBMA as [HBet6 HBet7])).

              {
              exfalso; apply HDiff5; apply between_equality with A; Between.
              }

              {
              destruct HPsBMA as [HDiff8 [H HElim]]; clear H.
              elim HElim; clear HElim; intro HBet8.

                {
                assert (HBet9 : Bet E O B)
                  by (apply outer_transitivity_between2 with BMA; Between).
                exfalso; apply HDiff5; apply between_equality with E; Between.
                }

                {
                assert (HBet9 : Bet E O B) by eBetween.
                exfalso; apply HDiff5; apply between_equality with E; Between.
                }
              }

              {
              assert (HBet8 : Bet O A B)
                by (apply outer_transitivity_between2 with BMA; Between).
              exfalso; apply HDiff3; apply between_equality with O; Between.
              }

              {
              assert (HBet8 : Bet O A B) by eBetween.
              exfalso; apply HDiff3; apply between_equality with O; Between.
              }
            }
          }

          {
          assert (HBet5 : Bet O B C) by eBetween.
          exfalso; apply HDiff2; apply between_equality with O; Between.
          }

          {
          destruct HLt as [BMA [HBMA HPsBMA]]; apply diff_sum in HBMA.
          elim (eq_dec_points A BMA); intro HDiff7; treat_equalities;
          [apply l14_36_a in HBMA; try apply out_trivial; auto; exfalso;
           apply HDiff3; apply between_equality with O; eBetween|].
          apply sum_cong in HBMA; Col; apply plgf_bet in HBMA.
          do 3 (try (elim HBMA; clear HBMA; intro HBMA;
                     try destruct HBMA as [HBet5 HBet6])).

            {
            assert (HBet7 : Bet O B A) by eBetween.
            exfalso; apply HDiff5; apply between_equality with A; Between.
            }

            {
            destruct HPsBMA as [HDiff8 [H' HElim]]; clear H';
            elim HElim; clear HElim; intro HBet7.

              {
              elim (l5_3 O B BMA E); Between; intro HBet8; exfalso;
              [apply HDiff5; apply between_equality with BMA|
               apply HDiff8; apply between_equality with B]; Between.
              }

              {
              assert (HBet8 : Bet O B BMA) by eBetween.
              exfalso; apply HDiff5; apply between_equality with BMA; Between.
              }
            }

            {
            assert (HBet7 : Bet O A B) by eBetween.
            assert (HBet8 : Bet O B A) by eBetween.
            exfalso; apply HDiff3; apply between_equality with O; Between.
            }

            {
            assert (HBet7 : Bet O A B) by eBetween.
            assert (HBet8 : Bet O B A) by eBetween.
            exfalso; apply HDiff3; apply between_equality with O; Between.
            }
          }

          {
          destruct HLt as [BMA [HBMA HPsBMA]]; apply diff_sum in HBMA.
          elim (eq_dec_points A BMA); intro HDiff7; treat_equalities;
          [apply l14_36_a in HBMA; try apply out_trivial; auto; exfalso;
           apply HDiff3; apply between_equality with O; eBetween|].
          apply sum_cong in HBMA; Col; apply plgf_bet in HBMA.
          do 3 (try (elim HBMA; clear HBMA; intro HBMA;
                     try destruct HBMA as [HBet5 HBet6])).

            {
            assert (HBet7 : Bet A O E) by eBetween.
            exfalso; apply HDiff1; apply between_equality with A; Between.
            }

            {
            destruct HPsBMA as [HDiff8 [H' HElim]]; clear H';
            elim HElim; clear HElim; intro HBet7.

              {
              assert (HBet8 : Bet BMA O E) by eBetween.
              exfalso; apply HDiff8; apply between_equality with E; Between.
              }

              {
              assert (HBet8 : Bet BMA O E) by eBetween.
              exfalso; apply HDiff1; apply between_equality with BMA; Between.
              }
            }

            {
            assert (HBet7 : Bet O A B) by eBetween.
            assert (HBet8 : Bet B A C) by eBetween.
            exfalso; apply HDiff3; apply between_equality with C; Between.
            }

            {
            assert (HBet7 : Bet O A B) by eBetween.
            assert (HBet8 : Bet B A C) by eBetween.
            exfalso; apply HDiff3; apply between_equality with C; Between.
            }
          }
        }

        {
        exfalso; apply neg_not_pos in HNgB; apply HNgB; clear HNgB.
        do 2 (split; auto).
        destruct HLt as [BMA [HBMA HPsBMA]]; apply diff_sum in HBMA.
        elim (eq_dec_points A BMA); intro HDiff7; treat_equalities;
        [apply l14_36_a in HBMA; try apply out_trivial; auto; exfalso;
         apply HDiff3; apply between_equality with O; eBetween|].
        apply sum_cong in HBMA; Col; apply plgf_bet in HBMA.
        do 3 (try (elim HBMA; clear HBMA; intro HBMA;
                   try destruct HBMA as [HBet3 HBet4])).

          {
          assert (HBet5 : Bet BMA O A) by eBetween.
          destruct HPsA as [H [H' HElim1]]; clear H; clear H'.
          destruct HPsBMA as [HDiff8 [H' HElim2]]; clear H'.
          elim HElim1; clear HElim1; intro HBet6;
          elim HElim2; clear HElim2; intro HBet7.

            {
            assert (HBet8 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff8; apply between_equality with E; Between.
            }

            {
            assert (HBet8 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff1; apply between_equality with BMA; Between.
            }

            {
            assert (HBet8 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff8; apply between_equality with E; Between.
            }

            {
            assert (HBet8 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff1; apply between_equality with BMA; Between.
            }
          }

          {
          assert (HBet5 : Bet BMA O A) by eBetween.
          destruct HPsA as [H [H' HElim1]]; clear H; clear H'.
          destruct HPsBMA as [HDiff8 [H' HElim2]]; clear H'.
          elim HElim1; clear HElim1; intro HBet6;
          elim HElim2; clear HElim2; intro HBet7.

            {
            assert (HBet8 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff8; apply between_equality with E; Between.
            }

            {
            assert (HBet8 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff1; apply between_equality with BMA; Between.
            }

            {
            assert (HBet8 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff8; apply between_equality with E; Between.
            }

            {
            assert (HBet8 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff1; apply between_equality with BMA; Between.
            }
          }

          {
          destruct HPsA as [H [H' HElim]]; clear H; clear H'.
          elim HElim; clear HElim; intro HBet5; [|eBetween].
          elim (l5_2 O A B E); eBetween.
          }

          {
          destruct HPsA as [H [H' HElim]]; clear H; clear H'.
          elim HElim; clear HElim; intro HBet5; [|eBetween].
          elim (l5_2 O A B E); eBetween.
          }
        }
      }

      {
      elim HColB; clear HColB; [intro HPsB|intro HNgB].

        {
        destruct HPsA as [H [H' HElim1]]; clear H; clear H'.
        destruct HPsB as [H [H' HElim2]]; clear H; clear H'.
        elim HElim1; clear HElim1; intro HBet3;
        elim HElim2; clear HElim2; intro HBet4.

          {
          elim (l5_3 O A B E); Between; intro HBet5.

            {
            left; eBetween.
            }

            {
            destruct HLt as [BMA [HBMA HPsBMA]]; apply diff_sum in HBMA.
            elim (eq_dec_points A BMA); intro HDiff7; treat_equalities;
            [apply l14_36_a in HBMA; try apply out_trivial; auto; exfalso;
             apply HDiff3; apply between_equality with O; Between|].
            apply sum_cong in HBMA; Col; apply plgf_bet in HBMA.
            do 3 (try (elim HBMA; clear HBMA; intro HBMA;
                       try destruct HBMA as [HBet6 HBet7])).

              {
              exfalso; apply HDiff5; apply between_equality with A; Between.
              }

              {
              destruct HPsBMA as [HDiff8 [H HElim]]; clear H.
              elim HElim; clear HElim; intro HBet8.

                {
                assert (HBet9 : Bet E O B)
                  by (apply outer_transitivity_between2 with BMA; Between).
                exfalso; apply HDiff5; apply between_equality with E; Between.
                }

                {
                assert (HBet9 : Bet E O B) by eBetween.
                exfalso; apply HDiff5; apply between_equality with E; Between.
                }
              }

              {
              assert (HBet8 : Bet O A B)
                by (apply outer_transitivity_between2 with BMA; Between).
              exfalso; apply HDiff3; apply between_equality with O; Between.
              }

              {
              assert (HBet8 : Bet O A B) by eBetween.
              exfalso; apply HDiff3; apply between_equality with O; Between.
              }
            }
          }

          {
          elim (l5_3 O CMB E B); Between.
          }

          {
          destruct HLt as [BMA [HBMA HPsBMA]]; apply diff_sum in HBMA.
          elim (eq_dec_points A BMA); intro HDiff7; treat_equalities;
          [apply l14_36_a in HBMA; try apply out_trivial; auto; exfalso;
           apply HDiff3; apply between_equality with O; eBetween|].
          apply sum_cong in HBMA; Col; apply plgf_bet in HBMA.
          do 3 (try (elim HBMA; clear HBMA; intro HBMA;
                     try destruct HBMA as [HBet5 HBet6])).

            {
            assert (HBet7 : Bet O B A) by eBetween.
            exfalso; apply HDiff5; apply between_equality with A; Between.
            }

            {
            destruct HPsBMA as [HDiff8 [H' HElim]]; clear H';
            elim HElim; clear HElim; intro HBet7.

              {
              elim (l5_3 O B BMA E); Between; intro HBet8; exfalso;
              [apply HDiff5; apply between_equality with BMA|
               apply HDiff8; apply between_equality with B]; Between.
              }

              {
              assert (HBet8 : Bet O B BMA) by eBetween.
              exfalso; apply HDiff5; apply between_equality with BMA; Between.
              }
            }

            {
            assert (HBet7 : Bet O A B) by eBetween.
            assert (HBet8 : Bet O B A) by eBetween.
            exfalso; apply HDiff3; apply between_equality with O; Between.
            }

            {
            assert (HBet7 : Bet O A B) by eBetween.
            assert (HBet8 : Bet O B A) by eBetween.
            exfalso; apply HDiff3; apply between_equality with O; Between.
            }
          }

          {
          elim (l5_3 O CMB E B); Between.
          }
        }

        {
        assert (HBet3 : Bet B O A).
          {
          destruct HPsA as [H'' [H' H]]; unfold Ng in *; spliter;
          induction H; eBetween.
          }
        exfalso; apply neg_not_pos in HNgB; apply HNgB; clear HNgB.
        do 2 (split; auto).
        destruct HLt as [BMA [HBMA HPsBMA]]; apply diff_sum in HBMA.
        elim (eq_dec_points A BMA); intro HDiff7; treat_equalities;
        [apply l14_36_a in HBMA; try apply out_trivial; auto; exfalso;
         apply HDiff4; apply between_equality with B; eBetween|].
        apply sum_cong in HBMA; Col; apply plgf_bet in HBMA.
        do 3 (try (elim HBMA; clear HBMA; intro HBMA;
                   try destruct HBMA as [HBet4 HBet5])).

          {
          assert (HBet6 : Bet BMA O A) by eBetween.
          destruct HPsA as [H [H' HElim1]]; clear H; clear H'.
          destruct HPsBMA as [HDiff8 [H' HElim2]]; clear H'.
          elim HElim1; clear HElim1; intro HBet7;
          elim HElim2; clear HElim2; intro HBet8.

            {
            assert (HBet9 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff8; apply between_equality with E; Between.
            }

            {
            assert (HBet9 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff1; apply between_equality with BMA; Between.
            }

            {
            assert (HBet9 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff8; apply between_equality with E; Between.
            }

            {
            assert (HBet9 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff1; apply between_equality with BMA; Between.
            }
          }

          {
          assert (HBet6 : Bet BMA O A) by eBetween.
          destruct HPsA as [H [H' HElim1]]; clear H; clear H'.
          destruct HPsBMA as [HDiff8 [H' HElim2]]; clear H'.
          elim HElim1; clear HElim1; intro HBet7;
          elim HElim2; clear HElim2; intro HBet8.

            {
            assert (HBet9 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff8; apply between_equality with E; Between.
            }

            {
            assert (HBet9 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff1; apply between_equality with BMA; Between.
            }

            {
            assert (HBet9 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff8; apply between_equality with E; Between.
            }

            {
            assert (HBet9 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff1; apply between_equality with BMA; Between.
            }
          }

          {
          destruct HPsA as [H [H' HElim]]; clear H; clear H'.
          elim HElim; clear HElim; intro HBet6; [|eBetween].
          elim (l5_2 O A B E); eBetween.
          }

          {
          destruct HPsA as [H [H' HElim]]; clear H; clear H'.
          elim HElim; clear HElim; intro HBet6; [|eBetween].
          elim (l5_2 O A B E); eBetween.
          }
        }
      }

      {
      elim HColB; clear HColB; [intro HPsB|intro HNgB].

        {
        destruct HPsB as [H [H' HElim]]; clear H; clear H'.
        elim HElim; clear HElim; intro HBet3.

          {
          elim (l5_2 O B CMB E); eBetween.
          }

          {
          right; eBetween.
          }
        }

        {
        assert (HBet3 : Bet B O A).
          {
          destruct HPsA as [H'' [H' H]]; unfold Ng in *; spliter;
          induction H; eBetween.
          }
        exfalso; apply neg_not_pos in HNgB; apply HNgB; clear HNgB.
        do 2 (split; auto).
        destruct HLt as [BMA [HBMA HPsBMA]]; apply diff_sum in HBMA.
        elim (eq_dec_points A BMA); intro HDiff7; treat_equalities;
        [apply l14_36_a in HBMA; try apply out_trivial; auto; exfalso;
         apply HDiff4; apply between_equality with B; eBetween|].
        apply sum_cong in HBMA; Col; apply plgf_bet in HBMA.
        do 3 (try (elim HBMA; clear HBMA; intro HBMA;
                   try destruct HBMA as [HBet4 HBet5])).

          {
          assert (HBet6 : Bet BMA O A) by eBetween.
          destruct HPsA as [H [H' HElim1]]; clear H; clear H'.
          destruct HPsBMA as [HDiff8 [H' HElim2]]; clear H'.
          elim HElim1; clear HElim1; intro HBet7;
          elim HElim2; clear HElim2; intro HBet8.

            {
            assert (HBet9 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff8; apply between_equality with E; Between.
            }

            {
            assert (HBet9 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff1; apply between_equality with BMA; Between.
            }

            {
            assert (HBet9 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff8; apply between_equality with E; Between.
            }

            {
            assert (HBet9 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff1; apply between_equality with BMA; Between.
            }
          }

          {
          assert (HBet6 : Bet BMA O A) by eBetween.
          destruct HPsA as [H [H' HElim1]]; clear H; clear H'.
          destruct HPsBMA as [HDiff8 [H' HElim2]]; clear H'.
          elim HElim1; clear HElim1; intro HBet7;
          elim HElim2; clear HElim2; intro HBet8.

            {
            assert (HBet9 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff8; apply between_equality with E; Between.
            }

            {
            assert (HBet9 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff1; apply between_equality with BMA; Between.
            }

            {
            assert (HBet9 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff8; apply between_equality with E; Between.
            }

            {
            assert (HBet9 : Bet BMA O E) by eBetween.
            exfalso; apply HDiff1; apply between_equality with BMA; Between.
            }
          }

          {
          destruct HPsA as [H [H' HElim]]; clear H; clear H'.
          elim HElim; clear HElim; intro HBet6; [|eBetween].
          elim (l5_2 O A B E); eBetween.
          }

          {
          destruct HPsA as [H [H' HElim]]; clear H; clear H'.
          elim HElim; clear HElim; intro HBet6; [|eBetween].
          elim (l5_2 O A B E); eBetween.
          }
        }
      }
    }

    {
    elim HColB; clear HColB; [intro HPsB|intro HNgB].

      {
      do 3 (try (elim HCMB; clear HCMB; intro HCMB;
               try destruct HCMB as [HBet1 HBet2])).

        {
        destruct HNgA as [H [H' HBet3]]; clear H; clear H'.
        destruct HPsB as [H [H' HElim]]; clear H; clear H'.
        elim HElim; clear HElim; intro HBet4;
        assert (HBet5 : Bet O B C) by eBetween;
        exfalso; apply HDiff5; apply between_equality with C; Between.
        }

        {
        destruct HNgA as [H [H' HBet3]]; clear H; clear H'.
        destruct HPsB as [H [H' HElim]]; clear H; clear H'.
        elim HElim; clear HElim; intro HBet4;
        assert (HBet5 : Bet O B C) by eBetween;
        exfalso; apply HDiff2; apply between_equality with O; Between.
        }

        {
        destruct HPsB as [H [H' HElim]]; clear H; clear H'.
        elim HElim; clear HElim; intro HBet4; [left; eBetween|].
        elim (l5_3 O CMB E B); eBetween.
        }

        {
        destruct HPsB as [H [H' HElim]]; clear H; clear H'.
        elim HElim; clear HElim; intro HBet4; [|right; eBetween].
        elim (l5_2 O B CMB E); eBetween.
        }
      }

      {
      do 3 (try (elim HCMB; clear HCMB; intro HCMB;
               try destruct HCMB as [HBet1 HBet2])).

        {
        destruct HNgB as [H [H' HBet3]]; clear H; clear H'.
        elim (l5_2 B O C E); Between; [|right; eBetween]; intro HBet4.
        elim (l5_2 O C CMB E); eBetween.
        }

        {
        destruct HNgB as [H [H' HBet3]]; clear H; clear H'.
        assert (HBet4 : Bet E O C) by eBetween.
        elim (l5_2 C O CMB E); Between.
        }

        {
        destruct HNgA as [H [H' HBet3]]; clear H; clear H'.
        destruct HNgB as [H [H' HBet4]]; clear H; clear H'.
        elim (l5_2 E O A B); Between; intro HBet5.

          {
          destruct HLt as [BMA [HBMA HPsBMA]]; apply diff_sum in HBMA.
          elim (eq_dec_points A BMA); intro HDiff7; treat_equalities;
          [destruct HPsBMA as [H [H' HElim]]; clear H; clear H';
           elim HElim; clear HElim; intro HBet6; exfalso;
           [apply HDiff4; apply between_equality with E|
            apply HDiff1; apply between_equality with A]; Between|].
          apply sum_cong in HBMA; Col; apply plgf_bet in HBMA.
          do 3 (try (elim HBMA; clear HBMA; intro HBMA;
                     try destruct HBMA as [HBet6 HBet7])).

            {
            exfalso; apply HDiff4; apply between_equality with B; Between.
            }

            {
            exfalso; apply HDiff3; apply between_equality with O; Between.
            }

            {
            assert (HBet8 : Bet E O BMA) by eBetween.
            destruct HPsBMA as [HDiff8 [H' HElim]]; clear H'.
            exfalso; elim HElim; clear HElim; intro HBet9;
            [apply HDiff8; apply between_equality with E|
             apply HDiff1; apply between_equality with BMA]; Between.
            }

            {
            assert (HBet8 : Bet E O BMA) by eBetween.
            destruct HPsBMA as [HDiff8 [H' HElim]]; clear H'.
            exfalso; elim HElim; clear HElim; intro HBet9;
            [apply HDiff8; apply between_equality with E|
             apply HDiff1; apply between_equality with BMA]; Between.
            }
          }

          {
          assert (HBet6 : Bet O B C).
            {
            elim (eq_dec_points B CMB); intro HDiff7; treat_equalities; [|eBetween].
            apply l14_36_a in HCMB'; try apply out_trivial; auto.
            }
          elim (l5_2 O B A C); Between; intro HBet7.

            {
            exfalso; apply HDiff3; apply between_equality with C; Between.
            }

            {
            exfalso; apply HDiff2; apply between_equality with A; Between.
            }
          }
        }

        {
        destruct HNgA as [H [H' HBet3]]; clear H; clear H'.
        destruct HNgB as [H [H' HBet4]]; clear H; clear H'.
        elim (l5_2 E O A B); Between; intro HBet5.

          {
          destruct HLt as [BMA [HBMA HPsBMA]]; apply diff_sum in HBMA.
          elim (eq_dec_points A BMA); intro HDiff7; treat_equalities;
          [destruct HPsBMA as [H [H' HElim]]; clear H; clear H';
           elim HElim; clear HElim; intro HBet6; exfalso;
           [apply HDiff4; apply between_equality with E|
            apply HDiff1; apply between_equality with A]; Between|].
          apply sum_cong in HBMA; Col; apply plgf_bet in HBMA.
          do 3 (try (elim HBMA; clear HBMA; intro HBMA;
                     try destruct HBMA as [HBet6 HBet7])).

            {
            exfalso; apply HDiff4; apply between_equality with B; Between.
            }

            {
            exfalso; apply HDiff3; apply between_equality with O; Between.
            }

            {
            assert (HBet8 : Bet E O BMA) by eBetween.
            destruct HPsBMA as [HDiff8 [H' HElim]]; clear H'.
            exfalso; elim HElim; clear HElim; intro HBet9;
            [apply HDiff8; apply between_equality with E|
             apply HDiff1; apply between_equality with BMA]; Between.
            }

            {
            assert (HBet8 : Bet E O BMA) by eBetween.
            destruct HPsBMA as [HDiff8 [H' HElim]]; clear H'.
            exfalso; elim HElim; clear HElim; intro HBet9;
            [apply HDiff8; apply between_equality with E|
             apply HDiff1; apply between_equality with BMA]; Between.
            }
          }

          {
          assert (HBet6 : Bet O B C).
            {
            elim (eq_dec_points B CMB); intro HDiff7; treat_equalities; [|eBetween].
            apply l14_36_a in HCMB'; try apply out_trivial; auto.
            }

          elim (l5_2 O B A C); Between; intro HBet7.

            {
            exfalso; apply HDiff3; apply between_equality with C; Between.
            }

            {
            exfalso; apply HDiff2; apply between_equality with A; Between.
            }
          }
        }
      }
    }
  }
Qed.
bet_lt12_le13
Proof.
intros O E E' A B C HBet HLt.
apply leP_trans with B; [left; auto|].
apply bet_lt12_le23 with A; auto.
Qed.
bet_lt21_le32
Proof.
intros O E E' A B C HBet HLt.
assert (HNC : ~ Col O E E')
  by (destruct HLt as [D [H H']]; apply diff_ar2 in H; unfold Ar2 in *; spliter; Col).
elim (eq_dec_points B C); intro HDiff2; [right; auto|].
assert (HDiff3 : B <> A) by (apply ltP_neq with O E E'; auto).
assert (HColA : Col O E A)
  by (destruct HLt as [D [H H']]; apply diff_ar2 in H; unfold Ar2 in *; spliter; Col).
assert (HColB : Col O E B)
  by (destruct HLt as [D [H H']]; apply diff_ar2 in H; unfold Ar2 in *; spliter; Col).
assert (HColC : Col O E C) by (assert_diffs; assert_cols; ColR).
destruct (diff_exists O E E' B C) as [BMC HBMC]; Col.
destruct (opp_exists O E E' HNC A) as [MA HMA]; Col.
destruct (opp_exists O E E' HNC B) as [MB HMB]; Col.
destruct (opp_exists O E E' HNC C) as [MC HMC]; Col.
assert (HColMA : Col O E MA) by (unfold Opp, Sum, Ar2 in *; spliter; Col).
assert (HColMB : Col O E MB) by (unfold Opp, Sum, Ar2 in *; spliter; Col).
assert (HColMC : Col O E MC) by (unfold Opp, Sum, Ar2 in *; spliter; Col).
assert (HColBMC : Col O E BMC)
  by (apply diff_ar2 in HBMC; unfold Ar2 in *; spliter; Col).
destruct (diff_exists O E E' A B) as [AMB HAMB]; Col.
assert (HColAMB : Col O E AMB)
  by (apply diff_ar2 in HAMB; unfold Ar2 in *; spliter; Col).
destruct (diff_exists O E E' MA MB) as [MAMMB HMAMMB]; Col.
assert (HColMAMMB : Col O E MAMMB)
  by (apply diff_ar2 in HMAMMB; unfold Ar2 in *; spliter; Col).
assert (HOppAMB : Opp O E E' AMB MAMMB).
  {
  apply sum_opp; apply sum_assoc_1 with MB A B;
  [| |apply sum_comm; Col; apply diff_sum; apply diff_O_A; Col].

    {
    apply diff_sum in HAMB.
    apply sum_assoc_2 with B AMB O; auto.
    apply sum_O_B; Col.
    }

    {
    apply diff_sum in HMAMMB.
    apply sum_assoc_2 with MA B O; auto; try apply sum_O_B; Col;
    [apply diff_sum; apply diff_O_A; Col|].
    apply sum_assoc_1 with MAMMB MB O; auto; [apply sum_comm; auto|].
    apply sum_A_O; Col.
    }
  }
destruct (diff_exists O E E' MB MA) as [MBMMA HMBMMA]; Col.
assert (HColMBMMA : Col O E MBMMA)
  by (apply diff_ar2 in HMBMMA; unfold Ar2 in *; spliter; Col).
assert (HOppMAMMB : Opp O E E' MAMMB MBMMA) by (apply diff_opp with MA MB; auto).
assert (AMB = MBMMA)
  by (apply opp_uniqueness with O E E' MAMMB; auto; apply opp_comm; auto).
treat_equalities.
assert (HBet' : Bet MA MB MC)
  by (apply l7_15 with A B C O; auto; try apply opp_midpoint with E E'; auto).
destruct (diff_exists O E E' MB MC) as [MBMMC HMBMMC]; Col.
assert (HColMAMMC : Col O E MBMMC)
  by (apply diff_ar2 in HMBMMC; unfold Ar2 in *; spliter; Col).
assert (HOppAMC : Opp O E E' BMC MBMMC).
  {
  apply sum_opp; apply sum_assoc_1 with MC B C;
  [| |apply sum_comm; Col; apply diff_sum; apply diff_O_A; Col].

    {
    apply diff_sum in HBMC.
    apply sum_assoc_2 with C BMC O; auto.
    apply sum_O_B; Col.
    }

    {
    apply diff_sum in HMBMMC.
    apply sum_assoc_2 with MB C O; auto; try apply sum_O_B; Col;
    [apply diff_sum; apply diff_O_A; Col|].
    apply sum_assoc_1 with MBMMC MC O; auto; [apply sum_comm; auto|].
    apply sum_A_O; Col.
    }
  }
destruct (diff_exists O E E' MC MB) as [MCMMB HMCMMB]; Col.
assert (HOppMBMMC : Opp O E E' MBMMC MCMMB) by (apply diff_opp with MB MC; auto).
assert (BMC = MCMMB)
  by (apply opp_uniqueness with O E E' MBMMC; auto; apply opp_comm; auto).
treat_equalities.
assert (HLt' : LtP O E E' MA MB)
  by (exists AMB; split; auto; apply lt_diff_ps with E' A B; auto).
assert (HLe : LeP O E E' MB MC) by (apply bet_lt12_le23 with MA; auto).
left; exists BMC; split; auto; apply lt_diff_ps with E' MC MB; auto.
elim HLe; clear HLe; intro HFalse; auto; treat_equalities.
assert (O = BMC)
  by (apply diff_uniqueness with O E E' MB MB; auto; apply diff_null; Col).
treat_equalities; apply diff_null_eq in HBMC; treat_equalities; intuition.
Qed.
bet_lt21_le31
Proof.
intros O E E' A B C HBet HLt.
apply leP_trans with B; [|left; auto].
apply bet_lt21_le32 with A; auto.
Qed.
opp_2_le_le
Proof.
intros O E E' A MA B MB HOppA HOppB HLe.
assert (HNC : ~ Col O E E') by (unfold Opp, Sum, Ar2 in *; spliter; Col).
assert (HColA : Col O E A) by (unfold Opp, Sum, Ar2 in *; spliter; Col).
assert (HColMA : Col O E MA) by (unfold Opp, Sum, Ar2 in *; spliter; Col).
assert (HColB : Col O E B) by (unfold Opp, Sum, Ar2 in *; spliter; Col).
assert (HColMB : Col O E MB) by (unfold Opp, Sum, Ar2 in *; spliter; Col).
destruct (sum_exists O E E' HNC MA MB) as [MAMB HMAMB]; Col.
assert (HMA : Sum O E E' B MAMB MA)
  by (apply sum_assoc_2 with MB MA O; apply sum_comm; Col; apply sum_A_O; auto).
assert (HMB : Sum O E E' A MAMB MB)
  by (apply sum_assoc_2 with MA MB O; try apply sum_O_B; auto; apply sum_comm; auto).
eapply compatibility_of_sum_with_order in HLe; [|apply HMB|apply HMA]; auto.
Qed.
diff_2_le_le
Proof.
intros O E E' A B C AMC BMC HAMC HBMC HLe.
assert (HNC : ~ Col O E E')
  by (apply diff_ar2 in HAMC; unfold Ar2 in *; spliter; Col).
assert (HColC : Col O E C)
  by (apply diff_ar2 in HAMC; unfold Ar2 in *; spliter; Col).
assert (HColAMC : Col O E AMC)
  by (apply diff_ar2 in HAMC; unfold Ar2 in *; spliter; Col).
assert (HColBMC : Col O E BMC)
  by (apply diff_ar2 in HBMC; unfold Ar2 in *; spliter; Col).
destruct (opp_exists O E E' HNC C) as [MC HMC]; Col.
assert (HAMC' : Sum O E E' A MC AMC).
  {
  apply diff_sum in HAMC; apply sum_assoc_1 with AMC C O;
  apply sum_comm; auto; apply sum_O_B; Col.
  }
assert (HBMC' : Sum O E E' B MC BMC).
  {
  apply diff_sum in HBMC; apply sum_assoc_1 with BMC C O;
  apply sum_comm; auto; apply sum_O_B; Col.
  }
apply compatibility_of_sum_with_order with A B MC; auto.
Qed.
length_pos
Proof.
intros.
unfold Length in *.
tauto.
Qed.
length_id_1
Proof.
intros.
unfold Length in *.
spliter.
treat_equalities.
reflexivity.
Qed.
length_id_2
Proof.
intros.
unfold Length.
repeat split.
assumption.
Col.
unfold LeP.
tauto.
Cong.
Qed.
length_id
Proof.
intros.
split.
intros.
split.
eauto using length_id_1.
unfold Length in *.
tauto.
intros.
spliter. subst.
apply length_id_2.
assumption.
Qed.
length_eq_cong_1
Proof.
intros.
unfold Length in *.
spliter.
apply cong_transitivity with O AB;Cong.
Qed.
length_eq_cong_2
Proof.
intros.
unfold Length in *.
spliter.
repeat split;try assumption.
apply cong_transitivity with A B;Cong.
Qed.
ltP_pos
Proof.
intros.
unfold LtP in H.
ex_and H A'.

assert(~Col O E E' /\ Col O E A).
unfold Diff in H.
ex_and H X.
unfold Sum in H1.
spliter.
unfold Ar2 in H1.
tauto.
spliter.

assert(HH:= diff_A_O O E E' A H1 H2).
assert(A = A').
apply(diff_uniqueness O E E' A O A A'); assumption.
subst A'.
assumption.
Qed.
bet_leP
Proof.
intros.
unfold LeP in *.
induction H0; induction H1.

unfold LtP in H0.
unfold LtP in H1.
ex_and H0 P.
ex_and H1 Q.

assert(Ar2 O E E' AB CD P /\ Col O E Q).
unfold Diff in H0.
ex_and H0 X.
unfold Diff in H1.
ex_and H1 Y.
unfold Sum in H4.
unfold Sum in H5.
spliter.
unfold Ar2 in *.
spliter.
repeat split; Col.
unfold Ar2 in H4.
spliter.

assert(P = AB).
apply (diff_uniqueness O E E' AB O); auto.
apply diff_A_O; auto.
subst P.

assert(Q = CD).
apply (diff_uniqueness O E E' CD O); auto.
apply diff_A_O; auto.
subst Q.
clean_duplicated_hyps.

induction(eq_dec_points AB CD).
right.
assumption.
left.
clear H0 H1.


assert(HH:=opp_exists O E E' H4 AB H6).
ex_and HH AB'.

assert(exists P, Sum O E E' CD AB' P).
apply(sum_exists O E E' H4 CD AB'); Col.
unfold Opp in H0.
unfold Sum in H0.
spliter.
unfold Ar2 in H0.
tauto.
ex_and H1 P.


unfold LtP.
exists P.
split.
unfold Diff.
exists AB'.
split; auto.


assert(Diff O E E' CD AB P).
unfold Diff.
exists AB'.
split; auto.

apply diff_sum in H1.
induction (eq_dec_points AB O).
subst AB.
unfold Ps in H2.
unfold Out in H2.
spliter.
tauto.

assert(Parallelogram_flat O AB CD P).
apply (sum_cong O E E' H4 AB P CD H1).
left.
assumption.
unfold Parallelogram_flat in H10.
spliter.

assert(Bet CD P O).
apply(l4_6 O AB CD CD P O).
assumption.
repeat split; Cong.
unfold Ps.
unfold Out.
repeat split.
intro.
subst P.
assert(AB=CD).
apply cong_symmetry in H13.
apply (cong_identity _ _ O); Cong.
subst CD.
tauto.
intro.
subst E.
apply H4.
Col.
unfold Ps in H3.
unfold Out in H3.
spliter.
induction H17.
left.
apply (between_exchange4 O P CD E); Between.
apply (l5_3 O P E CD); Between.
subst CD.
apply between_identity in H.
subst AB.
right; auto.
subst AB.
left; assumption.
subst AB.
subst CD.
right; auto.
Qed.
leP_bet
Proof.
intros.
unfold LeP in H.
induction H.
unfold LtP in H.
ex_and H X.
apply diff_sum in H.

assert(Out O AB X \/ AB=O).
unfold LeP in H0.
induction H0.
left.
apply ltP_pos in H0.
unfold Ps in *.
eapply (l6_7 _ _ E); auto.
apply l6_6.
assumption.
right.
auto.

induction H3.

apply (l14_36_a O E E' AB X CD); auto.
subst AB.
apply between_trivial2.
subst CD.
apply between_trivial.
Qed.
length_Ar2
Proof.
intros.
unfold Length in H.
spliter.

unfold LeP in H1.
induction H1.
left.
split.
assumption.
unfold LtP in H1.
ex_and H1 P.
unfold Diff in H1.
ex_and H1 Q.
unfold Sum in *.
spliter.
unfold Ar2 in *.
tauto.
right; auto.
Qed.
length_leP_le_1
Proof.
intros.
unfold Length in *.
spliter.
assert(Bet O AB CD).
apply (leP_bet O E E'); assumption.

prolong D C M' A B.
assert(HH:=symmetric_point_construction M' C).
ex_and HH M.
unfold Midpoint in H11.
spliter.

assert(Cong A B C M).
apply (cong_transitivity _ _ C M'); Cong.

apply(le_transitivity _ _ C M).
unfold Le.
exists M.
split; Between.

assert(Le O AB O CD).
unfold Le.
exists AB.
split; Cong.

apply(l5_6 O AB O CD C M C D); Cong.
apply (cong_transitivity _ _ A B); Cong.
Qed.
length_leP_le_2
Proof.
intros.

assert(HH1:= length_Ar2 O E E' A B AB H).
assert(HH2:= length_Ar2 O E E' C D CD H0).
spliter.
unfold Length in *.
spliter.
apply bet_leP; try assumption.

induction(eq_dec_points O CD).
subst CD.
apply cong_symmetry in H4.
apply cong_identity in H4.
subst D.
unfold Le in H1.
ex_and H1 X.
apply between_identity in H1.
subst X.
apply cong_identity in H4.
subst B.
apply cong_identity in H7.
subst AB.
Between.
assert(Le O AB O CD).

apply(l5_6 A B C D O AB O CD); Cong.
unfold Le in H8.
ex_and H9 M.

induction HH1; induction HH2.
spliter.

unfold Le in H1.
ex_and H1 P.

unfold LeP in *.
induction H6; induction H3.
unfold LtP in *.
ex_and H6 X.
ex_and H3 Y.
apply diff_sum in H6.
apply diff_sum in H3.
apply sum_cong in H6; auto.
apply sum_cong in H3; auto.
unfold Parallelogram_flat in *.
spliter.
apply cong_symmetry in H19.
apply cong_identity in H19.
subst Y.
apply cong_symmetry in H23.
apply cong_identity in H23.
subst X.
clean_trivial_hyps.

assert(AB = M \/ Midpoint O AB M).
apply(l7_20 O AB M); Cong.

unfold Ps in *.
assert(Out O AB CD).
apply (l6_7 O AB E CD); auto.
apply l6_6.
assumption.
apply out_col in H3.
apply bet_col in H9.
apply col_permutation_2.

apply (col_transitivity_1 _ CD); Col.
induction H3.
subst M.
assumption.
unfold Midpoint in H3.
spliter.

assert(Out O AB CD).
unfold Ps in *.

apply (l6_7 O AB E CD); auto.
apply l6_6.
assumption.
assert(Bet AB O CD).

eapply (outer_transitivity_between _ _ M); Between.
intro.
subst M.
apply cong_identity in H6.
subst AB.
tauto.
unfold Out in H18.
spliter.
induction H22.
assert(AB = O).
apply(between_equality _ _ CD); Between.
subst AB.
Between.
assert(Bet CD O CD).
apply (between_exchange3 AB); Between.
assert(O = CD).
apply between_equality in H23.
contradiction.
Between.
tauto.
right.
intro.
subst Y.
unfold Ps in H17.
unfold Out in H17.
tauto.
right.
intro.
subst X.
unfold Ps in H16.
unfold Out in H16.
tauto.
subst CD.
tauto.
subst AB.
Between.
subst CD.
tauto.
subst CD.
tauto.
subst AB.
Between.
subst CD.
tauto.
Qed.
l15_3
Proof.
intros.
assert(Ar2 O E E' A B C).
unfold Sum in H.
spliter.
assumption.
unfold Ar2 in H0.
spliter.
induction (eq_dec_points A O).
subst A.
assert(B = C).
apply (sum_uniqueness O E E' O B); auto.
apply sum_O_B; auto.
subst C.
Cong.
apply sum_cong in H; auto.
unfold Parallelogram_flat in H.
spliter.
Cong.
Qed.
length_uniqueness
Proof.
intros.
assert(Col O E AB /\ ~ Col O E E' \/ AB = O).
eapply (length_Ar2 O E E' A B AB); assumption.
assert(Col O E AB' /\ ~ Col O E E' \/ AB' = O).
eapply (length_Ar2 O E E' A B AB'); assumption.

unfold Length in *.
spliter.
assert(Cong O AB O AB').
apply cong_transitivity with A B; Cong.
assert(AB = AB' \/ Midpoint O AB AB').
apply(l7_20 O AB AB').
ColR.
Cong.
induction H10.
assumption.
unfold Midpoint in H10.
spliter.

induction H1; induction H2.
spliter.

unfold LeP in *.
induction H4; induction H7.
unfold LtP in H4.
unfold LtP in H7.
ex_and H4 X.
ex_and H7 Y.
apply diff_sum in H4.
apply diff_sum in H7.
assert(X = AB').
apply(sum_O_B_eq O E E'); Col.
subst X.
assert(Y = AB).
apply(sum_O_B_eq O E E'); Col.
subst Y.
unfold Ps in *.
assert(Out O AB AB').
eapply (l6_7 _ _ E).
assumption.
apply l6_6; assumption.
unfold Out in H16.
spliter.
induction H18.
assert(AB = O).
eapply (between_equality _ _ AB'); Between.
subst AB.
apply cong_symmetry in H11.
apply cong_identity in H11.
auto.
assert(AB' = O).
eapply (between_equality _ _ AB); Between.
subst AB'.
apply cong_identity in H11.
auto.
subst AB.
apply cong_symmetry in H9.
apply cong_identity in H9.
auto.
subst AB'.
apply cong_identity in H9.
auto.
subst AB'.
apply cong_identity in H9.
auto.
subst AB'.
apply cong_identity in H9.
auto.
subst AB.
apply cong_symmetry in H9.
apply cong_identity in H9.
auto.
subst AB.
subst AB'.
reflexivity.
Qed.
length_cong
Proof.
intros.
unfold Length in H.
spliter.
Cong.
Qed.
length_Ps
Proof.
intros.
unfold Length in H0.
spliter.
unfold LeP in H2.
induction H2.
unfold LtP in H2.
ex_and H2 X.
apply diff_sum in H2.
apply sum_cong in H2.
unfold Parallelogram_flat in H2.
spliter.
apply cong_symmetry in H6.
apply cong_identity in H6.
subst X.
assumption.
unfold Sum in H2.
spliter.
unfold Ar2 in H2.
tauto.
right.
intro.
subst X.
unfold Ps in H4.
unfold Out in H4.
tauto.
subst AB.
tauto.
Qed.
length_not_col_null
Proof.
intros.
unfold Length in H0.
spliter.
unfold LeP in H2.
induction H2.
unfold LtP in H2.
ex_and H2 X.
apply diff_sum in H2.
unfold Sum in H2.
spliter.
unfold Ar2 in H2.
spliter.
contradiction.
auto.
Qed.
triangular_equality_equiv
Proof.
split.
intros.
assert(HH:= H O E A H0).
apply (HH E' B C); auto.
intros.
assert(HH:= H O E E' A B C AB BC AC H0 H1 H2 H3 H4).
assumption.
Qed.
not_triangular_equality1
Proof.
intros.
intro.
assert(HH:=(H0 E A A O O O)).
assert(Bet A A A); Between.
assert(Length O E E A A O).
apply(length_id_2); auto.
assert(HHH:= (HH H1 H2 H2 H2)).
unfold Sum in HHH.
spliter.
ex_and H4 X.
ex_and H5 Y.
unfold Ar2 in H3.
spliter.
apply H3.
Col.
Qed.
triangular_equality
Proof.
intros O E E' A B C AB BC AC H H0 Hl1 Hl2 Hl3.

unfold Is_length in *.

induction Hl1; induction Hl2; induction Hl3; try(spliter; contradiction).
unfold Length in *.
spliter.
unfold LeP in *.
induction H11; induction H8; induction H5.

(* General Case *)

unfold LtP in *.
ex_and H11 X.
ex_and H8 Y.
ex_and H5 Z.
apply diff_sum in H11.
apply diff_sum in H8.
apply diff_sum in H5.
assert(AB = X).
apply (sum_uniqueness O E E' O X).
assumption.
unfold Sum in H11.
spliter.
unfold Ar2 in H11.
apply(sum_O_B); tauto.
subst X.

assert(BC = Y).
apply (sum_uniqueness O E E' O Y).
assumption.
unfold Sum in H8.
spliter.
unfold Ar2 in H8.
apply(sum_O_B); tauto.
subst Y.

assert(AC = Z).
apply (sum_uniqueness O E E' O Z).
assumption.
unfold Sum in H5.
spliter.
unfold Ar2 in H5.
apply(sum_O_B); tauto.
subst Z.

assert(forall A B : Tpoint,Col O E A -> Col O E B -> exists C : Tpoint, Sum O E E' A B C).
apply(sum_exists O E E' ).
unfold Sum in H11.
spliter.
unfold Ar2 in H11.
tauto.
assert(HS:= H16 AB BC H10 H7).
ex_and HS AC'.

assert(Bet O AB AC').
apply(l14_36_a O E E' AB BC AC' H17).
eapply (l6_7 _ _ E).
assumption.
apply l6_6.
assumption.

assert(HH:= l15_3 O E E' AB BC AC' H17).

assert(Cong O AC' A C).
apply(l2_11 O AB AC' A B C); Cong.
apply cong_transitivity with O BC; Cong.

assert(HP:= sum_pos_pos O E E' AB BC AC' H13 H14 H17).
assert(AC = AC').
apply(l6_11_uniqueness O A C E AC AC').
intro.
subst E.
tauto.
intro.
subst C.
apply between_identity in H0.
subst B.
apply cong_identity in H6.
subst AC.
unfold Ps in H15.
unfold Out in H15.
tauto.
unfold Ps in H15.
assumption.
Cong.
unfold Ps in HP.
assumption.
Cong.
subst AC'.
left.
assumption.

(* Case AC = O *)

subst AC.
apply cong_symmetry in H6.
apply cong_identity in H6.
subst C.
apply between_identity in H0.
subst B.
apply cong_identity in H12.
subst AB.
apply cong_identity in H9.
subst BC.
unfold LtP in H8.
ex_and H8 X.
apply diff_sum in H0.
assert(X=O).
apply(sum_uniqueness O E E' O X).
apply sum_O_B.
unfold Sum in H0.
spliter.
unfold Ar2 in H0.
tauto.
unfold Ps in H5.
apply out_col in H5.
Col.
assumption.
subst X.
unfold Ps in H5.
unfold Out in H5.
tauto.

(* BC = O *)

subst BC.
apply cong_symmetry in H9.
apply cong_identity in H9.
subst C.
assert(Cong O AB O AC).
apply cong_transitivity with A B; Cong.
unfold LtP in H11.
ex_and H11 X.
apply diff_sum in H9.
assert(X = AB).
apply (sum_uniqueness O E E' O X).
apply sum_O_B.
unfold Sum in H9.
spliter.
unfold Ar2 in H9.
tauto.
unfold Ps in H11.
apply out_col in H11.
Col.
assumption.
subst X.
unfold LtP in H5.
ex_and H5 Y.
apply diff_sum in H5.

assert(Y = AC).
apply (sum_uniqueness O E E' O Y).
apply sum_O_B.
unfold Sum in H9.
spliter.
unfold Ar2 in H9.
tauto.
unfold Ps in H13.
apply out_col in H13.
Col.
assumption.
subst Y.
assert(AB = AC).
apply(l6_11_uniqueness O A B E AB AC).
intro.
subst E.
unfold Ps in H13.
unfold Out in H13.
tauto.
intro.
subst B.
apply cong_identity in H6.
subst AC.
unfold Ps in H13.
unfold Out in H13.
tauto.
unfold Ps in H11.
assumption.
Cong.
unfold Ps in H13.
assumption.
Cong.
subst AB.
left.
apply sum_A_O.
unfold Sum in H9.
unfold Ar2 in H9.
tauto.
unfold Ps in H11.
apply out_col in H11.
Col.

(* Case AC = O /\ BC = O *)

subst AC.
subst BC.
apply cong_symmetry in H6.
apply cong_identity in H6.
subst C.
apply cong_symmetry in H9.
apply cong_identity in H9.
subst B.
apply cong_identity in H12.
subst AB.
left.
apply sum_O_O.
unfold LtP in H11.
ex_and H11 X.
apply diff_sum in H5.
unfold Sum in H5.
unfold Ar2 in H5.
tauto.

(* Case AB = O *)

subst AB.
apply cong_symmetry in H12.
apply cong_identity in H12.
subst B.

assert(BC = AC).
apply(l6_11_uniqueness O A C E BC AC).
intro.
subst E.
tauto.
intro.
subst C.
apply cong_identity in H9.
subst BC.
unfold LtP in H8.
ex_and H8 X.
apply diff_sum in H8.
assert(X = O).
apply (sum_uniqueness O E E' O X).
apply sum_O_B.
unfold Sum in H8.
unfold Ar2 in H8.
tauto;
unfold Ps in H13.
unfold Ps in H9.
apply out_col in H9.
Col.
assumption.
subst X.
unfold Ps in H9.
unfold Out in H9.
tauto.
unfold LtP in H8.
ex_and H8 X.
apply diff_sum in H8.

assert(X = BC).
apply (sum_uniqueness O E E' O X).
apply sum_O_B.
unfold Sum in H8.
unfold Ar2 in H8.
tauto;
unfold Out in H13.
unfold Ps in H11.
apply out_col in H11.
Col.
assumption.
subst X.
unfold Ps in H11.
assumption.
Cong.

unfold LtP in H5.
ex_and H5 X.
apply diff_sum in H5.
assert(X = AC).
apply (sum_uniqueness O E E' O X).
apply sum_O_B.
unfold Sum in H5.
unfold Ar2 in H5.
tauto;
unfold Out in H13.
unfold Ps in H11.
apply out_col in H11.
Col.
assumption.
subst X.
unfold Ps in H11.
assumption.
Cong.
subst AC.
left.
apply sum_O_B.
unfold LtP in H5.
ex_and H5 X.
apply diff_sum in H5.
unfold Sum in H5.
unfold Ar2 in H5.
tauto.
Col.

(* Case AB = O /\ AC = O *)

subst AC.
subst AB.
apply cong_symmetry in H12.
apply cong_identity in H12.
subst B.
apply cong_symmetry in H6.
apply cong_identity in H6.
subst C.
apply cong_identity in H9.
subst BC.
left.
apply sum_O_O.
unfold LtP in H8.
ex_and H8 X.
apply diff_sum in H5.
unfold Sum in H5.
unfold Ar2 in H5.
tauto.

(* Case AB = O /\ BC = O *)

subst AB.
subst BC.
apply cong_symmetry in H9.
apply cong_identity in H9.
subst C.
apply cong_symmetry in H12.
apply cong_identity in H12.
subst B.
apply cong_identity in H6.
subst AC.
left.
apply sum_O_O.
unfold LtP in H5.
ex_and H5 X.
apply diff_sum in H5.
unfold Sum in H5.
unfold Ar2 in H5.
tauto.

(* Case AB = O /\ BC = O /\ AC= O *)


treat_equalities.
assert(HH:=Col_dec O E E').
induction HH.
right.
split.
intro.
unfold Ar2 in H1.
spliter.
contradiction.
tauto.
left.
apply sum_O_O.
auto.
Qed.
length_O
Proof.
intros.
unfold Length.
repeat split; Col.
unfold LeP.
right;auto.
Cong.
Qed.
triangular_equality_bis
Proof.
intros O E E' A B C AB BC AC.
intro HH0.
intros.

unfold Length in *.
spliter.
unfold LeP in *.
induction H11; induction H8; induction H5.

(* General Case *)

unfold LtP in *.
ex_and H11 X.
ex_and H8 Y.
ex_and H5 Z.
apply diff_sum in H11.
apply diff_sum in H8.
apply diff_sum in H5.
assert(AB = X).
apply (sum_uniqueness O E E' O X).
assumption.
unfold Sum in H11.
spliter.
unfold Ar2 in H11.
apply(sum_O_B); tauto.
subst X.

assert(BC = Y).
apply (sum_uniqueness O E E' O Y).
assumption.
unfold Sum in H8.
spliter.
unfold Ar2 in H8.
apply(sum_O_B); tauto.
subst Y.

assert(AC = Z).
apply (sum_uniqueness O E E' O Z).
assumption.
unfold Sum in H5.
spliter.
unfold Ar2 in H5.
apply(sum_O_B); tauto.
subst Z.

assert(forall A B : Tpoint,Col O E A -> Col O E B -> exists C : Tpoint, Sum O E E' A B C).
apply(sum_exists O E E' ).
unfold Sum in H11.
spliter.
unfold Ar2 in H11.
tauto.
assert(HS:= H16 AB BC H10 H7).
ex_and HS AC'.

assert(Bet O AB AC').
apply(l14_36_a O E E' AB BC AC' H17).
eapply (l6_7 _ _ E).
assumption.
apply l6_6.
assumption.

assert(HH:= l15_3 O E E' AB BC AC' H17).

assert(Cong O AC' A C).
apply(l2_11 O AB AC' A B C); Cong.
apply cong_transitivity with O BC; Cong.

assert(HP:= sum_pos_pos O E E' AB BC AC' H13 H14 H17).
assert(AC = AC').
apply(l6_11_uniqueness O A C E AC AC').
intro.
subst E.
unfold Ps in H15.
unfold Out in H15.
tauto.
intro.
subst C.
apply between_identity in H0.
subst B.
apply cong_identity in H6.
subst AC.
unfold Ps in H15.
unfold Out in H15.
tauto.
unfold Ps in H15.
assumption.
Cong.
unfold Ps in HP.
assumption.
Cong.
subst AC'.
assumption.

(* Case AC = O *)

subst AC.
apply cong_symmetry in H6.
apply cong_identity in H6.
subst C.
apply between_identity in H0.
subst B.
apply cong_identity in H12.
subst AB.
apply cong_identity in H9.
subst BC.
unfold LtP in H8.
ex_and H8 X.
apply diff_sum in H0.
assert(X=O).
apply(sum_uniqueness O E E' O X).
apply sum_O_B.
unfold Sum in H0.
spliter.
unfold Ar2 in H0.
tauto.
unfold Ps in H5.
apply out_col in H5.
Col.
assumption.
subst X.
unfold Ps in H5.
unfold Out in H5.
tauto.

(* BC = O *)

subst BC.
apply cong_symmetry in H9.
apply cong_identity in H9.
subst C.
assert(Cong O AB O AC).
apply cong_transitivity with A B; Cong.
unfold LtP in H11.
ex_and H11 X.
apply diff_sum in H9.
assert(X = AB).
apply (sum_uniqueness O E E' O X).
apply sum_O_B.
unfold Sum in H9.
spliter.
unfold Ar2 in H9.
tauto.
unfold Ps in H11.
apply out_col in H11.
Col.
assumption.
subst X.
unfold LtP in H5.
ex_and H5 Y.
apply diff_sum in H5.

assert(Y = AC).
apply (sum_uniqueness O E E' O Y).
apply sum_O_B.
unfold Sum in H9.
spliter.
unfold Ar2 in H9.
tauto.
unfold Ps in H13.
apply out_col in H13.
Col.
assumption.
subst Y.
assert(AB = AC).
apply(l6_11_uniqueness O A B E AB AC).
intro.
subst E.
unfold Ps in H13.
unfold Out in H13.
tauto.
intro.
subst B.
apply cong_identity in H6.
subst AC.
unfold Ps in H13.
unfold Out in H13.
tauto.
unfold Ps in H11.
assumption.
Cong.
unfold Ps in H13.
assumption.
Cong.
subst AB.
apply sum_A_O.
unfold Sum in H9.
unfold Ar2 in H9.
tauto.
unfold Ps in H11.
apply out_col in H11.
Col.

(* Case AC = O /\ BC = O *)

subst AC.
subst BC.
apply cong_symmetry in H6.
apply cong_identity in H6.
subst C.
apply cong_symmetry in H9.
apply cong_identity in H9.
subst B.
apply cong_identity in H12.
subst AB.
apply sum_O_O.
unfold LtP in H11.
ex_and H11 X.
apply diff_sum in H5.
unfold Sum in H5.
unfold Ar2 in H5.
tauto.

(* Case AB = O *)

subst AB.
apply cong_symmetry in H12.
apply cong_identity in H12.
subst B.

assert(BC = AC).
apply(l6_11_uniqueness O A C E BC AC).
intro.
subst E.
tauto.
intro.
subst C.
apply cong_identity in H9.
subst BC.
unfold LtP in H8.
ex_and H8 X.
apply diff_sum in H8.
assert(X = O).
apply (sum_uniqueness O E E' O X).
apply sum_O_B.
unfold Sum in H8.
unfold Ar2 in H8.
tauto;
unfold Ps in H13.
unfold Ps in H9.
apply out_col in H9.
Col.
assumption.
subst X.
unfold Ps in H9.
unfold Out in H9.
tauto.
unfold LtP in H8.
ex_and H8 X.
apply diff_sum in H8.

assert(X = BC).
apply (sum_uniqueness O E E' O X).
apply sum_O_B.
unfold Sum in H8.
unfold Ar2 in H8.
tauto;
unfold Out in H13.
unfold Ps in H11.
apply out_col in H11.
Col.
assumption.
subst X.
unfold Ps in H11.
assumption.
Cong.

unfold LtP in H5.
ex_and H5 X.
apply diff_sum in H5.
assert(X = AC).
apply (sum_uniqueness O E E' O X).
apply sum_O_B.
unfold Sum in H5.
unfold Ar2 in H5.
tauto;
unfold Out in H13.
unfold Ps in H11.
apply out_col in H11.
Col.
assumption.
subst X.
unfold Ps in H11.
assumption.
Cong.
subst AC.
apply sum_O_B.
unfold LtP in H5.
ex_and H5 X.
apply diff_sum in H5.
unfold Sum in H5.
unfold Ar2 in H5.
tauto.
Col.

(* Case AB = O /\ AC = O *)

subst AC.
subst AB.
apply cong_symmetry in H12.
apply cong_identity in H12.
subst B.
apply cong_symmetry in H6.
apply cong_identity in H6.
subst C.
apply cong_identity in H9.
subst BC.
apply sum_O_O.
unfold LtP in H8.
ex_and H8 X.
apply diff_sum in H5.
unfold Sum in H5.
unfold Ar2 in H5.
tauto.

(* Case AB = O /\ BC = O *)

subst AB.
subst BC.
apply cong_symmetry in H9.
apply cong_identity in H9.
subst C.
apply cong_symmetry in H12.
apply cong_identity in H12.
subst B.
apply cong_identity in H6.
subst AC.
apply sum_O_O.
unfold LtP in H5.
ex_and H5 X.
apply diff_sum in H5.
unfold Sum in H5.
unfold Ar2 in H5.
tauto.

(* Case AB = O /\ BC = O /\ AC= O *)

subst AB.
subst AC.
subst BC.

apply cong_symmetry in H12.
apply cong_identity in H12.
subst B.
apply cong_symmetry in H9.
apply cong_identity in H9.
subst C.
apply cong_identity in H6.
induction HH0; tauto.
Qed.
length_out
Proof.
intros.
unfold Length in *.
spliter.
unfold LeP in *.
induction H7; induction H4.
unfold LtP in *.
ex_and H7 X.
ex_and H4 Y.
apply diff_sum in H7.
apply diff_sum in H4.
assert(X = AB).
apply (sum_uniqueness O E E' O X).
apply sum_O_B.
unfold Sum in H4.
spliter.
unfold Ar2 in H4.
tauto.
unfold Ps in H9.
apply out_col in H9.
Col.
assumption.
subst X.
assert(Y = CD).
apply (sum_uniqueness O E E' O Y).
apply sum_O_B.
unfold Sum in H4.
spliter.
unfold Ar2 in H4.
tauto.
unfold Ps in H10.
apply out_col in H10.
Col.
assumption.
subst Y.
unfold Ps in *.
eapply (l6_7  _ _ E).
assumption.
apply l6_6.
assumption.
subst CD.
apply cong_symmetry in H5.
apply cong_identity in H5.
contradiction.
subst AB.
apply cong_symmetry in H8.
apply cong_identity in H8.
contradiction.
subst CD.
apply cong_symmetry in H5.
apply cong_identity in H5.
contradiction.
Qed.
image_preserves_bet1
Proof.
intros.
induction(eq_dec_points X Y).
subst Y.
unfold Reflect in *.
induction H0.
tauto.
induction H1.
tauto.
induction H2.
tauto.
spliter.
clean_duplicated_hyps.
apply(l7_15 A B C A' B' C' X).
apply l7_2.
auto.
apply l7_2; auto.
apply l7_2; auto.
assumption.
apply (image_preserves_bet A B C A' B' C' X Y).
unfold Reflect in H0.
induction H0.
tauto.
spliter.
contradiction.
unfold Reflect in *.
induction H0; induction H1; induction H2; try( spliter; contradiction).
spliter.
auto.
induction H0; induction H1; induction H2; try( spliter; contradiction).
spliter.
auto.
induction H0; induction H1; induction H2; try( spliter; contradiction).
spliter.
auto.
assumption.
Qed.
image_preserves_col
Proof.
intros.
induction H.
unfold Col.
left.
apply (image_preserves_bet1 X Y A B C A' B' C'); auto.
induction H.
unfold Col.
right; left.
apply (image_preserves_bet1 X Y B C A B' C' A'); auto.
unfold Col.
right; right.
apply (image_preserves_bet1 X Y C A B C' A' B'); auto.
Qed.
image_preserves_out
Proof.
intros.
unfold Out in *.
spliter.
repeat split; auto.
intro.
subst B'.
assert(B = A).
apply (l10_2_uniqueness X Y A' B A H1 H0).
contradiction.

intro.
subst C'.
assert(C=A).
apply (l10_2_uniqueness X Y A' C A H2 H0).
contradiction.
induction H4.
left.
apply (image_preserves_bet1 X Y A B C); auto.
right.
apply (image_preserves_bet1 X Y A C B); auto.
Qed.
project_preserves_out
Proof.
intros.
repeat split.
intro.
subst B'.
unfold Out in H.
spliter.
unfold Proj in H1.
unfold Proj in H2.
spliter.
induction H9; induction H13.
assert(Par A A' B A').
apply (par_trans _ _ X Y); auto.
apply par_symmetry.
assumption.
induction H14.
apply H14.
exists A'.
split; Col.
spliter.
apply H0.
apply par_symmetry.
apply(par_col_par X Y A A' B).
intro.
subst B.
tauto.
apply par_symmetry.
assumption.
Col.
subst A'.
apply H0.
apply par_left_comm.
assumption.
subst A'.
contradiction.
subst A'.
contradiction.

assert(HC:Col A B C).
apply out_col in H.
assumption.
unfold Out in H.
spliter.
intro.
subst C'.
unfold Proj in H1 ,H3.
spliter.
induction H9; induction H13.
assert(Par A A' C A').
apply (par_trans _ _ X Y).
assumption.
apply par_symmetry.
assumption.
induction H14.
apply H14.
exists A'.
split; Col.
spliter.

apply H0.
apply par_symmetry.
apply (par_col_par X Y A A' B).
intro.
subst B.
tauto.
apply par_symmetry.
assumption.
ColR.
subst A'.
apply H0.
apply par_symmetry.
apply(par_col_par X Y A C B).
intro.
subst B.
tauto.
apply par_symmetry.
apply par_left_comm.
assumption.
Col.
subst A'.
apply H0.
apply par_symmetry.
apply(par_col_par X Y A C B).
intro.
subst B.
tauto.
apply par_symmetry.
assumption.
Col.
subst A'.
contradiction.
unfold Out in H.
spliter.
induction H5.
left.
apply (project_preserves_bet P Q X Y A B C A' B' C'); assumption.
right.
apply (project_preserves_bet P Q X Y A C B A' C' B'); assumption.
Qed.
conga_bet_conga
Proof.
intros.
assert(HH:= l11_13 A B C D E F A' D' H H4 H0 H6 H2).
apply conga_comm.
apply(l11_13 C B A' F E D' C' F'); auto.
apply conga_comm.
assumption.
Qed.
thales
Proof.
intros.
induction(Col_dec O E E').
unfold Prodg.
right.
split.
intro.
unfold Ar2 in H10.
spliter.
contradiction.
unfold Prodg in H8.
induction H8.
unfold Prod in H8.
spliter.
unfold Ar2 in H8.
spliter.
contradiction.
tauto.
induction H8.

induction(eq_dec_points P B).
subst B.
apply length_cong in H5.
apply cong_symmetry in H5.
apply cong_identity in H5.
subst B1.
unfold Pj in H3.
induction H3.
induction H3.
apply False_ind.
apply H3.
exists C.
split; Col.
spliter.
apply False_ind.
apply H2.
ColR.
subst D.
apply length_cong in H7.
apply cong_symmetry in H7.
apply cong_identity in H7.
subst D1.
assert (AD = O).
apply (prod_uniqueness O E E' A1 O).
assumption.
apply prod_0_r.
assumption.
unfold Prod in H8.
spliter.
unfold Ar2 in H3.
tauto.
subst AD.
left.
apply prod_0_r.
assumption.

unfold Length in H6.
spliter.
unfold LeP in H6.
induction H6.
unfold LtP in H6.
ex_and H6 X.
apply diff_sum in H6.
unfold Sum in H6.
spliter.
unfold Ar2 in H6.
tauto.
subst C1; Col.

induction(eq_dec_points A B).
{
subst B.
induction H3.
induction H3.
apply False_ind.
apply H3.
exists A.
split; Col.
spliter.
assert(C=D).
apply(l6_21 P C A C); Col.
subst D.
assert(A1=B1).
apply (length_uniqueness O E E' P A);auto.
subst B1.
assert(C1 = D1).
apply (length_uniqueness O E E' P C);auto.
subst D1.
left.
apply prod_comm.
assumption.
subst D.
apply False_ind.
apply H2; Col.
}

rename H11 into HAB.

assert(Hl0:= H4).
assert(Hl1:= H5).
assert(Hl2:= H6).
assert(Hl3:= H7).

unfold Length in H4.
unfold Length in H5.
unfold Length in H6.
unfold Length in H7.
spliter.
clean_duplicated_hyps.


assert(exists C' : Tpoint, Cong_3 P A C O A1 C' /\ OS O A1 E' C').
{
apply(l10_16 P A C O A1 E');
Cong.
apply length_Ar2 in Hl0.
induction Hl0.
spliter.
intro.
induction(eq_dec_points A1 O).
subst A1.
apply cong_symmetry in H22.
apply cong_identity in H22.
subst A.
apply H2.
Col.
apply H5.
ColR.
subst A1.
intro.
apply cong_symmetry in H22.
apply cong_identity in H22.
subst A.
apply H2.
Col.
}

ex_and H4 C1'.

assert(CongA P A C O A1 C1').
{
apply(cong3_conga).
intro.
subst A.
apply H2; Col.
intro.
subst C.
apply H2; Col.
assumption.
}

assert(HN:~Col O C1 C1').
{
intro.
unfold OS in H5.
ex_and H5 K.
unfold TS in H23.
spliter.
apply H23.
apply col_permutation_2.
apply (col_transitivity_1 _ C1).
intro.
subst C1.
treat_equalities.
apply H2.
Col.
ColR.
Col.
}

assert(HH:= midpoint_existence C1 C1').
ex_and HH M.

assert(HH:= l10_2_existence O M D1).
ex_and HH D1'.
unfold Reflect in H23.
induction H23.
spliter.
unfold ReflectL in H24.
spliter.
ex_and H24 N.

assert(Out O C1 D1).
{
apply (length_out O E E' P C P D).
intro.
subst C.
apply cong_identity in H16.
subst C1.
apply H2; Col.
intro.
subst D.
apply cong_identity in H13.
subst D1.
assert(AD=O).
{
apply (prod_uniqueness O E E' A1 O).
assumption.
apply prod_0_r.
unfold Prod in H8.
spliter.
unfold Ar2 in H8.
tauto.
Col.
}
subst AD.
induction H3.
induction H3.
apply H3.
exists A.
split; Col.
spliter.
apply H2.
ColR.
subst B; tauto.
assumption.
assumption.
}

(*********************)
assert(Out O A1 C1).
{
apply (length_out O E E' P A P C).
intro.
subst A.
apply cong_identity in H22.
subst A1.
apply H2; Col.
intro.
subst C.
apply cong_identity in H16.
subst C1.
unfold Out in H27.
tauto.
assumption.
assumption.
}
(*********************)

assert(M <> C1).
{
intro.
subst M.
eapply (symmetric_point_uniqueness _ _ C1) in H7.
subst C1'.
apply H2.
apply out_col.

apply(cong3_preserves_out O A1 C1 P A C H28).
unfold Cong_3 in *.
spliter.
repeat split; Cong.
apply l7_3_2.
}

assert(Per O M C1).
{
unfold Per.
exists C1'.
split.
assumption.
unfold Cong_3 in H4.
spliter.
apply (cong_transitivity _ _ P C); Cong.
}

apply per_perp_in in H30; auto.
apply perp_in_comm in H30.
apply perp_in_perp_bis in H30.


assert(Out O C1' D1').
{
apply(image_preserves_out O M O C1 D1).
assumption.
unfold Reflect.
left.
split; auto.
unfold ReflectL.
split.
exists O.
split; finish.
right.
auto.

unfold Reflect.
left.
split; auto.
unfold ReflectL.
split.
exists M.
split; finish.
left.
induction H30.
apply perp_sym.
apply perp_comm.
apply (perp_col _ M).
intro.
subst C1'.

apply l7_3 in H7.
contradiction.
finish.
unfold Midpoint in H7.
spliter.
finish.
apply perp_distinct in H30.
tauto.
unfold Reflect.
left.
split; auto.
unfold ReflectL.
split.
exists N.
split; finish.
left.
induction H25.
apply perp_right_comm.
assumption.
subst D1'.
apply l7_3 in H24.
subst D1.
induction H30.
apply perp_not_col in H24.
apply False_ind.
apply H24.
apply out_col in H27.
apply col_permutation_2.
apply (col_transitivity_1 _ N).
intro.
subst N.
apply cong_symmetry in H13.
apply cong_identity in H13.
subst D.
unfold Pj in H3.
induction H3.
induction H3.
apply H3.
exists A.
split; Col.
spliter.
apply H2.
ColR.
subst B.
tauto.
Col.
Col.
apply perp_distinct in H24.
tauto.
}

assert(Perp O N D1 N).
{
apply (perp_col O M D1 N).
intro.
subst N.
apply HN.
unfold Midpoint in H24.
spliter.
apply bet_col in H24.
apply out_col in H31.
apply out_col in H27.
eapply (col_transitivity_1 _ D1').
intro.
subst D1'.
apply cong_identity in H32.
subst D1.
treat_equalities.
induction H3.
induction H1.
apply H1.
exists A.
split; Col.
spliter.
apply H2.
ColR.
subst B.
tauto.
apply(col_transitivity_1 _ D1).
intro.
subst D1.
treat_equalities.
induction H3.
induction H1.
apply H1.
exists A.
split; Col.
spliter.
apply H2.
ColR.
subst B.
tauto.
Col.
Col.
ColR.
apply perp_sym.
apply (perp_col _ D1').
intro.
subst N.
unfold Midpoint in H24.
spliter.
treat_equalities.
apply HN.
apply out_col in H31.
apply out_col in H27.
apply (col_transitivity_1 _ D1).
intro.
subst D1.
treat_equalities.
induction H3.
induction H1.
apply H1.
exists A.
split; Col.
spliter.
apply H2.
ColR.
subst B.
tauto.
Col.
Col.
induction H25.
finish.
subst D1'.
apply l7_3 in H24.
subst N.
apply False_ind.
apply out_col in H31.
apply out_col in H27.
apply HN.
apply (col_transitivity_1 _ D1).
intro.
subst D1.
treat_equalities.
treat_equalities.
induction H3.
induction H1.
apply H1.
exists A.
split; Col.
spliter.
apply H2.
ColR.
subst B.
tauto.
Col.
Col.
unfold Midpoint in H24.
spliter.
apply bet_col in H24.
Col.
Col.
}
apply perp_left_comm in H32.

assert(Cong O D1 O D1').
{
apply perp_perp_in in H32.
apply perp_in_comm in H32.
apply perp_in_per in H32.
unfold Per in H32.
ex_and H32 D2.
assert(D2 = D1').
eapply (l7_9 _ _ N D1);
finish.
subst D2.
assumption.
}

assert(Pj C1 C1' D1 D1').
{
unfold Pj.
left.
induction H25; induction H30.
apply (l12_9 _ _ _ _ O M).
apply (perp_col _ M).
intro.
subst C1'.
apply HN.
Col.
finish.
unfold Midpoint in H7.
spliter.
finish.
finish.
apply perp_distinct in H30.
tauto.
subst D1'.
apply l7_3 in H24.
subst N.
apply perp_distinct in H32.
tauto.
subst D1'.
apply l7_3 in H24.
subst N.
apply perp_distinct in H32.
tauto.
}
assert(Cong_3 P C A O C1' A1).
{
unfold Cong_3 in *.
spliter.
repeat split; Cong.
}
assert(CongA P C A O C1' A1).
{
apply cong3_conga.
intro.
subst C.
apply H2.
Col.
intro.
subst C.
apply H2.
Col.
assumption.
}
unfold Cong_3 in H35.
spliter.
assert(Cong P A O A1 /\ (P <> A -> CongA C P A C1' O A1 /\ CongA C A P C1' A1 O)).
{
apply(l11_49 P C A O C1' A1); Cong.
}
spliter.
assert(P <> A).
{
intro.
subst A.
apply H2.
Col.
}
apply H40 in H41.
clear H40.
spliter.

assert(CongA C A P D B P).
{
induction(bet_dec C P D).
assert(Bet A P B).
apply(project_preserves_bet A P A C C P D).
assumption.
unfold Proj.
repeat split.
intro.
subst A.
apply H2.
Col.
intro.
subst C.
apply H2.
Col.
intro.
induction H43.
apply H43.
exists A.
split; Col.
spliter.
apply H2.
Col.
Col.
left.
apply par_left_comm.
apply par_reflexivity.
intro.
subst A.
apply H2.
Col.
unfold Proj.
repeat split.
intro.
subst A.
apply H2.
Col.
intro.
subst C.
apply H2.
Col.
intro.
induction H43.
apply H43.
exists A.
split; Col.
spliter.
apply H2.
Col.
Col.
right.
reflexivity.
unfold Proj.
repeat split.
intro.
subst A.
apply H2.
Col.
intro.
subst C.
apply H2.
Col.
intro.
induction H43.
apply H43.
exists A.
split; Col.
spliter.
apply H2.
Col.
Col.
left.
unfold Pj in H3.
induction H3.
apply par_symmetry.
apply par_right_comm.
assumption.
subst D.
apply False_ind.
apply H2.
ColR.

assert(CongA C A B D B A <-> Par A C B D).
apply(l12_21 A C B D).
unfold TS.
repeat split.
intro.
apply H2.
ColR.
intro.
apply H2.

assert(P <> D).
intro.
subst D.
induction H3.
induction H3.
apply H3.
exists A.
split; Col.
spliter.
apply H3.
apply (l6_21 P B A C); Col.
intro.
apply H2.
ColR.
subst B.
tauto.
ColR.

exists P.
split; Col.
destruct H44.
induction H3.
assert(HH3:=H3).
apply H45 in HH3.
apply(out_conga C A B D B A C P D P).
assumption.
apply out_trivial.
intro.
subst C.
apply H2.
Col.
repeat split.
intro.
subst B.
tauto.
intro.
subst A.
apply H2.
Col.
right.
assumption.
apply out_trivial.
intro.
subst D.
apply H2.
ColR.
repeat split.
assumption.
intro.
subst B.
apply H2.
tauto.
right; Between.
subst D.
apply False_ind.
apply H2.
ColR.

assert(Out P C D).
unfold Col in H1.
unfold Out.
repeat split.
intro.
subst C.
apply H42.
Between.
intro.
subst D.
apply H42.
Between.
induction H1.
left; assumption.
induction H1.
right; Between.
apply False_ind.
apply H42.
Between.

assert(Out P A B).
apply (project_preserves_out P C D  P A B  P A A C).
assumption.
intro.
induction H44.
apply H44.
exists C.
split; Col.
spliter.
contradiction.
unfold Proj.
repeat split.
intro.
subst A.
apply H2.
Col.
intro.
subst C.
apply H2.
Col.
intro.
induction H44.
apply H44.
exists A.
split; Col.
spliter.
contradiction.
Col.
right.
reflexivity.

unfold Proj.
repeat split.
intro.
subst A.
apply H2.
Col.
intro.
subst C.
apply H2.
Col.
intro.
induction H44.
apply H44.
exists A.
split; Col.
spliter.
contradiction.
Col.
left.
apply par_left_comm.
apply par_reflexivity.
intro.
subst C.
apply H2.
Col.
unfold Proj.
repeat split.
intro.
subst A.
apply H2; Col.
intro.
subst C.
apply H2; Col.
intro.
induction H44.
apply H44.
exists A.
split; Col.
spliter.
contradiction.
Col.
left.
induction H3.
apply par_left_comm.
apply par_symmetry.
assumption.
subst D.
apply False_ind.
apply H2.
ColR.

apply (l12_22 A C B D P).
assumption.
apply out_one_side.
left.
assumption.
assumption.
induction H3.
assumption.
subst D.
apply False_ind.
apply H2.
ColR.
}
assert(C <> A).
{
intro.
subst C.
unfold CongA in H42.
tauto.
}

assert(P <> A).
{
intro.
subst A.
unfold CongA in H42.
tauto.
}

assert(~Par P A C A).
{
intro.
induction H45.
apply H45.
exists A.
split; Col.
spliter.
apply H2.
Col.
}

assert(CongA C P A D P B).
{
induction(bet_dec C P D).

assert(Bet A P B).
apply (project_preserves_bet P A C A C P D A P B); auto.
repeat split; Col.
left.
right.
repeat split; Col.
repeat split; Col.
repeat split; Col.
unfold Pj in H3.
induction H3.
left.
finish.
right.
auto.
apply(l11_14 C P A D B); auto.
intro.
subst C.
unfold CongA in H36.
tauto.
intro.
subst D.
induction H3.
induction H3.
apply H3.
exists A.
split; Col.
spliter.
apply H2.
ColR.
subst B.
tauto.


assert(Out P C D).
apply(not_bet_out).
Col.
assumption.
assert(Out P A B).
apply(project_preserves_out P C D P A B P A C A).
repeat split.
intro.
subst C.
apply H46.
Between.
intro.
subst D.
apply H46.
Between.
unfold Out in H47.
spliter.
tauto.
intro.
induction H48.
apply H48.
exists C.
split; Col.
spliter.
apply H2.
Col.
repeat split; Col.
repeat split; Col.
left.
right.
repeat split; Col.
repeat split; Col.
left.
unfold Pj in H3.
induction H3.
finish.
subst D.
apply False_ind.
unfold CongA in H42.
tauto.

apply conga_sym.
apply(out_conga C P A C P A D B C A); finish.
apply conga_refl.
apply out_trivial.
unfold Out in H47.
tauto.
unfold Out in H48.
tauto.
apply out_trivial.
unfold Out in H47.
tauto.
}

assert(C1 <> C1').
{
intro.
subst C1'.
apply HN.
Col.
}

assert(O <> C1').
{
intro.
subst C1'.
unfold CongA in H36.
tauto.
}

assert(~Col O C1 C1').
{
intro.
induction H30.
apply perp_not_col in H30.
apply H30.
unfold Midpoint in H7.
spliter.
apply bet_col in H7.
ColR.
apply perp_distinct in H30.
tauto.
}
assert(~Par O C1' C1 C1').
{
intro.
induction H50.
apply H50.
exists C1'.
split; Col.
spliter.
contradiction.
}

assert(~Par O C1 C1 C1').
{
intro.
induction H51.
apply H51.
exists C1.
split; Col.
spliter.
contradiction.
}
assert(Out O C1' D1').
{
apply(project_preserves_out O C1 D1 O C1' D1' O C1' C1 C1'); auto.
repeat split; Col.
repeat split; Col.
left.
finish.
repeat split; Col.
left.
apply(l12_9 D1 D1' C1 C1' O M).
assert(Perp D1 D1' N O).
apply(perp_col D1 N N O D1').
intro.
subst D1'.
apply l7_3 in H24.
subst N.
apply perp_distinct in H32.
tauto.
finish.
unfold Midpoint in H24.
spliter.
apply bet_col in H24.
Col.
apply perp_sym.
apply(perp_col O N D1 D1' M).
assumption.
finish.
Col.
induction H30.
apply (perp_col C1 M O M C1'); finish.
unfold Midpoint in H7.
spliter.
apply bet_col in H7.
Col.
apply perp_distinct in H30.
tauto.
}
assert(CongA C1' O A1 D1' O B1).
{
apply(out_conga C1' O A1 C1' O A1 C1' A1 D1' B1); auto.
apply conga_refl.
auto.
intro.
subst A1.
unfold Out in H28.
tauto.
apply out_trivial.
auto.
apply out_trivial.
intro.
subst A1.
unfold Out in H28.
tauto.
apply(length_out O E E' P A  P B A1 B1); auto.
}
assert(CongA D1' O B1 D P B).
{
apply (conga_trans _ _ _ C P A).
apply (conga_trans _ _ _ C1' O A1).
apply conga_sym.
assumption.
apply conga_sym.
assumption.
assumption.
}
assert((D1' <> B1 -> CongA O D1' B1 P D B /\ CongA O B1 D1' P B D)).
{
apply (l11_49 D1' O B1 D P B).
assumption.
apply (cong_transitivity _ _ O D1); Cong.
assumption.
}

assert(D1' <> B1).
{
intro.
subst D1'.
induction H34.
induction H34.
apply H34.
exists C1.
split; Col.
ColR.
spliter.
apply H49.
ColR.
subst D1.
apply l7_3 in H24.
subst N.
apply perp_distinct in H32.
tauto.
}
apply H55 in H56.
spliter.
clear H55.
apply conga_comm in H57.

assert(CongA C1' A1 O D1' B1 O <-> Par A1 C1' B1 D1').
{
apply(l12_22 A1 C1' B1 D1' O).
apply (length_out O E E' P A P B); auto.
apply out_one_side.
left.
intro.
apply H49.
assert(A1 <> O).
intro.
subst A1.
unfold CongA in H53.
tauto.
ColR.
assumption.
}
destruct H55.
assert(Par A1 C1' B1 D1').
{
apply H55.
apply (conga_trans _ _ _ D B P).
apply (conga_trans _ _ _ C A P).
apply conga_sym.
assumption.
assumption.
apply conga_sym.
assumption.
}
clear H55 H58.
assert(Prod O C1 C1' A1 D1 B1).
{
unfold Prod.
repeat split.
assumption.
ColR.
ColR.
ColR.
exists D1'.
repeat split.
assumption.

apply out_col in H31.
ColR.
left.
finish.
}

assert(exists Y : Tpoint, Prod O E C1' A1 D1 Y /\ Prod O E C1' C1 B1 Y).
{
apply(prod_x_axis_unit_change O C1 C1' A1 D1 C1 B1 E).
repeat split; Col.
ColR.
ColR.
Col.
exists B1.
split; auto.
apply prod_1_l; Col.
ColR.
}
ex_and H58 Y.
assert(HH:=prod_y_axis_change O E C1' E' A1 D1 Y H58 H9).
{
assert(Y = AD).
apply(prod_uniqueness O E E' A1 D1); auto.
subst Y.
assert(HP:=prod_y_axis_change O E C1' E' C1 B1 AD H60 H9).
left.
assumption.
}
spliter.
subst M.
apply False_ind.
unfold Midpoint in H7.
spliter.
apply bet_col in H7.
Col.

right.
spliter.
split.
intro.
apply H8.
unfold Ar2 in H11.
spliter.
repeat split; Col.
unfold Length in H4.
tauto.
unfold Length in H7.
tauto.
unfold Length in H7.
tauto.
assumption.
Qed.
length_existence
Proof.
intros.
assert(NEO : E <> O).
intro.
subst E.
apply H.
Col.
assert(HH:= segment_construction_2 E O A B NEO).
ex_and HH AB.
exists AB.
unfold Length.
assert(AB = O \/ Out O E AB).
induction(eq_dec_points AB O).
left; assumption.
right.
repeat split; auto.
assert(Col O E AB).
induction H2.
subst AB.
Col.
apply out_col.
assumption.
repeat split; Col.
unfold LeP.
induction H2.
right; auto.
left.
unfold LtP.
exists AB.
repeat split.
apply diff_A_O; Col.
unfold Out in H2.
tauto.
auto.
induction H0.
right; assumption.
left; assumption.
Qed.
l15_7
Proof.
intros.

induction(eq_dec_points AB O).
(* AB = O *)
subst AB.
assert(A = B).
apply (length_id_1 O E E'); assumption.
subst B.
apply perp_in_distinct in H2.
tauto.

(* AB != O*)
assert(~Col O E E' /\ Col O E AB).
unfold Length in H3.
spliter.
unfold LeP in H8.
induction H8.
  (* Ltp O E E' O AB*)
unfold LtP in H8.
ex_and H8 X.
apply diff_sum in H8.
apply sum_ar2 in H8.
unfold Ar2 in H8.
tauto.
  (* O = AB *)
subst AB.
tauto.
spliter.

induction(eq_dec_points H A).
  (* H = A *)
subst H.
assert(AH=O).
apply (length_uniqueness O E E' A A); auto.
apply length_id_2.
assumption.
subst AH.
apply perp_in_per in H2.
assert(A = C).
apply (l8_7 B);
finish.
subst C.
assert(AC = O).
apply (length_uniqueness O E E' A A); auto.
subst AC.
split;intros;
assert(AC2=O).
apply (prod_uniqueness O E E' O O); auto.
apply prod_0_r; Col.
subst AC2.
apply prod_0_r; Col.
apply (prod_uniqueness O E E' AB O); auto.
apply prod_0_r; Col.
subst AC2.
apply prod_0_r; Col.


  (* H !=A *)
assert(C <> A).
intro.
subst C.
apply perp_in_right_comm in H2.
apply perp_in_id in H2.
contradiction.

assert(HH:= segment_construction_2 H A A C H9).
ex_and HH C'.
assert(Out A H C').
unfold Out.
repeat split; auto.
intro.
subst C'.
apply cong_symmetry in H12.
apply cong_identity in H12.
subst C.
tauto.

assert(HH:= segment_construction_2 C A A H H10).
ex_and HH H'.
assert(Out A C H').
repeat split;auto.
intro.
subst H'.
apply cong_symmetry in H15.
apply cong_identity in H15.
subst H.
tauto.

assert(H <> C).
intro.
subst H.
apply perp_in_distinct in H2.
tauto.

assert(Cong H C H' C' /\ (H <> C -> CongA A H C A H' C' /\ CongA A C H A C' H')).
apply(l11_49 H A C H' A C').
apply (l11_10 H A C C A H).
apply conga_right_comm.
apply conga_refl; auto.
apply out_trivial; auto.
apply out_trivial; auto.
apply l6_6.
assumption.
apply l6_6.
assumption.
Cong.
Cong.
spliter.
assert(HH:= H19 H17).
clear H19.
spliter.

assert(Per A H C).
apply perp_in_per.
apply perp_in_comm.
apply perp_perp_in.
apply perp_comm.
apply (perp_col  _ B).
auto.
apply perp_in_perp_bis in H2.
induction H2.
  (* Perp H H A B *)
apply perp_distinct in H2.
tauto.
  (* Perp C H A B *)
apply perp_sym.
apply perp_left_comm.
assumption.
apply perp_in_col in H2.
tauto.

assert(HH:= l11_17 A H C A H' C' H21 H19).
assert(Par C B H' C').
apply(l12_9 C B H' C' A C).
apply per_perp_in in H1.
apply perp_in_comm in H1.
apply perp_in_perp_bis in H1.
induction H1.
  (* Perp C A B C *)
finish.
  (* Perp C C B C *)
apply perp_distinct in H1.
tauto.
auto.
intro.
subst C.
apply perp_in_id in H2.
contradiction.
apply per_perp_in in HH.
apply perp_in_comm in HH.
apply perp_in_perp_bis in HH.
apply perp_sym.
apply perp_right_comm.
apply(perp_col A H' C' H' C).
auto.
induction HH.
    (* Perp H' A C' H' *)
finish.
    (* Perp H' H' C' H' *)
apply perp_distinct in H22.
tauto.
apply out_col in H16.
Col.
intro.
subst H'.
apply conga_distinct in H19.
tauto.
intro.
subst H'.
apply conga_distinct in H19.
tauto.

assert(HL1:=length_existence O E E' A H' H7).
ex_and HL1 AH'.
assert(HL1:=length_existence O E E' A C' H7).
ex_and HL1 AC'.
assert(exists P : Tpoint, Prod O E E' AC' AC P).

apply(prod_exists O E E' H7 AC' AC).
unfold Length in H24.
tauto.
unfold Length in H4.
tauto.
ex_and H25 P.

assert(Perp C H A B).
apply perp_in_perp_bis in H2.
induction H2.
  (* Perp H H A B *)
apply perp_distinct in H2.
tauto.
  (* Perp C H A B *)
assumption.

assert(Prodg O E E' AH' AB P).
apply(thales O E E' A C' B H' C  AC' AB AH' AC   P); Col.
apply perp_in_col in H2.
spliter.

apply out_col in H13.
ColR.
apply out_col in H16.
Col.
intro.
assert(Perp H A C H).
apply perp_comm.
apply(perp_col A B H C H).
intro.
subst H.
apply conga_distinct in H19.
tauto.
finish.
apply perp_in_col in H2.
tauto.
apply perp_not_col in H28.
apply H28.
assert(A <> C').
intro.
subst C'.
unfold CongA in H20.
tauto.
assert(Col A H H').
ColR.
assert(A <> H').
intro.
subst H'.
unfold CongA in H19.
tauto.
ColR.

left.
finish.
left.
assumption.

assert(Prod O E E' AH' AB P).
induction H27.
assumption.
spliter.
apply False_ind.
apply H27.
repeat split; Col.
unfold Length in H23.
tauto.


assert(Length O E E' A H' AH).
apply(length_eq_cong_2 O E E' A H A H' AH H5).
Cong.
assert(AH = AH').
apply (length_uniqueness O E E' A H'); auto.
subst AH'.

assert(Length O E E' A C' AC).
apply(length_eq_cong_2 O E E' A C A C' AC H4).
Cong.
assert(AC = AC').
apply (length_uniqueness O E E' A C'); auto.
subst AC'.

split.
intro.
assert(P = AC2).
apply (prod_uniqueness O E E' AC AC); auto.
subst P.
apply prod_comm.
assumption.

intro.
assert(P = AC2).
apply (prod_uniqueness O E E' AB AH); auto.
apply prod_sym.
assumption.
subst P.
assumption.
Qed.
l15_7_1
Proof.
intros.
destruct(l15_7 O E E' A B C H AB AC AH AC2 H0 H1 H2 H3 H4 H5).
apply H7.
assumption.
Qed.
l15_7_2
Proof.
intros.
destruct(l15_7 O E E' A B C H AB AC AH AC2 H0 H1 H2 H3 H4 H5).
apply H8.
assumption.
Qed.
length_sym
Proof.
intros.
unfold Length in *.
spliter.
repeat split; auto.
Cong.
Qed.
pythagoras
Proof.
intros.
assert(~Col O E E' /\ Col O E AB2 /\ Col O E AC2 /\ Col O E BC).
unfold Prod in *.
spliter.
unfold Ar2 in H4 ,H5 ,H6.
repeat split; tauto.
spliter.

induction(Col_dec A C B).
(* Col A C B *)
assert(HH:=l8_9 A C B H0 H11).
induction HH.
(* A = C *)
subst C.
assert(AB = BC).
apply(length_uniqueness O E E' A B).
assumption.
apply length_sym.
assumption.
subst BC.
assert(AB2 = BC2).
apply(prod_uniqueness O E E' AB AB); auto.
subst BC2.

assert(AC = O).
apply(length_uniqueness O E E' A A).
assumption.
apply length_id_2; assumption.
subst AC.
assert(AC2=O).
apply(prod_uniqueness O E E' O O).
assumption.
apply prod_0_l; Col.
subst AC2.
apply sum_O_B; Col.

(* B = C *)
subst C.
assert(AB = AC).
apply(length_uniqueness O E E' A B).
assumption.
assumption.
subst AC.
assert(AB2 = AC2).
apply(prod_uniqueness O E E' AB AB); auto.
subst AC2.

assert(BC = O).
apply(length_uniqueness O E E' B B).
assumption.
apply length_id_2; assumption.
subst BC.
assert(BC2=O).
apply(prod_uniqueness O E E' O O).
assumption.
apply prod_0_l; Col.
subst BC2.
apply sum_A_O; Col.


(* ~Col A C B *)
assert(exists X : Tpoint, Col A B X /\ Perp A B C X).
apply(l8_18_existence A B C); Col.
ex_and H12 P.
assert(Perp_at P A B C P).
apply(l8_14_2_1b_bis A B C P P H13); Col.
assert(Bet A P B /\ A <> P /\ B <> P).
apply(l11_47 A B C P H0).
finish.
spliter.

assert(HL1:= length_existence O E E' A P H7).
assert(HL2:= length_existence O E E' B P H7).
ex_and HL1 AP.
ex_and HL2 BP.

assert(Sum O E E' AP BP AB).
apply(triangular_equality_bis O E E' A P B AP BP AB); auto.
apply length_sym.
assumption.

assert(Prod O E E' AB AP AC2).
apply(l15_7_1 O E E' A B C P AB AC AP AC2 H H0); finish.

assert(Prod O E E' AB BP BC2).
eapply(l15_7_1 O E E' B A C P AB BC); finish.
apply length_sym;auto.

assert(HD:=distr_l O E E' AB AP BP AB AC2 BC2 AB2 H20 H21 H22 H6).
assumption.
Qed.
is_length_exists
Proof.
intros O E E' X Y HNC.
elim (eq_dec_points X Y); intro HXY;
[treat_equalities; exists O; left; apply length_id_2; assert_diffs; auto|
destruct (length_existence O E E' X Y) as [XY HLength]; Col; exists XY; left; auto].
Qed.
grid_exchange_axes
Proof.
intros O E S U1 U2 HCs.
destruct HCs as [HDiff [HCong1 [HCong2 HPer]]].
repeat (split; Perp).
Qed.
Cs_not_Col
Proof.
unfold Cs; intros O E S U1 U2 HCs.
spliter; assert_diffs; apply per_not_col; Perp.
Qed.
exists_grid
Proof.
destruct lower_dim_ex as [O [I [X HNC]]].
assert (H : ~ Col O I X) by auto; clear HNC; rename H into HNC.
assert_diffs; destruct (ex_per_cong I O O X O I) as [J HJ]; Col; spliter.
exists O; exists I; exists X; exists O; exists I; exists J.
repeat (split; finish).
Qed.
exists_grid_spec
Proof.
assert (~ Col PA PB PC) by (apply lower_dim).
assert_diffs.
destruct (ex_per_cong PB PA PA PC PA PB) as [J HJ]; Col; spliter.
exists PA; exists PB; exists J.
repeat (split; finish).
Qed.
coord_exchange_axes
Proof.
intros O E S U1 U2 P X Y HCd.
destruct HCd as [HCs [H [HPX HPY]]]; clear H.
split; try (apply grid_exchange_axes; auto).
split; try apply all_coplanar.
split; auto.
Qed.
Cd_Col
Proof.
unfold Cd; unfold Projp; intros O E S U1 U2 P X Y HCd.
destruct HCd as [HCs [HC [[PX HPX] [PY HPY]]]]; clear HC.
destruct HPX as [[HDiff1 HElim1] HCong1]; destruct HPY as [[HDiff2 HElim2] HCong2].
split; [apply l4_13 with S U1 PX|apply l4_13 with S U2 PY]; Cong;
[induction HElim1|induction HElim2]; spliter; treat_equalities; Col.
Qed.
exists_projp
Proof.
intros A B P HAB.
elim (Col_dec A B P); intro HNC; [exists P; split; Col; right|].
destruct (l8_18_existence A B P HNC) as [P' HP'].
exists P'; split; Col.
Qed.
exists_coord
Proof.
intros O E S U P HSU HCong.
destruct (exists_projp S U P HSU) as [PX Hprojp].
assert (HCol : Col S U PX)
  by (destruct Hprojp as [H' H]; induction H; spliter; treat_equalities; Col).
destruct (l4_14 S U PX O E) as [X HCong']; Cong.
exists PX; exists X; auto with cong.
Qed.
coordinates_of_point
Proof.
intros O E S U1 U2 P HCs.
assert (H := HCs); destruct H as [HDiff [HCong1 [HCong2 H]]]; clear H.
assert (HSU1 : S <> U1) by (assert_diffs; auto).
assert (HSU2 : S <> U2) by (assert_diffs; auto).
destruct (exists_coord O E S U1 P HSU1 HCong1) as [PX [X HX]].
destruct (exists_coord O E S U2 P HSU2 HCong2) as [PY [Y HY]].
exists X; exists Y; split; auto.
split; try (apply all_coplanar).
split; [exists PX|exists PY]; auto.
Qed.
point_of_coordinates_origin
Proof.
intros O E S U1 U2 HCs.
split; auto.
split; try apply all_coplanar.
destruct HCs as [HDiff [HCong1 [HCong2 H]]]; clear H.
assert_diffs; split; exists S; repeat (split; Col; Cong).
Qed.
point_of_coordinates_on_an_axis
Proof.
intros O E S U1 U2 X HCs HCol HOX.
assert (H := HCs); destruct H as [HDiff [HCong1 [HCong2 H]]]; clear H.
destruct (l4_14 O E X S U1 HCol HCong1) as [P HP].
exists P; split; auto.
destruct HCs as [H [H' [H'' HPer]]]; clear H; clear H'; clear H''.
split; try apply all_coplanar.
assert_diffs; split; [exists P|exists S]; repeat (split; Cong);
[right; split; try apply l4_13 with O E X; Col|].
left; split; Col.
apply per_perp in HPer; auto.
apply perp_col0 with S U1; Col; Perp;
[unfold Cong_3 in *; spliter; assert_diffs|apply l4_13 with O E X]; Col.
Qed.
point_of_coordinates
Proof.
intros O E S U1 U2 X Y HCs HCol1 HCol2.
elim (eq_dec_points O X); intro HOX; elim (eq_dec_points O Y); intro HOY;
treat_equalities; [exists S; apply point_of_coordinates_origin|
                   destruct (point_of_coordinates_on_an_axis O E S U2 U1 Y) as [P HP];
                   try apply grid_exchange_axes;
                   try (exists P; apply coord_exchange_axes)|
                   apply point_of_coordinates_on_an_axis|]; auto.
assert (H := HCs); destruct H as [HDiff [HCong1 [HCong2 H]]]; clear H.
destruct (l4_14 O E X S U1 HCol1 HCong1) as [PX HPX].
destruct (l4_14 O E Y S U2 HCol2 HCong2) as [PY HPY].
destruct (perp_exists PX S U1) as [PX' HPerp1]; [assert_diffs; auto|].
destruct (perp_exists PY S U2) as [PY' HPerp2]; [assert_diffs; auto|].
assert (HPerp3 : Perp PX PX' PY PY').
  {
  apply par_perp_perp with S U2; Perp.
  apply l12_9 with S U1; Perp.
  destruct HCs as [H [H' [H'' HPer]]]; clear H; clear H'; clear H''.
  assert_diffs; apply per_perp in HPer; Perp.
  }
assert (H := HPerp3); destruct H as [P HP]; exists P; split; auto.
split; try apply all_coplanar.
split; [exists PX|exists PY]; split; Cong.

  {
  assert_diffs; split; auto.
  left; split; [apply l4_13 with O E X; Col|].
  unfold Perp_at in *; spliter; apply perp_col0 with PX PX'; Col.
  assert (HPYS : PY <> S) by (unfold Cong_3 in *; spliter; assert_diffs; auto).
  intro; treat_equalities; apply HPYS.
  apply l6_21 with S U1 U2 S; Col;
  [destruct HCs as [H' [H'' [H''' HPer]]]; apply perp_not_col;
   assert_diffs; apply per_perp in HPer; Perp|
  |apply l4_13 with E O Y; try apply cong_3_swap; Col].
  assert (HPar : Par S U1 PY PY')
    by (apply l12_9 with P PX'; Perp).
  elim HPar; clear HPar; intro HParS; [|spliter; ColR].
  exfalso; apply HParS; exists P; split; Col.
  apply l4_13 with X O E; try (apply cong_3_swap; apply cong_3_swap_2); Col.
  }

  {
  assert_diffs; split; auto.
  left; split; [apply l4_13 with O E Y; Col|].
  unfold Perp_at in *; spliter; apply perp_col0 with PY PY'; Col.
  assert (HPXS : PX <> S) by (unfold Cong_3 in *; spliter; assert_diffs; auto).
  intro; treat_equalities; apply HPXS.
  apply l6_21 with S U2 U1 S; Col;
  [destruct HCs as [H' [H'' [H''' HPer]]]; apply perp_not_col;
   assert_diffs; apply per_perp in HPer; Perp|
  |apply l4_13 with E O X; try apply cong_3_swap; Col].
  assert (HPar : Par S U2 PX PX')
    by (apply l12_9 with P PY'; Perp).
  elim HPar; clear HPar; intro HParS; [|spliter; ColR].
  exfalso; apply HParS; exists P; split; Col.
  apply l4_13 with Y O E; try (apply cong_3_swap; apply cong_3_swap_2); Col.
  }
Qed.
eq_points_coordinates
Proof.
intros O E S U1 U2 P1 X1 Y1 P2 X2 Y2 HCd1 HCd2.
split; intro; spliter; treat_equalities.

  {
  destruct HCd1 as [HCs [H [[PX HPX1] [PY HPY1]]]]; clear H.
  destruct HCd2 as [H [H' [[PX2 HPX2] [PY2 HPY2]]]]; clear H; clear H'.
  assert (PX = PX2) by (spliter; apply projp_id with P1 S U1; auto); treat_equalities;
  assert (PY = PY2) by (spliter; apply projp_id with P1 S U2; auto); treat_equalities.
  destruct HPX1 as [H HCong1]; assert (H' : Col PX S U1)
    by (destruct H as [H' H]; induction H; spliter; treat_equalities; Col).
  clear H; assert (HCol1 : Col O E X1) by (apply l4_13 with S U1 PX; Col; Cong).
  clear H'; destruct HPX2 as [H HCong3]; clear H.
  destruct HPY1 as [H HCong2]; assert (H' : Col PY S U2)
    by (destruct H as [H' H]; induction H; spliter; treat_equalities; Col).
  clear H; assert (HCol2 : Col O E Y1) by (apply l4_13 with S U2 PY; Col; Cong).
  clear H'; destruct HPY2 as [H HCong4]; clear H.
  split; apply l4_18 with O E; Col;
  try (intro; treat_equalities; unfold Cs in HCs; spliter; intuition);
  unfold Cong_3 in *; spliter; eapply cong_transitivity; eCong.
  }

  {
  destruct HCd1 as [HCs [H [[PX HPX1] [PY HPY1]]]]; clear H.
  destruct HCd2 as [H [H' [[PX2 HPX2] [PY2 HPY2]]]]; clear H; clear H'.
  assert (PX = PX2); treat_equalities.
    {
    destruct HPX1 as [[H HElim] H0]; unfold Cs in HCs; unfold Cong_3 in *;
    spliter; assert_diffs; apply l4_18 with S U1; auto.
    induction HElim; spliter; treat_equalities; Col.
    apply cong_transitivity with O X1; Cong.
    apply cong_transitivity with E X1; Cong.
    }
  assert (PY = PY2); treat_equalities.
    {
    destruct HPY1 as [[H HElim] H0]; unfold Cs in HCs; unfold Cong_3 in *;
    spliter; assert_diffs; apply l4_18 with S U2; auto.
    induction HElim; spliter; treat_equalities; Col.
    apply cong_transitivity with O Y1; Cong.
    apply cong_transitivity with E Y1; Cong.
    }
  destruct HPX1 as [HProjp1 H]; clear H; destruct HPX2 as [HProjp2 H]; clear H;
  destruct HPY1 as [HProjp3 H]; clear H; destruct HPY2 as [HProjp4 H]; clear H.
  assert (HCol1 : Col PX P1 P2) by (apply projp2_col with S U1; auto).
  assert (HCol2 : Col PY P1 P2) by (apply projp2_col with S U2; auto).
  elim (eq_dec_points P1 P2); intro HP1P2; treat_equalities; auto; exfalso.
  assert (HPar : Par S U1 S U2).
    {
    elim (eq_dec_points P1 PX); intro HP1PX;
    elim (eq_dec_points P1 PY); intro HP1PY; treat_equalities.

      {
      destruct HProjp2 as [H H1]; clear H; elim H1; clear H1; intro H1;
      [destruct H1 as [H1 HPerp1]|spliter; intuition].
      destruct HProjp4 as [H H2]; clear H; elim H2; clear H2; intro H2;
      [destruct H2 as [H2 HPerp2]|spliter; intuition].
      apply l12_9 with P2 P1; Perp.
      }

      {
      destruct HProjp2 as [H H1]; clear H; elim H1; clear H1; intro H1;
      [destruct H1 as [H1 HPerp1]|spliter; intuition].
      destruct HProjp3 as [H H2]; clear H; elim H2; clear H2; intro H2;
      [destruct H2 as [H2 HPerp2]|spliter; intuition].
      apply l12_9 with P2 P1; Perp.
      apply perp_col0 with P1 PY; Perp; Col.
      }

      {
      destruct HProjp1 as [H H1]; clear H; elim H1; clear H1; intro H1;
      [destruct H1 as [H1 HPerp1]|spliter; intuition].
      destruct HProjp4 as [H H2]; clear H; elim H2; clear H2; intro H2;
      [destruct H2 as [H2 HPerp2]|spliter; intuition].
      apply l12_9 with P2 P1; Perp.
      apply perp_col0 with P1 PX; Perp; Col.
      }

      {
      destruct HProjp1 as [H H1]; clear H; elim H1; clear H1; intro H1;
      [destruct H1 as [H1 HPerp1]|spliter; intuition].
      destruct HProjp3 as [H H2]; clear H; elim H2; clear H2; intro H2;
      [destruct H2 as [H2 HPerp2]|spliter; intuition].
      apply l12_9 with P2 P1;
      [apply perp_col0 with P1 PX|apply perp_col0 with P1 PY];Perp; Col.
      }
    }
  assert (HFalse : ~ ~ Col U1 S U2).
    {
    intro HF; apply HF;
    elim HPar; clear HPar; intro HPar; spliter; Col.
    exfalso; apply HPar; exists S; Col.
    }
  unfold Cs in HCs; spliter; assert_diffs; apply HFalse; apply per_not_col; Col.
  }
Qed.
l16_9_1
Proof.
intros O E E' X Y XY XMY HCol1 HCol2 HXY HLe1 HXMY.
assert (HNC : ~ Col O E E')
  by (apply diff_ar2 in HXMY; unfold Ar2 in *; spliter; Col).
assert (HOE : O <> E) by (assert_diffs; auto).
assert (HCol3 : Col O E XMY).
  {
  unfold Diff, Opp, Sum, Ar2 in *;
  destruct HXMY as [MB [H1 [H2 [H3 H4]]]];
  spliter; Col.
  }
assert (HCong1 := HXMY); apply diff_sum in HCong1; apply l15_3 in HCong1.
elim HXY; clear HXY; intro HXY; [|spliter; intuition].
destruct HXY as [H [HCol4 [HLe2 HCong2]]].
elim (l7_20 O XY XMY); [auto|intro HMid; clear H|ColR|apply cong_transitivity with X Y; Cong].
elim HLe1; clear HLe1; intro HLt1; [clear HCong1|treat_equalities; auto].
elim HLe2; clear HLe2; intro HLt2; [clear HCong2|treat_equalities; auto].
exfalso; apply not_pos_and_neg with O E XMY;
split; [apply lt_diff_ps with E' X Y; auto|].
apply pos_opp_neg with E' XY; [apply ltP_pos with E'; auto|].
apply midpoint_opp; repeat (Col; split).
Qed.
length_eq_or_opp
Proof.
intros O E E' A B L1 L2 HL1 HL2.
assert (HNC : ~ Col O E E') by (apply diff_ar2 in HL2; unfold Ar2 in *; spliter; Col).
assert (HColA : Col O E A) by (apply diff_ar2 in HL2; unfold Ar2 in *; spliter; Col).
assert (HColB : Col O E B) by (apply diff_ar2 in HL2; unfold Ar2 in *; spliter; Col).
elim (col_2_le_or_ge O E E' A B); auto; intro HLe;
[right|left; apply l16_9_1 with O E E' A B; auto; left; auto].
apply diff_opp with B A; auto.
destruct (diff_exists O E E' B A) as [D HD]; Col.
assert (L1 = D)
  by (apply l16_9_1 with O E E' B A; auto; left; apply length_sym; auto).
treat_equalities; auto.
Qed.
l16_9_2
Proof.
intros O E E' X Y XY XMY XY2 XMY2 HCol1 HCol2 HXY HXMY HXY2 HXMY2.
assert (HNC : ~ Col O E E')
  by (apply diff_ar2 in HXMY; unfold Ar2 in *; spliter; Col).
assert (H:= HXY); elim H; clear H; intro HXY'; [|spliter; assert_diffs; intuition].
elim (length_eq_or_opp O E E' X Y XY XMY); auto; intro HOpp1; treat_equalities;
apply prod_uniqueness with O E E' XY XY; auto.
destruct (opp_exists O E E' HNC E) as [ME HOpp2]; Col.
apply prod_assoc1 with XMY ME XMY; auto; [|apply prod_comm];
apply opp_prod;auto; apply opp_comm; Col.
Qed.
cong_3_2_cong_4
Proof.
intros O E I J S U X Y HOE HCol1 HCol2 HCong1 HCong4.
destruct HCong1 as [HCong1 [HCong2 HCong3]].
destruct HCong4 as [HCong4 [HCong5 HCong6]].
repeat (split; Cong).
apply l4_16 with O E S U; Col.
repeat (split; Cong).
Qed.
cong_3_3_cong_5:
Proof.
intros O E I J K S U X Y Z HOE HCol1 HCol2 HCol3 HCong1 HCong4 HCong7.
destruct HCong1 as [HCong1 [HCong2 HCong3]].
destruct HCong4 as [HCong4 [HCong5 HCong6]].
destruct HCong7 as [HCong7 [HCong8 HCong9]].
repeat (split; Cong);
apply l4_16 with O E S U; Col; repeat (split; Cong).
Qed.
square_distance_formula_aux
Proof.
intros O E E' S U1 U2 P PX PY Q QX PXQX.
intros HCd1 HCd2 HDiff  HNC HCol1 HCol2 HCol3 HCs HPXQX.
apply length_eq_cong_2 with PX QX; auto; clear HPXQX.
destruct HCd1 as [H [H' [HPX' HPY']]]; clear H; clear H'.
destruct HPX' as [PX' [HProjp1 HCong1]]; destruct HPY' as [PY' [HProjp2 HCong2]].
destruct HCd2 as [H [H' [HQX' HQY']]]; clear H; clear H'.
destruct HQX' as [QX' [HProjp3 HCong3]]; destruct HQY' as [QY' [HProjp4 HCong4]].
assert (PY' = QY')
  by (assert_diffs; apply col_cong_3_cong_3_eq with O E PY S U2; auto).
treat_equalities;
assert (HPerp1 : Perp P Q S U2) by (apply projp_projp_perp with PY'; auto).
assert (HPerp2 : Perp U1 S S U2)
  by (unfold Cs in HCs; spliter; assert_diffs; apply per_perp; Perp).
destruct HProjp1 as [H H1]; clear H; destruct HProjp3 as [H H2]; clear H.
elim H1; clear H1; intro H1; elim H2; clear H2; intro H2;
destruct H1 as [HCol5 HPerp3]; destruct H2 as [HCol6 HPerp4]; treat_equalities.

  {
  elim (eq_dec_points S PX'); intro HDiff1;
  elim (eq_dec_points S QX'); intro HDiff2; treat_equalities.

    {
    exfalso; unfold Cong_3 in *; spliter; treat_equalities.
    assert (HPar1 : Par P Q S U1)
      by (apply l12_9 with S U2; Perp).
    assert (HPar2 : Par P S Q S)
      by (apply l12_9 with S U1; Perp).
    elim HPar2; clear HPar2; intro HCol1; [apply HCol1; exists S; Col|].
    elim HPar1; clear HPar1; intro HCol2; [apply HCol2; exists S; spliter; Col|].
    spliter; apply perp_not_col2 in HPerp3;
    elim HPerp3; intro HNC'; apply HNC'; Col.
    }

    {
    assert (O = PX) by (unfold Cong_3 in HCong1; spliter; treat_equalities; auto).
    treat_equalities; assert (HCol7 : Col S U2 P).
      {
      assert (H : Par P S S U2)
        by (apply l12_9 with S U1; Perp).
      elim H; clear H; intro H; [exfalso; apply H; exists S|spliter]; Col.
      }
    assert (HNC' : ~ Col S U1 U2) by (apply perp_not_col; Perp).
    assert (H : Rectangle P S QX' Q).
      {
      apply perp_3_rect; try (intro; assert_diffs; apply HNC'; ColR);
      [apply perp_col0 with S U1|apply perp_sym; apply perp_col0 with S U1|];
      Col; Perp.
      apply perp_sym; apply par_perp_perp with S U1; Perp.
      apply l12_9 with S U2; Perp.
      }
    apply Rectangle_Plg in H; apply plg_to_parallelogram in H;
    apply plg_cong_2 in H.
    unfold Cong_3 in HCong3; spliter; apply cong_transitivity with S QX'; Cong.
    }

    {
    assert (O = QX) by (unfold Cong_3 in HCong3; spliter; treat_equalities; auto).
    treat_equalities; assert (HCol7 : Col S U2 Q).
      {
      assert (H : Par Q S S U2)
        by (apply l12_9 with S U1; Perp).
      elim H; clear H; intro H; [exfalso; apply H; exists S|spliter]; Col.
      }
    assert (HNC' : ~ Col S U1 U2) by (apply perp_not_col; Perp).
    assert (H : Rectangle Q S PX' P).
      {
      apply perp_3_rect; try (intro; assert_diffs; apply HNC'; ColR);
      [apply perp_col0 with S U1|apply perp_sym; apply perp_col0 with S U1|];
      Col; Perp.
      apply perp_sym; apply par_perp_perp with S U1; Perp.
      apply l12_9 with S U2; Perp.
      }
    apply Rectangle_Plg in H; apply plg_to_parallelogram in H;
    apply plg_cong_2 in H.
    unfold Cong_3 in HCong1; spliter; apply cong_transitivity with S PX'; Cong.
    }

    {
    elim (eq_dec_points S PY'); intro HDiff3; treat_equalities.

      {
      assert (HNC' := HPerp3); apply perp_not_col2 in HNC'.
      elim HNC'; clear HNC'; intro HNC'; [exfalso; apply HNC'|intuition].
      destruct HProjp2 as [H' H]; clear H'.
      elim H; clear H; intro H; [|spliter; subst; Col].
      destruct H as [H HPerp5]; clear H.
      assert (HPar : Par P S S U1)
        by (apply l12_9 with S U2; Perp).
      elim HPar; clear HPar; intro HPar;
      [exfalso; apply HPar; exists S|spliter]; Col.
      }

      {
      assert (HNC' : ~ Col S U1 U2) by (apply perp_not_col; Perp).
      assert (HCol7 : Col S U1 PX') by (apply l4_13 with O E PX; Col).
      assert (HCol8 : Col S U2 PY') by (apply l4_13 with O E PY; Col).
      assert (HCol9 : Col S U1 QX') by (apply l4_13 with O E QX; Col).
      assert (HDiff4 : P <> PY').
        {
        intro; treat_equalities; apply HDiff1.
        assert_diffs; apply l6_21 with S U1 U2 S; Col.
        assert (HPar : Par P PX' S U2)
          by (apply l12_9 with S U1; Perp).
        elim HPar; clear HPar; intro HPar;
        [exfalso; apply HPar; exists P|]; spliter; Col.
        }
      assert (HDiff5 : Q <> PY').
        {
        intro; treat_equalities; apply HDiff2.
        assert_diffs; apply l6_21 with S U1 U2 S; Col.
        assert (HPar : Par Q QX' S U2)
          by (apply l12_9 with S U1; Perp).
        elim HPar; clear HPar; intro HPar;
        [exfalso; apply HPar; exists Q|]; spliter; Col.
        }
      assert (HRect1 : Rectangle PX' S PY' P).
        {
        apply perp_3_rect; try (intro; assert_diffs; apply HNC'; ColR).

          {
          apply perp_col0 with S U2; Col.
          apply perp_col0 with S U1; Col; Perp.
          }

          {
          apply perp_col0 with P Q; try (apply perp_col0 with S U2); Col; Perp.
          apply col_permutation_1; apply projp2_col with S U2; auto.
          }

          {
          apply par_perp_perp with S U1; Perp.
          apply l12_9 with S U2; Perp.
          apply perp_sym; apply perp_col0 with P Q; Col.
          apply col_permutation_1; apply projp2_col with S U2; auto.
          }
        }
      assert (HRect2 : Rectangle QX' S PY' Q).
        {
        apply perp_3_rect; try (intro; assert_diffs; apply HNC'; ColR).

          {
          apply perp_col0 with S U2; Col.
          apply perp_col0 with S U1; Col; Perp.
          }

          {
          apply perp_col0 with P Q; try (apply perp_col0 with S U2); Col; Perp.
          apply col_permutation_1; apply projp2_col with S U2; auto.
          }

          {
          apply par_perp_perp with S U1; Perp.
          apply l12_9 with S U2; Perp.
          apply perp_sym; apply perp_col0 with P Q; Col.
          apply col_permutation_1; apply projp2_col with S U2; auto.
          }
        }
      assert (HRect3 : Rectangle P PX' QX' Q)
        by (apply rect_2_rect with S PY'; try apply rect_permut; auto).
      apply Rectangle_Parallelogram in HRect3; apply plg_cong_2 in HRect3.
      assert_diffs;
      apply cong_3_2_cong_4 with O E PX QX S U1 PX' QX' in HCong1; Col.
      unfold Cong_4 in HCong1; spliter; apply cong_transitivity with PX' QX'; Cong.
      }
    }
  }

  {
  exfalso; elim (perp_not_col2 S U1 P PX'); Perp; intro H; apply H; Col; clear H.
  assert (HPar : Par P Q S U1) by (apply l12_9 with S U2; Perp).
  elim HPar; clear HPar; intro HPar; spliter; Col.
  exfalso; apply HPar; exists Q; Col.
  }

  {
  exfalso; elim (perp_not_col2 S U1 Q QX'); Perp; intro H; apply H; Col; clear H.
  assert (HPar : Par P Q S U1) by (apply l12_9 with S U2; Perp).
  elim HPar; clear HPar; intro HPar; spliter; Col.
  exfalso; apply HPar; exists P; Col.
  }

  {
  assert (Cong_4 O E PX QX S U1 P Q) by (assert_diffs; apply cong_3_2_cong_4; Col).
  unfold Cong_4 in *; spliter; Cong.
  }
Qed.
square_distance_formula
Proof.
intros O E E' S U1 U2 P Q PX PY QX QY PQ PQ2 PXMQX PYMQY PXMQX2 PYMQY2 F.
intros HCd1 HCd2 HPQ HPQ2 HPXMQX HPXMQX2 HPYMQY HPYMQY2 HF.
assert (HNC : ~ Col O E E')
  by (apply diff_ar2 in HPXMQX; unfold Ar2 in *; spliter; Col).
assert (HCol1 : Col O E PX) by (apply Cd_Col in HCd1; spliter; Col).
assert (HCol2 : Col O E QX) by (apply Cd_Col in HCd2; spliter; Col).
assert (HCol3 : Col O E PY) by (apply Cd_Col in HCd1; spliter; Col).
assert (HCol4 : Col O E QY) by (apply Cd_Col in HCd2; spliter; Col).
destruct (is_length_exists O E E' PX QX) as [PXQX HPXQX]; Col.
assert (HCol5 : Col O E PXQX).
  {
  unfold Is_length, Length in HPXQX; induction HPXQX; spliter; treat_equalities; Col.
  }
destruct (prod_exists O E E' HNC PXQX PXQX) as [PXQX2 HPXQX2]; Col.
assert (PXQX2 = PXMQX2) by (apply l16_9_2 with O E E' PX QX PXQX PXMQX; Col).
destruct (is_length_exists O E E' PY QY) as [PYQY HPYQY]; Col.
assert (HCol6 : Col O E PYQY).
  {
  unfold Is_length, Length in HPYQY; induction HPYQY; spliter; treat_equalities; Col.
  }
destruct (prod_exists O E E' HNC PYQY PYQY) as [PYQY2 HPYQY2]; Col.
assert (PYQY2 = PYMQY2) by (apply l16_9_2 with O E E' PY QY PYQY PYMQY; Col).
treat_equalities; apply sum_uniqueness with O E E' PXQX2 PYQY2; auto; clear HF; clear F.
clear HPXMQX2; clear HPXMQX; clear PXMQX; clear HPYMQY2; clear HPYMQY; clear PYMQY.
assert (HCs : Cs O E S U1 U2) by (unfold Cd in HCd1; spliter; auto).
destruct (point_of_coordinates O E S U1 U2 PX QY) as [R HCd3]; Col.
elim HPQ; clear HPQ; intro HPQ; [|spliter; treat_equalities; exfalso; Col].
elim HPXQX; clear HPXQX; intro HPXQX; [|spliter; treat_equalities; exfalso; Col].
elim HPYQY; clear HPYQY; intro HPYQY; [|spliter; treat_equalities; exfalso; Col].
elim (eq_dec_points P R); intro HPR; [assert (HPR' := HPR);
rewrite eq_points_coordinates in HPR; [|apply HCd1|apply HCd3]|];
elim (eq_dec_points Q R); intro HQR; [assert (HQR' := HQR);
rewrite eq_points_coordinates in HQR; [|apply HCd2|apply HCd3]| |assert (HQR' := HQR);
rewrite eq_points_coordinates in HQR; [|apply HCd2|apply HCd3]|];
apply sum_comm; Col; apply pythagoras with P Q R PYQY PXQX PQ; auto; try intro;
try (destruct HPR as [HPX HPY]); try (destruct HQR as [HQX HQY]);
treat_equalities; Col; Perp; clear HPYQY2; clear HPXQX2; clear HPQ2; clear HPQ;
try clear HPX; try clear HPY; try clear HQX; try clear HQY.

  {
  assert (O = PYQY); treat_equalities.
    {
    assert_diffs; apply length_uniqueness with O E E' PY PY; try apply length_id_2; auto.
    }
  assert_diffs; apply length_id_2; auto.
  }

  {
  assert (O = PXQX); treat_equalities.
    {
    assert_diffs; apply length_uniqueness with O E E' QX QX; try apply length_id_2; auto.
    }
  assert_diffs; apply length_id_2; auto.
  }

  {
  assert (O = PYQY); treat_equalities.
    {
    assert_diffs; apply length_uniqueness with O E E' PY PY; try apply length_id_2; auto.
    }
  assert_diffs; apply length_id_2; auto.
  }

  {
  apply square_distance_formula_aux with S U1 U2 PX PY QX; auto.
  }

  {
  apply square_distance_formula_aux with S U2 U1 QY QX PY; auto;
  try apply coord_exchange_axes; auto; try apply grid_exchange_axes; auto.
  apply length_sym; auto.
  }

  {
  assert (O = PXQX); treat_equalities.
    {
    assert_diffs; apply length_uniqueness with O E E' QX QX; try apply length_id_2; auto.
    }
  assert_diffs; apply length_id_2; auto.
  }

  {
  destruct HCd3 as [H [H' [HRX HRY]]]; clear H; clear H';
  destruct HRX as [RX' [HProjp5 HCong5]]; destruct HRY as [RY' [HProjp6 HCong6]];
  destruct HCd1 as [H [H' [HPX HPY]]]; clear H; clear H';
  destruct HPX as [PX' [HProjp1 HCong1]]; destruct HPY as [PY' [HProjp2 HCong2]];
  assert (RX' = PX')
    by (assert_diffs; apply col_cong_3_cong_3_eq with O E PX S U1; Col); subst;
  treat_equalities; destruct HCd2 as [H [H' [HQX HQY]]]; clear H; clear H';
  destruct HQX as [QX' [HProjp3 HCong3]]; destruct HQY as [QY' [HProjp4 HCong4]];
  assert (RY' = QY')
    by (assert_diffs; apply col_cong_3_cong_3_eq with O E QY S U2; Col); subst;
  assert (HPerp1 : Perp P R S U1) by (apply projp_projp_perp with PX'; auto);
  assert (HPerp2 : Perp Q R S U2) by (apply projp_projp_perp with QY'; auto);
  assert (HPerp3 : Perp U1 S S U2)
    by (unfold Cs in HCs; spliter; assert_diffs; apply per_perp; Perp).
  apply perp_per_2; auto; apply perp_sym; apply par_perp_perp with S U1; Perp.
  apply l12_9 with S U2; Perp.
  }

  {
  apply square_distance_formula_aux with S U2 U1 QY PX PY; auto;
  try apply coord_exchange_axes; auto; try apply grid_exchange_axes; auto.
  apply length_sym; auto.
  }

  {
  apply length_sym.
  apply square_distance_formula_aux with S U1 U2 QX QY PX; auto.
  apply length_sym; auto.
  }
Qed.
characterization_of_congruence
Proof.
intros O E E' S U1 U2 A AX AY B BX BY C CX CY D DX DY.
intros AXMBX AXMBX2 AYMBY AYMBY2 AB2' CXMDX CXMDX2 CYMDY CYMDY2 CD2'.
intros HCdA HCdB HCdC HCdD HAXMBX HAXMBX2 HAYMBY HAYMBY2 HAB2.
intros HCXMDX HCXMDX2 HCYMDY HCYMDY2 HCD2.
assert (HNC : ~ Col O E E')
  by (apply diff_ar2 in HAXMBX; unfold Ar2 in *; spliter; Col).
destruct (is_length_exists O E E' A B) as [AB HLengthAB]; Col.
assert (HColAB : Col O E AB).
  {
  unfold Is_length, Length in *; induction HLengthAB;
  spliter; treat_equalities; Col.
  }
destruct (prod_exists O E E' HNC AB AB) as [AB2 HLengthAB2]; Col.
assert (AB2 = AB2').
  {
  apply square_distance_formula with O E E' S U1 U2
                                     A B AX AY BX BY AB
                                     AXMBX AYMBY AXMBX2 AYMBY2; auto.
  }
treat_equalities; clear HAB2; clear HAYMBY2; clear HAYMBY;
clear HAXMBX2; clear HAXMBX; clear HCdA; clear HCdB.
destruct (is_length_exists O E E' C D) as [CD HLengthCD]; Col.
assert (HColCD : Col O E CD).
  {
  unfold Is_length, Length in *; induction HLengthCD;
  spliter; treat_equalities; Col.
  }
destruct (prod_exists O E E' HNC CD CD) as [CD2 HLengthCD2]; Col.
assert (CD2 = CD2').
  {
  apply square_distance_formula with O E E' S U1 U2
                                     C D CX CY DX DY CD
                                     CXMDX CYMDY CXMDX2 CYMDY2; auto.
  }
treat_equalities; clear HCD2; clear HCYMDY2; clear HCYMDY;
clear HCXMDX2; clear HCXMDX; clear HCdC; clear HCdD.
split; [intro HCong|intro; treat_equalities].

  {
  assert (H : Cong O AB O CD).
    {
    unfold Is_length, Length in *;
    induction HLengthAB; [|spliter; treat_equalities; exfalso; apply HNC; Col];
    induction HLengthCD; [|spliter; treat_equalities; exfalso; apply HNC; Col].
    spliter; apply cong_transitivity with A B; trivial.
    apply cong_transitivity with C D; Cong.
    }
  clear HLengthAB; clear HLengthCD; clear HCong; rename H into HCong.
  assert (H : Col O AB CD) by (assert_diffs; ColR).
  elim (l7_20 O AB CD); Col; clear H; clear HCong; intro HMid; treat_equalities.

    {
    apply prod_uniqueness with O E E' AB AB; auto.
    }

    {
    assert (HOpp1 : Opp O E E' AB CD)
      by (apply midpoint_opp; unfold Ar2; auto; repeat (split; Col)).
    clear HMid; destruct (opp_exists O E E' HNC E) as [ME HOpp2]; Col.
    assert (Prod O E E' AB ME CD) by (apply opp_prod; auto).
    assert (HXMY2' : Prod O E E' CD CD AB2).
      {
      apply prod_assoc1 with AB ME AB; auto.
      apply prod_assoc2 with ME AB E; try apply prod_1_l; Col; apply prod_comm; auto.
      apply opp_prod; auto; apply opp_comm; auto.
      }
    apply prod_uniqueness with O E E' CD CD; auto.
    }
  }

  {
  elim HLengthAB; clear HLengthAB; intro HLengthAB;
  [|spliter; treat_equalities; exfalso; apply HNC; Col].
  elim HLengthCD; clear HLengthCD; intro HLengthCD;
  [|spliter; treat_equalities; exfalso; apply HNC; Col].
  elim (eq_squares_eq_or_opp O E E' AB CD AB2); auto; intro HOpp; treat_equalities;
  [apply length_eq_cong_1 with O E E' AB; auto|].
  unfold Length, LeP, LtP in *; spliter; apply opp_midpoint in HOpp.
  unfold Midpoint in *; spliter.
  apply cong_transitivity with O CD; trivial.
  apply cong_transitivity with O AB; Cong.
  }
Qed.
bet_betCood_aux
Proof.
intros O E S U1 U2 A AX AY B BX BY C CX CY HCdA HCdB HCdC HBet.
destruct (parallel_existence S U1 A) as [A1 [A2 [HDiff4 [HPar HCol]]]];
try (intro; unfold Cd, Cs in *; spliter; treat_equalities; intuition).
assert (HAX' := HCdA).
destruct HAX' as [H [H' [HAX' H'']]]; clear H; clear H'; clear H''.
destruct HAX' as [AX' [HProjpAX' HCongAX']].
assert (HA : Projp AX' A A1 A2).
  {
  split; auto; induction (eq_dec_points A AX');
  [treat_equalities; right|left; split]; Col.
  apply par_perp_perp with S U1; auto.
  destruct HProjpAX' as [Hclear HAX']; clear Hclear.
  induction HAX'; spliter; Perp; intuition.
  }
assert (HBX' := HCdB).
destruct HBX' as [H [H' [HBX' H'']]]; clear H; clear H'; clear H''.
destruct HBX' as [BX' [HProjpBX' HCongBX']].
destruct (exists_projp A1 A2 BX') as [BX'' HBX'']; auto.
assert (HCX' := HCdC).
destruct HCX' as [H [H' [HCX' H'']]]; clear H; clear H'; clear H''.
destruct HCX' as [CX' [HProjpCX' HCongCX']].
destruct (exists_projp A1 A2 CX') as [CX'' HCX'']; auto.
assert (HDiff : O <> E) by (unfold Cd, Cs in *; spliter; auto).
assert (HColAX : Col O E AX).
  {
  unfold Cd in *; destruct HCdA as [H [H' [[PX [HProjp HCong]] H'']]].
  apply projp_col in HProjp; apply l4_13 with S U1 PX; Cong.
  }
assert (HColBX : Col O E BX).
  {
  unfold Cd in *; destruct HCdB as [H [H' [[PX [HProjp HCong]] H'']]].
  apply projp_col in HProjp; apply l4_13 with S U1 PX; Cong.
  }
assert (HColCX : Col O E CX).
  {
  unfold Cd in *; destruct HCdC as [H [H' [[PX [HProjp HCong]] H'']]].
  apply projp_col in HProjp; apply l4_13 with S U1 PX; Cong.
  }
apply l4_6 with AX' BX' CX'.

  {
  apply projp_preserves_bet with A B C S U1; auto.
  }

  {
  assert (Cong_5 O E AX BX CX S U1 AX' BX' CX')
    by (apply cong_3_3_cong_5; assert_diffs; auto).
  unfold Cong_5 in *; spliter; repeat (split; Cong).
  }
Qed.
bet_betCood
Proof.
intros O E S U1 U2 A AX AY B BX BY C CX CY HCdA HCdB HCdC HBet.
split; [apply bet_betCood_aux with O E S U1 U2 A AY B BY C CY|]; auto.
apply bet_betCood_aux with O E S U2 U1 A AX B BX C CX; auto;
apply coord_exchange_axes; auto.
Qed.
characterization_of_betweenness_aux
Proof.
intros O E E' S U1 U2 A AX AY B BX BY C CX CY BXMAX CXMAX AB AC IAC T.
intros HCdA HCdB HCdC HNC HColAX HColBX HColCX HColBXMAX HColCXMAX HColT.
intros HColAB HColAC HColIAC HBXMAX HCXMAX HAB HAC HT HIAC HBet HDiff1 HDiff2 HDiff3.
destruct (parallel_existence S U1 A) as [A1 [A2 [HDiff4 [HPar HCol]]]];
try (intro; unfold Cd, Cs in *; spliter; treat_equalities; intuition).
assert (HAX' := HCdA).
destruct HAX' as [H [H' [HAX' H'']]]; clear H; clear H'; clear H''.
destruct HAX' as [AX' [HProjpAX' HCongAX']].
assert (HA : Projp AX' A A1 A2).
  {
  split; auto; induction (eq_dec_points A AX');
  [treat_equalities; right|left; split]; Col.
  apply par_perp_perp with S U1; auto.
  destruct HProjpAX' as [Hclear HAX']; clear Hclear.
  induction HAX'; spliter; Perp; intuition.
  }
assert (HBX' := HCdB).
destruct HBX' as [H [H' [HBX' H'']]]; clear H; clear H'; clear H''.
destruct HBX' as [BX' [HProjpBX' HCongBX']].
destruct (exists_projp A1 A2 BX') as [BX'' HBX'']; auto.
assert (HCX' := HCdC).
destruct HCX' as [H [H' [HCX' H'']]]; clear H; clear H'; clear H''.
destruct HCX' as [CX' [HProjpCX' HCongCX']].
destruct (exists_projp A1 A2 CX') as [CX'' HCX'']; auto.
elim (Col_dec A B BX''); intro HABBX''.

  {
  elim (eq_dec_points A BX''); intro HABX''; treat_equalities.

    {
    assert (AX' = BX').
      {
      elim (line_dec S U1 A1 A2); intro HLine.

        {
        assert (A = AX') by (apply col_projp_eq with S U1;
                             auto; assert_diffs; spliter; ColR).
        treat_equalities; apply eq_sym; apply col_projp_eq with A1 A2; auto.
        assert (Col S U1 BX') by (apply projp_col with B; auto).
        assert_diffs; spliter; ColR.
        }

        {
        assert (HCol' : Col A AX' BX') by (apply projp2_col with A1 A2; auto).
        assert (HParS : Par_strict S U1 A1 A2); [|clear HLine].
          {
          elim (Col_dec S U1 A1); intro HCol'';
          [apply par_not_col_strict with A2|apply par_not_col_strict with A1];
          Col ; try (intro; apply HLine); Col.
          }
        apply l6_21 with S U1 A AX'; Col;
        [| |apply l4_13 with O E AX|apply l4_13 with O E BX]; Col;
        intro; treat_equalities; apply HParS; exists A; split; Col;
        apply col_permutation_2; apply l4_13 with O E AX; Col.
        }
      }
    treat_equalities; assert (HPerp : Perp A C S U1).
      {
      assert (HCol' : Col AX' A B) by (apply projp2_col with S U1; auto).
      assert_cols; apply perp_sym; apply perp_col0 with A B;
      try apply projp_projp_perp with AX'; Col.
      }
    assert (AX' = CX') by (apply perp_projp2_eq with A C S U1; auto).
    treat_equalities; assert (AX = BX).
      {
      assert_diffs; apply col_cong_3_cong_3_eq with S U1 AX' O E; Cong.
      apply l4_13 with O E AX; auto.
      }
    assert (AX = CX).
      {
      assert_diffs; apply col_cong_3_cong_3_eq with S U1 AX' O E; Cong.
      apply l4_13 with O E AX; auto.
      }
    treat_equalities;
    assert (O = BXMAX)
      by (apply diff_uniqueness with O E E' AX AX; auto; apply diff_null; Col);
    assert (O = CXMAX)
      by (apply diff_uniqueness with O E E' AX AX; auto; apply diff_null; Col);
    treat_equalities; apply prod_0_r; unfold Prod, Ar2 in *; spliter; Col.
    }

    {
    assert (B = BX'').
      {
      apply col_par_projp2_eq with A1 A2 S U1 BX'; Par.
      assert (Col A1 A2 BX'') by (apply projp_col with BX'; auto); ColR.
      }
    assert (C = CX'').
      {
      apply col_par_projp2_eq with A1 A2 S U1 CX'; Par; assert_cols.
      assert (Col A1 A2 BX'') by (apply projp_col with BX'; auto); ColR.
      }
    treat_equalities.
    assert (HElim : LeP O E E' AX BX \/ LeP O E E' BX AX)
      by (apply col_2_le_or_ge; Col).
    elim HElim; clear HElim; intro HLe4.

      {
      destruct (length_existence O E E' B A) as [LAB HLAB]; Col.
      assert (LAXBX : Length O E E' BX AX LAB).
        {
        apply length_eq_cong_2 with B A; auto.
        assert (Cong AX BX AX' BX').
          {
          apply cong_3_2_cong_4 with O E AX BX S U1 AX' BX' in HCongBX';
          try intro; treat_equalities; Col; unfold Cong_4 in *; spliter; Cong.
          }
        assert (Cong A B AX' BX').
          {
          apply col_2_par_projp2_cong with S U1 A1 A2; auto;
          [apply projp_col with A|apply projp_col with B]; auto.
          }
        apply cong_transitivity with AX' BX'; Cong.
        }
      assert (LAB = BXMAX)
        by (apply l16_9_1 with O E E' BX AX; Col; left; auto).
      elim HLe4; clear HLe4; intro HLt; treat_equalities;
      [|assert (AX' = BX') by (apply col_cong_3_cong_3_eq with O E AX S U1;
                               try intro; treat_equalities; Col);
      treat_equalities;
      apply projp_id with AX' A B A1 A2 in HBX''; intuition].
      apply bet_lt12_le13 with O E E' AX BX CX in HLt;
      [|apply bet_betCood_aux with O E S U1 U2 A AY B BY C CY; auto].
      destruct (length_existence O E E' C A) as [LAC HLAC]; Col.
      assert (LAXCX : Length O E E' CX AX LAC).
        {
        apply length_eq_cong_2 with C A; auto.
        assert (Cong AX CX AX' CX').
          {
          apply cong_3_2_cong_4 with O E AX CX S U1 AX' CX' in HCongCX';
          try intro; treat_equalities; Col;
          unfold Cong_4 in *; spliter; Cong.
          }
        assert (Cong A C AX' CX').
          {
          apply col_2_par_projp2_cong with S U1 A1 A2; auto;
          [apply projp_col with A|apply projp_col with C]; auto.
          }
        apply cong_transitivity with AX' CX'; Cong.
        }
      assert (LAC = CXMAX)
        by (apply l16_9_1 with O E E' CX AX; Col; left; auto).
      assert (AB = LAB).
        {
        apply length_uniqueness with O E E' A B; auto;
        apply length_eq_cong_2 with B A; Cong.
        }
      assert (AC = LAC); treat_equalities.
        {
        apply length_uniqueness with O E E' A C; auto;
        apply length_eq_cong_2 with C A; Cong.
        }
      auto.
      }

      {
      destruct (length_existence O E E' A B) as [LAB HLAB]; Col.
      assert (LAXBX : Length O E E' AX BX LAB).
        {
        apply length_eq_cong_2 with A B; auto.
        assert (Cong AX BX AX' BX').
          {
          apply cong_3_2_cong_4 with O E AX BX S U1 AX' BX' in HCongBX';
          try intro; treat_equalities; Col; unfold Cong_4 in *; spliter; Cong.
          }
        assert (Cong A B AX' BX').
          {
          apply col_2_par_projp2_cong with S U1 A1 A2; auto;
          [apply projp_col with A|apply projp_col with B]; auto.
          }
        apply cong_transitivity with AX' BX'; Cong.
        }
      destruct (diff_exists O E E' AX BX) as [AXMBX HAXMBX]; Col.
      assert (LAB = AXMBX)
        by (apply l16_9_1 with O E E' AX BX; Col; left; auto).
      elim HLe4; clear HLe4; intro HLt; treat_equalities;
      [|assert (AX' = BX') by (apply col_cong_3_cong_3_eq with O E BX S U1;
                               try intro; treat_equalities; Col);
      treat_equalities;
      apply projp_id with AX' A B A1 A2 in HBX''; intuition].
      apply bet_lt21_le31 with O E E' AX BX CX in HLt;
      [|apply bet_betCood_aux with O E S U1 U2 A AY B BY C CY; auto].
      destruct (length_existence O E E' A C) as [LAC HLAC]; Col.
      assert (LAXCX : Length O E E' AX CX LAC).
        {
        apply length_eq_cong_2 with A C; auto.
        assert (Cong AX CX AX' CX').
          {
          apply cong_3_2_cong_4 with O E AX CX S U1 AX' CX' in HCongCX';
          try intro; treat_equalities; Col;
          unfold Cong_4 in *; spliter; Cong.
          }
        assert (Cong A C AX' CX').
          {
          apply col_2_par_projp2_cong with S U1 A1 A2; auto;
          [apply projp_col with A|apply projp_col with C]; auto.
          }
        apply cong_transitivity with AX' CX'; Cong.
        }
      destruct (diff_exists O E E' AX CX) as [AXMCX HAXMCX]; Col.
      assert (LAC = AXMCX)
        by (apply l16_9_1 with O E E' AX CX; Col; left; auto).
      treat_equalities.
      assert (Opp O E E' BXMAX LAB) by (apply diff_opp with BX AX; auto).
      assert (Opp O E E' CXMAX LAC) by (apply diff_opp with CX AX; auto).
      destruct (opp_exists O E E' HNC E) as [ME HME]; Col.
      assert (AB = LAB) by (apply length_uniqueness with O E E' A B; auto).
      assert (AC = LAC) by (apply length_uniqueness with O E E' A C; auto).
      treat_equalities; apply prod_assoc2 with AC ME AB;
      [|apply opp_prod; auto; apply opp_comm|
       apply opp_prod; auto; apply opp_comm]; auto.
      }
    }
  }

  {
  destruct (length_existence O E E' A BX'') as [ABX'' HABX'']; Col.
  destruct (length_existence O E E' A CX'') as [ACX'' HACX'']; Col.
  assert (HColABX'' : Col O E ABX'').
    {
    destruct HABX'' as [H [H' [HElim H'']]]; clear H; clear H'; clear H''.
    elim HElim; clear HElim; intro HLt; treat_equalities; Col.
    destruct HLt as [D [HDiff H]]; clear H.
    apply diff_ar2 in HDiff; unfold Ar2 in *; spliter; Col.
    }
  assert (HColACX'' : Col O E ACX'').
    {
    destruct HACX'' as [H [H' [HElim H'']]]; clear H; clear H'; clear H''.
    elim HElim; clear HElim; intro HLt; treat_equalities; Col.
    destruct HLt as [D [HDiff H]]; clear H.
    apply diff_ar2 in HDiff; unfold Ar2 in *; spliter; Col.
    }
  destruct (prod_exists O E E' HNC AB ACX'') as [F HF]; Col.
  assert (HF' : Prodg O E E' ABX'' AC F).
    {
    apply thales with A B C BX'' CX'' AB ACX''; auto.

      {
      assert_diffs; auto.
      }

      {
      assert_cols; auto.
      }

      {
      apply projp_col in HBX''; apply projp_col in HCX''; ColR.
      }

      {
      destruct HBX'' as [H HElim1]; clear H;
      destruct HProjpBX' as [H HElim2]; clear H.
      destruct HCX'' as [H HElim3]; clear H;
      destruct HProjpCX' as [H HElim4]; clear H.
      elim HElim1; clear HElim1; intro H; destruct H as [HColBX'' HPerp1];
      elim HElim2; clear HElim2; intro H; destruct H as [HColBX' HPerp2];
      elim HElim3; clear HElim3; intro H; destruct H as [HColCX'' HPerp3];
      elim HElim4; clear HElim4; intro H; destruct H as [HColCX' HPerp4];
      treat_equalities.

        {
        assert (HCol1 : Par B BX' BX' BX'')
          by (apply par_perp_2_par with S U1 A1 A2; Perp).
        elim HCol1; clear HCol1; intro HCol1;
        [exfalso; apply HCol1; exists BX'; Col|].
        assert (HCol2 : Par C CX' CX' CX'')
          by (apply par_perp_2_par with S U1 A1 A2; Perp).
        elim HCol2; clear HCol2; intro HCol2;
        [exfalso; apply HCol2; exists CX'; Col|].
        left; apply l12_9 with A1 A2.

          {
          apply perp_sym; apply perp_col0 with BX' BX''; Perp;
          assert_diffs; spliter; Col.
          }

          {
          apply perp_sym; apply perp_col0 with CX' CX''; Perp;
          assert_diffs; spliter; Col.
          intro; treat_equalities; assert_cols; apply HABBX''; ColR.
          }
        }

        {
        assert (HCol1 : Par B BX' BX' BX'')
          by (apply par_perp_2_par with S U1 A1 A2; Perp).
        elim HCol1; clear HCol1; intro HCol1;
        [exfalso; apply HCol1; exists BX'; Col|].
        left; apply l12_9 with A1 A2; Perp.
        apply perp_sym; apply perp_col0 with BX' BX''; Perp;
        assert_diffs; spliter; Col.
        }

        {
        assert (HCol1 : Par B BX' BX' BX'')
          by (apply par_perp_2_par with S U1 A1 A2; Perp).
        elim HCol1; clear HCol1; intro HCol1;
        [exfalso; apply HCol1; exists BX'; Col|].
        left; apply l12_9 with A1 A2; Perp.
        apply perp_sym; apply perp_col0 with BX' BX''; Perp;
        assert_diffs; spliter; Col.
        apply perp_sym; apply par_perp_perp with S U1; Perp.
        }

        {
        right; auto.
        }

        {
        assert (HCol2 : Par C CX' CX' CX'')
          by (apply par_perp_2_par with S U1 A1 A2; Perp).
        elim HCol2; clear HCol2; intro HCol2;
        [exfalso; apply HCol2; exists CX'; Col|].
        left; apply l12_9 with A1 A2; Perp.
        apply perp_sym; apply perp_col0 with CX' CX''; Perp;
        assert_diffs; spliter; Col.
        intro; treat_equalities; assert_cols; apply HABBX''; ColR.
        }

        {
        left; apply l12_9 with A1 A2; Perp; Perp.
        }

        {
        left; apply l12_9 with A1 A2; Perp.
        apply perp_sym; apply par_perp_perp with S U1; Perp.
        }

        {
        right; auto.
        }

        {
        assert (HCol2 : Par C CX' CX' CX'')
          by (apply par_perp_2_par with S U1 A1 A2; Perp).
        elim HCol2; clear HCol2; intro HCol2;
        [exfalso; apply HCol2; exists CX'; Col|].
        left; apply l12_9 with A1 A2; Perp.

          {
          apply perp_sym; apply par_perp_perp with S U1; Perp.
          }

          {
          apply perp_sym; apply perp_col0 with CX' CX''; Perp;
          assert_diffs; spliter; Col.
          intro; treat_equalities; assert_cols; apply HABBX''; ColR.
          }
        }

        {
        left; apply l12_9 with A1 A2; Perp.
        apply perp_sym; apply par_perp_perp with S U1; Perp.
        }

        {
        left; apply l12_9 with A1 A2; Perp.
        apply perp_sym; apply par_perp_perp with S U1; Perp.
        apply perp_sym; apply par_perp_perp with S U1; Perp.
        }

        {
        right; auto.
        }

        {
        exfalso; apply HABBX''; Col.
        }

        {
        exfalso; apply HABBX''; Col.
        }

        {
        exfalso; apply HABBX''; Col.
        }

        {
        right; auto.
        }
      }

      {
      left; auto.
      }
    }
  elim HF'; clear HF'; intro HF'; [|destruct HF' as [HFalse H]; clear H;
                                    exfalso; apply HFalse; do 3 (split; Col)].
  assert (HProd : Prod O E E' T ACX'' ABX'').
    {
    assert (HColF : Col O E F) by (unfold Prod, Ar2 in *; spliter; Col).
    destruct (prod_exists O E E' HNC F IAC) as [G HG]; Col.
    assert (Prod O E E' ABX'' E G)
      by (apply prod_assoc2 with AC IAC F; auto; apply prod_comm; auto).
    assert (Prod O E E' ACX'' T G).
      {
      apply prod_assoc2 with AB IAC F; auto; apply prod_comm; auto.
      apply prod_assoc2 with AC T E; auto; apply prod_comm; auto.
      apply prod_1_r; Col.
      }
    assert (G = ABX'')
      by (apply prod_uniqueness with O E E' ABX'' E; auto; apply prod_1_r; Col).
    treat_equalities; apply prod_comm; auto.
    }
  assert (HElim : LeP O E E' AX BX \/ LeP O E E' BX AX)
    by (apply col_2_le_or_ge; Col).
  elim HElim; clear HElim; intro HLe4.

    {
    assert (LAXBX : Length O E E' BX AX ABX'').
      {
      apply length_eq_cong_2 with A BX''; auto.
      assert (Cong AX BX AX' BX').
        {
        apply cong_3_2_cong_4 with O E AX BX S U1 AX' BX' in HCongBX';
        try intro; treat_equalities; Col; unfold Cong_4 in *; spliter; Cong.
        }
      assert (Cong A BX'' AX' BX').
        {
        apply col_2_par_projp2_cong with S U1 A1 A2; auto;
        [apply projp_col with A|apply projp_col with B]; auto.
        }
      apply cong_transitivity with AX' BX'; Cong.
      }
    assert (ABX'' = BXMAX)
      by (apply l16_9_1 with O E E' BX AX; Col; left; auto).
    elim HLe4; clear HLe4; intro HLt; treat_equalities;
    [|assert (AX' = BX') by (apply col_cong_3_cong_3_eq with O E AX S U1;
                             try intro; treat_equalities; Col);
    treat_equalities;
    apply projp_id with AX' A BX'' A1 A2 in HBX''; auto;
    treat_equalities; exfalso; Col].
    apply bet_lt12_le13 with O E E' AX BX CX in HLt;
    [|apply bet_betCood_aux with O E S U1 U2 A AY B BY C CY; auto].
    assert (LAXCX : Length O E E' CX AX ACX'').
      {
      apply length_eq_cong_2 with A CX''; auto.
      assert (Cong AX CX AX' CX').
        {
        apply cong_3_2_cong_4 with O E AX CX S U1 AX' CX' in HCongCX';
        try intro; treat_equalities; Col; unfold Cong_4 in *; spliter; Cong.
        }
      assert (Cong A CX'' AX' CX').
        {
        apply col_2_par_projp2_cong with S U1 A1 A2; auto;
        [apply projp_col with A|apply projp_col with C]; auto.
        }
      apply cong_transitivity with AX' CX'; Cong.
      }
    assert (ACX'' = CXMAX)
      by (apply l16_9_1 with O E E' CX AX; Col; left; auto).
    treat_equalities; auto.
    }

    {
    assert (LAXBX : Length O E E' AX BX ABX'').
      {
      apply length_eq_cong_2 with A BX''; auto.
      assert (Cong AX BX AX' BX').
        {
        apply cong_3_2_cong_4 with O E AX BX S U1 AX' BX' in HCongBX';
        try intro; treat_equalities; Col; unfold Cong_4 in *; spliter; Cong.
        }
      assert (Cong A BX'' AX' BX').
        {
        apply col_2_par_projp2_cong with S U1 A1 A2; auto;
        [apply projp_col with A|apply projp_col with B]; auto.
        }
      apply cong_transitivity with AX' BX'; Cong.
      }
    destruct (diff_exists O E E' AX BX) as [AXMBX HAXMBX]; Col.
    assert (ABX'' = AXMBX)
      by (apply l16_9_1 with O E E' AX BX; Col; left; auto).
    elim HLe4; clear HLe4; intro HLt; treat_equalities;
    [|assert (AX' = BX') by (apply col_cong_3_cong_3_eq with O E BX S U1;
                             try intro; treat_equalities; Col);
    treat_equalities;
    apply projp_id with AX' A BX'' A1 A2 in HBX''; auto;
    treat_equalities; exfalso; Col].
    apply bet_lt21_le31 with O E E' AX BX CX in HLt;
    [|apply bet_betCood_aux with O E S U1 U2 A AY B BY C CY; auto].
    assert (LAXCX : Length O E E' AX CX ACX'').
      {
      apply length_eq_cong_2 with A CX''; auto.
      assert (Cong AX CX AX' CX').
        {
        apply cong_3_2_cong_4 with O E AX CX S U1 AX' CX' in HCongCX';
        try intro; treat_equalities; Col; unfold Cong_4 in *; spliter; Cong.
        }
      assert (Cong A CX'' AX' CX').
        {
        apply col_2_par_projp2_cong with S U1 A1 A2; auto;
        [apply projp_col with A|apply projp_col with C]; auto.
        }
      apply cong_transitivity with AX' CX'; Cong.
      }
    destruct (diff_exists O E E' AX CX) as [AXMCX HAXMCX]; Col.
    assert (ACX'' = AXMCX)
      by (apply l16_9_1 with O E E' AX CX; Col; left; auto).
    treat_equalities.
    assert (Opp O E E' BXMAX ABX'') by (apply diff_opp with BX AX; auto).
    assert (Opp O E E' CXMAX ACX'') by (apply diff_opp with CX AX; auto).
    destruct (opp_exists O E E' HNC E) as [ME HME]; Col.
    apply prod_assoc2 with ACX'' ME ABX'';
    [auto|apply opp_prod; auto; apply opp_comm; auto|
     apply opp_prod; auto; apply opp_comm; auto].
    }
  }
Qed.
characterization_of_betweenness
Proof.
intros O E E' S U1 U2 A AX AY B BX BY C CX CY BXMAX BYMAY CXMAX CYMAY.
intros HCdA HCdB HCdC HBXMAX HBYMAY HCXMAX HCYMAY.
assert (HNC : ~ Col O E E')
  by (apply diff_ar2 in HBXMAX; unfold Ar2 in *; spliter; Col).
assert (HColAX : Col O E AX)
  by (apply diff_ar2 in HBXMAX; unfold Ar2 in *; spliter; Col).
assert (HColAY : Col O E AY)
  by (apply diff_ar2 in HBYMAY; unfold Ar2 in *; spliter; Col).
assert (HColBX : Col O E BX)
  by (apply diff_ar2 in HBXMAX; unfold Ar2 in *; spliter; Col).
assert (HColBY : Col O E BY)
  by (apply diff_ar2 in HBYMAY; unfold Ar2 in *; spliter; Col).
assert (HColCX : Col O E CX)
  by (apply diff_ar2 in HCXMAX; unfold Ar2 in *; spliter; Col).
assert (HColCY : Col O E CY)
  by (apply diff_ar2 in HCYMAY; unfold Ar2 in *; spliter; Col).
assert (HColBXMAX : Col O E BXMAX)
  by (apply diff_ar2 in HBXMAX; unfold Ar2 in *; spliter; Col).
assert (HColBYMAY : Col O E BYMAY)
  by (apply diff_ar2 in HBYMAY; unfold Ar2 in *; spliter; Col).
assert (HColCXMAX : Col O E CXMAX)
  by (apply diff_ar2 in HCXMAX; unfold Ar2 in *; spliter; Col).
assert (HColCYMAY : Col O E CYMAY)
  by (apply diff_ar2 in HCYMAY; unfold Ar2 in *; spliter; Col).
split; [intro HBet|intro HT].

  {
  elim (eq_dec_points A B); intro HDiff1; treat_equalities.

    {
    assert (AX = BX /\ AY = BY)
      by (rewrite <- eq_points_coordinates; [|apply HCdA|apply HCdB]; auto).
    spliter; treat_equalities.
    assert (O = BXMAX)
      by (apply diff_uniqueness with O E E' AX AX; auto; apply diff_null; Col).
    assert (O = BYMAY)
      by (apply diff_uniqueness with O E E' AY AY; auto; apply diff_null; Col).
    treat_equalities; exists O; split; try (intro; treat_equalities; Col).
    split; Col. split; try apply leP_refl.
    split; try apply ps_le; Between.
    split; apply prod_0_l; Col.
    }

    {
    elim (eq_dec_points A C); intro HDiff2; treat_equalities; [intuition|].
    elim (eq_dec_points B C); intro HDiff3; treat_equalities.

      {
      assert (BX = CX /\ BY = CY)
        by (rewrite <- eq_points_coordinates; [|apply HCdB|apply HCdC]; auto).
      spliter; treat_equalities.
      assert (BXMAX = CXMAX) by (apply diff_uniqueness with O E E' BX AX; auto).
      assert (BYMAY = CYMAY) by (apply diff_uniqueness with O E E' BY AY; auto).
      treat_equalities; exists E; split; try (intro; treat_equalities; Col).
      split; Col. split; try apply ps_le; Between.
      split; try apply leP_refl.
      split; apply prod_1_l; Col.
      }

      {
      destruct (length_existence O E E' A B) as [AB HAB]; Col.
      destruct (length_existence O E E' A C) as [AC HAC]; Col.
      destruct (length_existence O E E' B C) as [BC HBC]; Col.
      assert (HSum : Sum O E E' AB BC AC)
        by (assert_diffs; apply triangular_equality_bis with A B C; auto).
      assert (HLe1 : LeP O E E' O AB) by (apply length_pos with A B; auto).
      assert (HLe2 : LeP O E E' AB AC)
        by (apply length_leP_le_2 with A B A C; try (apply l5_5_2; exists C); Cong).
      assert (HColAB : Col O E AB) by (unfold Length in *; spliter; Col).
      assert (HColAC : Col O E AC) by (unfold Length in *; spliter; Col).
      destruct (inv_exists O E E' AC) as [IAC HIAC]; Col;
      try (intro; unfold Length in *; spliter; treat_equalities; auto).
      assert (HColIAC : Col O E IAC) by (unfold Prod, Ar2 in *; spliter; Col).
      assert (HLe3 : LeP O E E' O IAC).
        {
        apply pos_inv_pos with AC; auto;
        try (intro; unfold Length in *; spliter; treat_equalities; auto).
        apply length_pos with A C; auto.
        }
      destruct (prod_exists O E E' HNC AB IAC) as [T HT]; Col.
      exists T; split; try (intro; treat_equalities; Col).
      split; [unfold Prod, Ar2 in *; spliter; Col|].
      split; [apply compatibility_of_prod_with_order with AB IAC; auto|].
      split; [apply le_pos_prod_le with AB AC IAC; auto; apply prod_comm; auto|].
      assert (HColT : Col O E T) by (unfold Prod, Ar2 in *; spliter; Col).
      assert (HT' : Prod O E E' T AC AB)
        by (apply prod_assoc1 with AB IAC E; auto; apply prod_1_r; Col).
      split;
      [apply characterization_of_betweenness_aux
       with S U1 U2 A AX AY B BX BY C CX CY AB AC IAC|
       apply characterization_of_betweenness_aux
       with S U2 U1 A AY AX B BY BX C CY CX AB AC IAC
      ]; auto; apply coord_exchange_axes; auto.
      }
    }
  }

  {
  destruct HT as [T [H [HColT [HOLeT [HTLeE [HX HY]]]]]]; clear H.
  rename B into B'; rename BX into B'X; rename BY into B'Y; rename HCdB into HCdB'.
  rename BXMAX into B'XMAX; rename HBXMAX into HB'XMAX.
  rename BYMAY into B'YMAY; rename HBYMAY into HB'YMAY.
  rename HColBX into HColB'X; rename HColBY into HColB'Y.
  rename HColBXMAX into HColB'XMAX; rename HColBYMAY into HColB'YMAY.
  destruct (length_existence O E E' A C) as [AC HAC]; Col.
  assert (HColAC : Col O E AC) by (unfold Length in *; spliter; Col).
  assert (HLe1 : LeP O E E' O AC) by (apply length_pos with A C; auto).
  destruct (prod_exists O E E' HNC T AC) as [AB HT]; Col.
  assert (HColAB : Col O E AB) by (unfold Prod, Ar2 in *; spliter; Col).
  assert (HLe2 : LeP O E E' O AB)
    by (apply compatibility_of_prod_with_order with T AC; auto).
  assert (HB : exists B, Bet A B C /\ Length O E E' A B AB).
    {
    assert (Le O AB A C).
      {
      apply length_leP_le_1 with O E E' AB AC; auto.
      assert_diffs; do 2 (split; Cong).
      apply le_pos_prod_le with T E AC; auto; apply prod_1_l; Col.
      }
    destruct (le_bet A C O AB) as [B [HBet HCong]]; auto; exists B; split; auto.
    assert_diffs; do 3 (split; Cong).
    }
  destruct HB as [B [HBet HAB]].
  elim (eq_dec_points A C); intro HDiff2; treat_equalities.

    {
    assert (AX = CX /\ AY = CY)
      by (rewrite <- eq_points_coordinates; [|apply HCdA|apply HCdC]; auto).
    spliter; treat_equalities.
    assert (O = CXMAX)
      by (apply diff_uniqueness with O E E' AX AX; auto; apply diff_null; Col).
    assert (O = CYMAY)
      by (apply diff_uniqueness with O E E' AY AY; auto; apply diff_null; Col).
    treat_equalities.
    assert (O = B'XMAX)
      by (apply prod_uniqueness with O E E' T O; auto; apply prod_0_r; Col).
    assert (O = B'YMAY)
      by (apply prod_uniqueness with O E E' T O; auto; apply prod_0_r; Col).
    treat_equalities.
    assert (AX = B'X) by (apply diff_uniquenessA with O E E' AX O; auto).
    assert (AY = B'Y) by (apply diff_uniquenessA with O E E' AY O; auto).
    treat_equalities.
    assert (A = B')
      by (rewrite eq_points_coordinates; [|apply HCdA|apply HCdB']; auto).
    treat_equalities; Between.
    }

    {
    assert (HCdB : exists BX, exists BY, Cd O E S U1 U2 B BX BY)
      by (apply coordinates_of_point; unfold Cd in *; spliter; auto).
    destruct HCdB as [BX [BY HCdB]].
    elim (eq_dec_points A B); intro HDiff1; treat_equalities;
    try (elim (eq_dec_points B C); intro HDiff3; treat_equalities).

      {
      assert (AX = BX /\ AY = BY)
        by (rewrite <- eq_points_coordinates; [|apply HCdA|apply HCdB]; auto).
      assert (O = AB); spliter; treat_equalities.
        {
        apply length_uniqueness with O E E' A A; auto; apply length_id_2;
        assert_diffs; auto.
        }
      elim (eq_dec_points O T); intro HOT; treat_equalities.

        {
        assert (O = B'XMAX)
          by (apply prod_uniqueness with O E E' O CXMAX; auto; apply prod_0_l; Col).
        assert (O = B'YMAY)
          by (apply prod_uniqueness with O E E' O CYMAY; auto; apply prod_0_l; Col).
        treat_equalities.
        assert (AX = B'X)
          by (apply diff_uniquenessA with O E E' AX O; auto; apply diff_null; Col).
        assert (AY = B'Y)
          by (apply diff_uniquenessA with O E E' AY O; auto; apply diff_null; Col).
        assert (A = B'); treat_equalities; Between.
        rewrite eq_points_coordinates; [|apply HCdA|apply HCdB']; auto.
        }

        {
        apply prod_null in HT; elim HT; clear HT; intro H; [intuition|].
        apply eq_sym in H; treat_equalities; exfalso; apply HDiff2.
        apply length_id in HAC; spliter; auto.
        }
      }

      {
      assert (BX = CX /\ BY = CY)
        by (rewrite <- eq_points_coordinates; [|apply HCdB|apply HCdC]; auto).
      spliter; treat_equalities.
      assert (AB = AC) by (apply length_uniqueness with O E E' A B; auto).
      spliter; treat_equalities.
      assert (E = T); treat_equalities.
        {
        apply prod_uniquenessA with O E E' AB AB; try apply prod_1_l; auto.
        intro; treat_equalities; apply length_id in HAB;
        assert_diffs; induction HAB; auto.
        }
      assert (CXMAX = B'XMAX)
        by (apply prod_uniqueness with O E E' E CXMAX; auto; apply prod_1_l; Col).
      assert (CYMAY = B'YMAY)
        by (apply prod_uniqueness with O E E' E CYMAY; auto; apply prod_1_l; Col).
      treat_equalities.
      assert (BX = B'X) by (apply diff_uniquenessA with O E E' AX CXMAX; auto).
      assert (BY = B'Y) by (apply diff_uniquenessA with O E E' AY CYMAY; auto).
      assert (B = B'); treat_equalities; Between.
      rewrite eq_points_coordinates; [|apply HCdB|apply HCdB']; auto.
      }

      {
      destruct (inv_exists O E E' AC) as [IAC HIAC]; Col;
      try (intro; unfold Length in *; spliter; treat_equalities; auto).
      assert (HColIAC : Col O E IAC) by (unfold Prod, Ar2 in *; spliter; Col).
      assert (HColBX : Col O E BX) by (apply Cd_Col in HCdB; spliter; Col).
      destruct (diff_exists O E E' BX AX) as [BXMAX HBXMAX]; Col.
      assert (HColBXMAX : Col O E BXMAX)
        by (apply diff_ar2 in HBXMAX; unfold Ar2 in *; spliter; Col).
      assert (HX' : Prod O E E' T CXMAX BXMAX).
        {
        apply characterization_of_betweenness_aux
        with S U1 U2 A AX AY B BX BY C CX CY AB AC IAC; auto.
        }
      assert (BXMAX = B'XMAX) by (apply prod_uniqueness with O E E' T CXMAX; auto).
      assert (HColBY : Col O E BY) by (apply Cd_Col in HCdB; spliter; Col).
      destruct (diff_exists O E E' BY AY) as [BYMAY HBYMAY]; Col.
      assert (HColBYMAY : Col O E BYMAY)
        by (apply diff_ar2 in HBYMAY; unfold Ar2 in *; spliter; Col).
      assert (HY' : Prod O E E' T CYMAY BYMAY).
        {
        apply characterization_of_betweenness_aux
        with S U2 U1 A AY AX B BY BX C CY CX AB AC IAC; auto;
        apply coord_exchange_axes; auto.
        }
      assert (BYMAY = B'YMAY) by (apply prod_uniqueness with O E E' T CYMAY; auto).
      treat_equalities.
      assert (BX = B'X) by (apply diff_uniquenessA with O E E' AX BXMAX; auto).
      assert (BY = B'Y) by (apply diff_uniquenessA with O E E' AY BYMAY; auto).
      treat_equalities.
      assert (B = B')
        by (rewrite eq_points_coordinates; [|apply HCdB|apply HCdB']; auto).
      treat_equalities; auto.
      }
    }
  }
Qed.
same_abscissa_col
Proof.
intros O E S U1 U2 A AX AY B BY C CY HCdA HCdB HCdC.
destruct HCdA as [HCs [H [[PXA [HProjpA HCongA]] H']]]; clear H; clear H'.
destruct HCdB as [H [H' [[PXB [HProjpB HCongB]] H'']]]; clear H; clear H'; clear H''.
destruct HCdC as [H [H' [[PXC [HProjpC HCongC]] H'']]]; clear H; clear H'; clear H''.
assert (HDiff1 : O <> E) by (unfold Cs in *; spliter; auto).
assert (HColAX : Col O E AX)
  by (apply l4_13 with S U1 PXA; Cong; apply projp_col with A; auto).
eapply col_cong_3_cong_3_eq in HCongB; [| | |apply HCongA]; treat_equalities; auto.
eapply col_cong_3_cong_3_eq in HCongC; [| | |apply HCongA]; treat_equalities; auto.
clear HCongA; elim (eq_dec_points A PXA); intro HDiff2; treat_equalities;
[apply projp2_col with S U1; auto|].
eapply projp2_col in HProjpB; [|apply HProjpA].
eapply projp2_col in HProjpC; [|apply HProjpA].
ColR.
Qed.
characterization_of_collinearity
Proof.
intros O E E' S U1 U2 A AX AY B BX BY C CX CY AXMBX AYMBY BXMCX BYMCY XProd YProd.
intros HCdA HCdB HCdC HAXMBX HAYMBY HBXMCX HBYMCY HXProd HYProd.
assert (HNC : ~ Col O E E')
  by (apply diff_ar2 in HAXMBX; unfold Ar2 in *; spliter; Col).
assert (HColAX : Col O E AX)
  by (apply diff_ar2 in HAXMBX; unfold Ar2 in *; spliter; Col).
assert (HColAY : Col O E AY)
  by (apply diff_ar2 in HAYMBY; unfold Ar2 in *; spliter; Col).
assert (HColBX : Col O E BX)
  by (apply diff_ar2 in HBXMCX; unfold Ar2 in *; spliter; Col).
assert (HColBY : Col O E BY)
  by (apply diff_ar2 in HBYMCY; unfold Ar2 in *; spliter; Col).
assert (HColCX : Col O E CX)
  by (apply diff_ar2 in HBXMCX; unfold Ar2 in *; spliter; Col).
assert (HColCY : Col O E CY)
  by (apply diff_ar2 in HBYMCY; unfold Ar2 in *; spliter; Col).
assert (HColAXMBX : Col O E AXMBX)
  by (apply diff_ar2 in HAXMBX; unfold Ar2 in *; spliter; Col).
assert (HColAYMBY : Col O E AYMBY)
  by (apply diff_ar2 in HAYMBY; unfold Ar2 in *; spliter; Col).
assert (HColBXMCX : Col O E BXMCX)
  by (apply diff_ar2 in HBXMCX; unfold Ar2 in *; spliter; Col).
assert (HColBYMCY : Col O E BYMCY)
  by (apply diff_ar2 in HBYMCY; unfold Ar2 in *; spliter; Col).
destruct (diff_exists O E E' BX AX) as [BXMAX HBXMAX]; Col.
assert (HColBXMAX : Col O E BXMAX)
  by (apply diff_ar2 in HBXMAX; unfold Ar2 in *; spliter; Col).
destruct (diff_exists O E E' BY AY) as [BYMAY HBYMAY]; Col.
assert (HColBYMAY : Col O E BYMAY)
  by (apply diff_ar2 in HBYMAY; unfold Ar2 in *; spliter; Col).
destruct (diff_exists O E E' CX AX) as [CXMAX HCXMAX]; Col.
assert (HColCXMAX : Col O E CXMAX)
  by (apply diff_ar2 in HCXMAX; unfold Ar2 in *; spliter; Col).
destruct (diff_exists O E E' CY AY) as [CYMAY HCYMAY]; Col.
assert (HColCYMAY : Col O E CYMAY)
  by (apply diff_ar2 in HCYMAY; unfold Ar2 in *; spliter; Col).
destruct (diff_exists O E E' CX BX) as [CXMBX HCXMBX]; Col.
assert (HColCXMBX : Col O E CXMBX)
  by (apply diff_ar2 in HCXMBX; unfold Ar2 in *; spliter; Col).
destruct (diff_exists O E E' CY BY) as [CYMBY HCYMBY]; Col.
assert (HColCYMBY : Col O E CYMBY)
  by (apply diff_ar2 in HCYMBY; unfold Ar2 in *; spliter; Col).
destruct (diff_exists O E E' AX CX) as [AXMCX HAXMCX]; Col.
assert (HColAXMCX : Col O E AXMCX)
  by (apply diff_ar2 in HAXMCX; unfold Ar2 in *; spliter; Col).
destruct (diff_exists O E E' AY CY) as [AYMCY HAYMCY]; Col.
assert (HColAYMCY : Col O E AYMCY)
  by (apply diff_ar2 in HAYMCY; unfold Ar2 in *; spliter; Col).
assert (HColXProd : Col O E XProd) by (unfold Prod, Ar2 in *; spliter; Col).
assert (HColYProd : Col O E YProd) by (unfold Prod, Ar2 in *; spliter; Col).
split; intro HCol; treat_equalities.

  {
  elim (eq_dec_points A B); intro HDiff1; elim (eq_dec_points A C); intro HDiff2;
  elim (eq_dec_points B C); intro HDiff3; treat_equalities;
  [|intuition|intuition| |intuition| | |].

    {
    apply eq_points_coordinates with O E S U1 U2 B AX AY B BX BY in HCdA; auto.
    destruct HCdA as [H H']; clear H';
    elim H; clear H; auto; intros; treat_equalities.
    assert (O = AXMBX)
      by (apply diff_uniqueness with O E E' AX AX; auto; apply diff_null; Col).
    assert (O = AYMBY)
      by (apply diff_uniqueness with O E E' AY AY; auto; apply diff_null; Col).
    treat_equalities.
    assert (O = XProd)
      by (apply prod_uniqueness with O E E' O BYMCY; auto; apply prod_0_l; Col).
    assert (O = YProd)
      by (apply prod_uniqueness with O E E' O BXMCX; auto; apply prod_0_l; Col).
    treat_equalities; auto.
    }

    {
    apply eq_points_coordinates with O E S U1 U2 A AX AY A BX BY in HCdA; auto.
    destruct HCdA as [H H']; clear H';
    elim H; clear H; auto; intros; treat_equalities.
    assert (O = AXMBX)
      by (apply diff_uniqueness with O E E' AX AX; auto; apply diff_null; Col).
    assert (O = AYMBY)
      by (apply diff_uniqueness with O E E' AY AY; auto; apply diff_null; Col).
    treat_equalities.
    assert (O = XProd)
      by (apply prod_uniqueness with O E E' O BYMCY; auto; apply prod_0_l; Col).
    assert (O = YProd)
      by (apply prod_uniqueness with O E E' O BXMCX; auto; apply prod_0_l; Col).
    treat_equalities; auto.
    }

    {
    apply eq_points_coordinates with O E S U1 U2 A AX AY A CX CY in HCdC; auto.
    destruct HCdC as [H H']; clear H';
    elim H; clear H; auto; intros; treat_equalities.
    destruct (opp_exists O E E' HNC E) as [ME HME]; Col.
    apply prod_uniqueness with O E E' AXMBX BYMCY; auto.
    apply prod_assoc1 with BXMCX ME AYMBY; auto;
    [|apply prod_comm|apply prod_comm; auto]; apply opp_prod; auto;
    [apply diff_opp with BX AX|apply diff_opp with BY AY]; auto.
    }

    {
    apply eq_points_coordinates with O E S U1 U2 B BX BY B CX CY in HCdC; auto.
    destruct HCdC as [H H']; clear H';
    elim H; clear H; auto; intros; treat_equalities.
    assert (O = BXMCX)
      by (apply diff_uniqueness with O E E' BX BX; auto; apply diff_null; Col).
    assert (O = BYMCY)
      by (apply diff_uniqueness with O E E' BY BY; auto; apply diff_null; Col).
    treat_equalities.
    assert (O = XProd)
      by (apply prod_uniqueness with O E E' AXMBX O; auto; apply prod_0_r; Col).
    assert (O = YProd)
      by (apply prod_uniqueness with O E E' AYMBY O; auto; apply prod_0_r; Col).
    treat_equalities; auto.
    }

    {
    do 2 (try (elim HCol; clear HCol; intro HCol)); rename HCol into HBet1.

      {
      assert (HBet2 : Bet AX BX CX /\ Bet AY BY CY)
        by (apply bet_betCood with O E S U1 U2 A B C; auto).
      destruct HBet2 as [HBet2 HBet3].
      assert (HBet':= HBet1).
      rewrite characterization_of_betweenness in HBet';
      [|apply HCdA|apply HCdB|apply HCdC|
       apply HBXMAX|apply HBYMAY|apply HCXMAX| apply HCYMAY].
      destruct HBet' as [T [HDiff4 [HColT [HLe1 [HLe2 [HProd1 HProd2]]]]]].
      assert (HSumX : Sum O E E' AXMBX BXMCX AXMCX)
        by (apply sum_diff_diff with AX BX CX; auto).
      assert (HSumY : Sum O E E' AYMBY BYMCY AYMCY)
        by (apply sum_diff_diff with AY BY CY; auto).
      destruct (prod_exists O E E' HNC AXMBX AYMBY) as [P1 HP1]; Col.
      assert (HColP1 : Col O E P1) by (unfold Prod, Ar2 in *; spliter; Col).
      destruct (opp_exists O E E' HNC E) as [ME HME]; Col.
      assert (HColME : Col O E ME) by (unfold Opp, Sum, Ar2 in *; spliter; Col).
      destruct (prod_exists O E E' HNC ME T) as [P2 HP2]; Col.
      assert (HColP2 : Col O E P2) by (unfold Prod, Ar2 in *; spliter; Col).
      destruct (sum_exists O E E' HNC XProd P1) as [XProd' HXProd']; Col.
      assert (HColXProd' : Col O E XProd') by (unfold Sum, Ar2 in *; spliter; Col).
      destruct (prod_exists O E E' HNC AXMBX AYMCY) as [D HProdX']; Col.
      assert (XProd' = D); treat_equalities.
        {
        apply sum_uniqueness with O E E' XProd P1; auto.
        apply distr_l with AXMBX BYMCY AYMBY AYMCY; auto.
        apply sum_comm; auto.
        }
      destruct (sum_exists O E E' HNC YProd P1) as [YProd' HYProd']; Col.
      assert (HColYProd' : Col O E YProd') by (unfold Sum, Ar2 in *; spliter; Col).
      destruct (prod_exists O E E' HNC AYMBY AXMCX) as [D HProdY']; Col.
      assert (YProd' = D); treat_equalities.
        {
        apply sum_uniqueness with O E E' YProd P1; auto.
        apply distr_l with AYMBY BXMCX AXMBX AXMCX; auto;
        [apply sum_comm|apply prod_comm]; auto.
        }
      destruct (prod_exists O E E' HNC P2 XProd') as [XProd'' HXProd'']; Col.
      destruct (prod_exists O E E' HNC AXMBX BYMAY) as [D HProdX'']; Col.
      assert (XProd'' = D); treat_equalities.
        {
        apply prod_uniqueness with O E E' AXMBX BYMAY; auto.
        apply prod_assoc2 with AYMCY P2 XProd'; auto; apply prod_comm; auto.
        apply prod_assoc1 with T ME CYMAY; auto; apply prod_comm; auto.
        apply opp_prod; auto; apply diff_opp with AY CY; auto.
        }
      destruct (prod_exists O E E' HNC P2 YProd') as [YProd'' HYProd'']; Col.
      destruct (prod_exists O E E' HNC AYMBY BXMAX) as [D HProdY'']; Col.
      assert (YProd'' = D); treat_equalities.
        {
        apply prod_uniqueness with O E E' AYMBY BXMAX; auto.
        apply prod_assoc2 with AXMCX P2 YProd'; auto; apply prod_comm; auto.
        apply prod_assoc1 with T ME CXMAX; auto; apply prod_comm; auto.
        apply opp_prod; auto; apply diff_opp with AX CX; auto.
        }
      assert (XProd'' = YProd''); treat_equalities.
        {
        apply prod_uniqueness with O E E' AXMBX BYMAY; auto; apply prod_comm.
        apply prod_assoc1 with AYMBY ME BXMAX; auto; [|apply prod_comm];
        apply opp_prod; auto; [apply diff_opp with AY BY|apply diff_opp with AX BX];
        auto.
        }
      assert (XProd' = YProd'); treat_equalities.
        {
        apply prod_uniquenessB with O E E' P2 XProd''; auto.
        intro H; apply eq_sym in H; treat_equalities; apply prod_null in HP2.
        elim HP2; clear HP2; intro HFalse; apply eq_sym in HFalse; treat_equalities;
        [apply HDiff4; apply opp_uniqueness with O E E' O;
         try apply opp0; Col; apply opp_comm; auto|].
        assert (O = BXMAX)
          by (apply prod_uniqueness with O E E' O CXMAX; auto; apply prod_0_l; Col).
        assert (O = BYMAY)
          by (apply prod_uniqueness with O E E' O CYMAY; auto; apply prod_0_l; Col).
        treat_equalities; apply diff_null_eq in HBXMAX; apply diff_null_eq in HBYMAY.
        treat_equalities; apply HDiff1; rewrite eq_points_coordinates;
        [|apply HCdA|apply HCdB]; auto.
        }
      apply sum_uniquenessA with O E E' P1 XProd'; auto.
      }

      {
      assert (HBet2 : Bet BX CX AX /\ Bet BY CY AY)
        by (apply bet_betCood with O E S U1 U2 B C A; auto).
      destruct HBet2 as [HBet2 HBet3].
      assert (HBet':= HBet1).
      rewrite characterization_of_betweenness in HBet';
      [|apply HCdB|apply HCdC|apply HCdA|
       apply HCXMBX|apply HCYMBY|apply HAXMBX| apply HAYMBY].
      destruct HBet' as [T [HDiff4 [HColT [HLe1 [HLe2 [HProd1 HProd2]]]]]].
      apply prod_uniqueness with O E E' AXMBX BYMCY; auto.
      destruct (opp_exists O E E' HNC E) as [ME HME]; Col.
      assert (HColME : Col O E ME) by (unfold Opp, Sum, Ar2 in *; spliter; Col).
      destruct (prod_exists O E E' HNC ME T) as [P HP]; Col.
      apply prod_assoc2 with P AYMBY BXMCX; apply prod_comm; auto.

        {
        apply prod_assoc1 with ME T CXMBX; auto.
        apply prod_comm; apply opp_prod; auto.
        apply diff_opp with CX BX; auto.
        }

        {
        apply prod_assoc2 with T ME CYMBY; apply prod_comm; auto.
        apply prod_comm; apply opp_prod; auto.
        apply diff_opp with CY BY; auto.
        }
      }

      {
      assert (HBet2 : Bet CX AX BX /\ Bet CY AY BY)
        by (apply bet_betCood with O E S U1 U2 C A B; auto).
      destruct HBet2 as [HBet2 HBet3].

      assert (HBet':= HBet1).
      rewrite characterization_of_betweenness in HBet';
      [|apply HCdC|apply HCdA|apply HCdB|
       apply HAXMCX|apply HAYMCY|apply HBXMCX| apply HBYMCY].
      destruct HBet' as [T [HDiff4 [HColT [HLe1 [HLe2 [HProd1 HProd2]]]]]].
      assert (HSumX : Sum O E E' CXMAX AXMBX CXMBX)
        by (apply sum_diff_diff with CX AX BX; auto).
      assert (HSumY : Sum O E E' CYMAY AYMBY CYMBY)
        by (apply sum_diff_diff with CY AY BY; auto).
      destruct (prod_exists O E E' HNC CXMAX BYMCY) as [P1 HP1]; Col.
      destruct (prod_exists O E E' HNC CYMAY BXMCX) as [P2 HP1']; Col.
      assert (P1 = P2); treat_equalities.
        {
        apply prod_uniqueness with O E E' CXMAX BYMCY; auto.
        destruct (opp_exists O E E' HNC E) as [ME HME]; Col.
        assert (HColME : Col O E ME) by (unfold Opp, Sum, Ar2 in *; spliter; Col).
        destruct (prod_exists O E E' HNC ME T) as [P HP]; Col.
        apply prod_assoc1 with BXMCX P CYMAY; apply prod_comm; auto.

          {
          apply prod_assoc1 with ME T AXMCX; auto.
          apply prod_comm; apply opp_prod; auto.
          apply diff_opp with AX CX; auto.
          }

          {
          apply prod_assoc2 with T ME AYMCY; apply prod_comm; auto.
          apply prod_comm; apply opp_prod; auto.
          apply diff_opp with AY CY; auto.
          }
        }
      assert (HColP1 : Col O E P1) by (unfold Prod, Ar2 in *; spliter; Col).
      destruct (sum_exists O E E' HNC XProd P1) as [XProd' HXProd']; Col.
      destruct (prod_exists O E E' HNC CXMBX BYMCY) as [P2 HP2]; Col.
      assert (P2 = XProd'); treat_equalities.
        {
        apply sum_uniqueness with O E E' XProd P1; auto.
        apply sum_comm; Col.
        apply distr_r with CXMAX AXMBX BYMCY CXMBX; auto.
        }
      destruct (sum_exists O E E' HNC YProd P1) as [YProd' HYProd']; Col.
      assert (P2 = YProd'); treat_equalities.
        {
        apply sum_uniqueness with O E E' YProd P1; auto.
        apply sum_comm; Col.
        apply distr_r with CYMAY AYMBY BXMCX CYMBY; auto.
        apply prod_comm; auto.
        destruct (opp_exists O E E' HNC E) as [ME HME]; Col.
        assert (HColME : Col O E ME) by (unfold Opp, Sum, Ar2 in *; spliter; Col).
        apply prod_assoc1 with CXMBX ME BYMCY; auto.

          {
          apply opp_prod; auto.
          apply diff_opp with CX BX; auto.
          }

          {
          apply prod_comm; apply opp_prod; auto.
          apply diff_opp with CY BY; auto.
          }
        }
      apply sum_uniquenessA with O E E' P1 P2; auto.
      }
    }
  }

  {
  elim (eq_dec_points O AXMBX); intro HDiff1;
  treat_equalities; try apply diff_null_eq in HAXMBX;
  elim (eq_dec_points O AYMBY); intro HDiff2;
  treat_equalities; try apply diff_null_eq in HAYMBY;
  elim (eq_dec_points O BXMCX); intro HDiff3;
  treat_equalities; try apply diff_null_eq in HBXMCX;
  elim (eq_dec_points O BYMCY); intro HDiff4;
  treat_equalities; try apply diff_null_eq in HBYMCY; treat_equalities.

    {
    assert (A = B) by (rewrite eq_points_coordinates; [|apply HCdA|apply HCdB]; auto).
    treat_equalities; Col.
    }

    {
    assert (A = B) by (rewrite eq_points_coordinates; [|apply HCdA|apply HCdB]; auto).
    treat_equalities; Col.
    }

    {
    assert (A = B) by (rewrite eq_points_coordinates; [|apply HCdA|apply HCdB]; auto).
    treat_equalities; Col.
    }

    {
    assert (A = B) by (rewrite eq_points_coordinates; [|apply HCdA|apply HCdB]; auto).
    treat_equalities; Col.
    }

    {
    assert (B = C) by (rewrite eq_points_coordinates; [|apply HCdB|apply HCdC]; auto).
    treat_equalities; Col.
    }

    {
    apply same_abscissa_col with O E S U1 U2 AX AY BY CY; auto.
    }

    {
    apply prod_O_l_eq in HXProd; apply eq_sym in HXProd; treat_equalities.
    apply prod_null in HYProd; elim HYProd; clear HYProd; intro H;
    apply eq_sym in H; treat_equalities; intuition.
    }

    {
    apply prod_O_l_eq in HXProd; apply eq_sym in HXProd; treat_equalities.
    apply prod_null in HYProd; elim HYProd; clear HYProd; intro H;
    apply eq_sym in H; treat_equalities; intuition.
    }

    {
    assert (B = C) by (rewrite eq_points_coordinates; [|apply HCdB|apply HCdC]; auto).
    treat_equalities; Col.
    }

    {
    apply prod_O_l_eq in HYProd; apply eq_sym in HYProd; treat_equalities.
    apply prod_null in HXProd; elim HXProd; clear HXProd; intro H;
    apply eq_sym in H; treat_equalities; intuition.
    }

    {
    apply same_abscissa_col with O E S U2 U1 AY AX BX CX; auto;
    apply coord_exchange_axes; auto.
    }

    {
    apply prod_O_l_eq in HYProd; apply eq_sym in HYProd; treat_equalities.
    apply prod_null in HXProd; elim HXProd; clear HXProd; intro H;
    apply eq_sym in H; treat_equalities; intuition.
    }

    {
    assert (B = C) by (rewrite eq_points_coordinates; [|apply HCdB|apply HCdC]; auto).
    treat_equalities; Col.
    }

    {
    apply prod_O_r_eq in HYProd; apply eq_sym in HYProd; treat_equalities.
    apply prod_null in HXProd; elim HXProd; clear HXProd; intro H;
    apply eq_sym in H; treat_equalities; intuition.
    }

    {
    apply prod_O_r_eq in HXProd; apply eq_sym in HXProd; treat_equalities.
    apply prod_null in HYProd; elim HYProd; clear HYProd; intro H;
    apply eq_sym in H; treat_equalities; intuition.
    }

    {
    destruct (length_existence O E E' AX BX) as [L1 HL1]; Col.
    assert (HColL1 : Col O E L1) by (unfold Length in *; spliter; Col).
    destruct (length_existence O E E' AX CX) as [L2 HL2]; Col.
    assert (HColL2 : Col O E L2) by (unfold Length in *; spliter; Col).
    destruct (length_existence O E E' BX CX) as [L3 HL3]; Col.
    assert (HColL3 : Col O E L3) by (unfold Length in *; spliter; Col).
    assert (HElim : LeP O E E' L1 L3 /\ LeP O E E' L2 L3 \/
                    LeP O E E' L1 L2 /\ LeP O E E' L3 L2 \/
                    LeP O E E' L2 L1 /\ LeP O E E' L3 L1).
      {
      assert (H1 : LeP O E E' L1 L2 \/ LeP O E E' L2 L1)
          by (apply col_2_le_or_ge; Col).
      assert (H2 : LeP O E E' L1 L3 \/ LeP O E E' L3 L1)
        by (apply col_2_le_or_ge; Col).
      assert (H3 : LeP O E E' L2 L3 \/ LeP O E E' L3 L2)
        by (apply col_2_le_or_ge; Col).
      elim H1; clear H1; intro HLe1; elim H2; clear H2; intro HLe2;
      elim H3; clear H3; intro HLe3; auto.

        {
        apply leP_asym in HLe2; treat_equalities; [left; split; auto; right; auto|].
        apply leP_trans with L2; auto.
        }

        {
        apply leP_asym in HLe2; treat_equalities; [left; split; auto; right; auto|].
        apply leP_trans with L2; auto.
        }
      }
    do 2 (try (elim HElim; clear HElim; intro HElim;
               try destruct HElim as [HLe1 HLe2])); [right; right|left|right; left].
      {
      assert (HBetX : Bet CX AX BX).
        {
        apply l5_12_b; [assert_diffs; ColR|
                apply length_leP_le_1 with O E E' L2 L3|
                apply length_leP_le_1 with O E E' L1 L3];
        auto; apply length_sym; auto.
        }
      rewrite characterization_of_betweenness;
      [|apply HCdC|apply HCdA|apply HCdB|
       apply HAXMCX|apply HAYMCY|apply HBXMCX|apply HBYMCY].
      assert (HDiff5 : O <> L3).
        {
        intro; treat_equalities; apply length_id in HL3; spliter; treat_equalities.
        apply HDiff1; apply diff_uniqueness with O E E' BX BX; auto;
        apply diff_null; Col.
        }
      assert (HLe3 : LeP O E E' O L3) by (apply length_pos with BX CX; auto).
      destruct (inv_exists O E E' L3) as [IBC HIBC]; Col.
      assert (HColIBC : Col O E IBC) by (unfold Prod, Ar2 in *; spliter; Col).
      assert (HLe4 : LeP O E E' O IBC) by (apply pos_inv_pos with L3; auto).
      destruct (prod_exists O E E' HNC L2 IBC) as [T HT]; Col; exists T.
      split; try (intro; treat_equalities; Col).
      split; [unfold Prod, Ar2 in *; spliter; Col|].
      assert (HLe5 : LeP O E E' O L2) by (apply length_pos with AX CX; auto).
      split; [apply compatibility_of_prod_with_order with L2 IBC; auto|].
      split; [apply le_pos_prod_le with L2 L3 IBC; auto; apply prod_comm; auto|].
      assert (HDiff6 : O <> E) by (assert_diffs; auto).
      destruct (prod_exists O E E' HNC BXMCX BYMCY) as [P HP]; Col.
      destruct (prod_exists O E E' HNC AXMCX BYMCY) as [Pr HProd1]; Col.
      assert (HSum : Sum O E E' XProd P Pr).
        {
        apply distr_l with BYMCY AXMBX BXMCX AXMCX; auto; try apply prod_comm; auto.
        apply sum_diff_diff with AX BX CX; auto.
        }
      assert (HProd2 : Prod O E E' AYMCY BXMCX Pr).
        {
        destruct (prod_exists O E E' HNC AYMCY BXMCX) as [P' HP']; Col.
        assert (Pr = P'); treat_equalities; auto.
        apply sum_uniqueness with O E E' XProd P; auto.
        apply distr_l with BXMCX AYMBY BYMCY AYMCY; auto; try apply prod_comm; auto.
        apply sum_diff_diff with AY BY CY; auto.
        }
      assert (HProd3 : Prod O E E' T L3 L2).
        {
        apply prod_assoc1 with L2 IBC E; auto; try apply prod_1_r; Col.
        }
      elim (eq_dec_points O L2); intro HDiff7; treat_equalities.

        {
        assert (O = T)
          by (apply prod_uniqueness with O E E' O IBC; auto; apply prod_0_l; Col).
        apply length_id in HL2; spliter; treat_equalities.
        assert (O = AXMCX)
          by (apply diff_uniqueness with O E E' AX AX; auto; apply diff_null; Col).
        treat_equalities; split; [apply prod_0_l; Col|].
        apply diff_null_eq in HAXMCX; treat_equalities.
        assert (BXMAX = BXMCX) by (apply diff_uniqueness with O E E' BX AX; auto).
        treat_equalities.
        assert (AYMBY = CYMBY).
          {
          apply prod_uniquenessA with O E E' BXMAX XProd; auto; apply prod_comm.
          destruct (opp_exists O E E' HNC E) as [ME HME]; Col.
          apply prod_assoc1 with AXMBX ME BYMCY; auto;
          [apply diff_2_prod with AX BX|
           apply prod_comm; apply diff_2_prod with CY BY]; auto.
          }
        assert (AY = CY); treat_equalities.
          {
          apply diff_uniquenessA with O E E' BY AYMBY; auto.
          }
        assert (O = AYMCY); treat_equalities; [|apply prod_0_l; Col].
        apply diff_uniqueness with O E E' AY AY; auto.
        apply diff_null; Col.
        }

        {
        elim (length_eq_or_opp O E E' AX CX L2 AXMCX); auto;
        try apply length_sym; auto; intro HOpp; treat_equalities.

          {
          assert (HLe6 : LtP O E E' CX AX).
            {
            assert (H : LeP O E E' CX AX).
              {
              apply compatibility_of_sum_with_order with O L2 CX; auto;
              try apply sum_O_B; Col; apply sum_comm; Col; apply diff_sum; auto.
              }
            elim H; clear H; intro H; auto; treat_equalities.
            exfalso; apply HDiff7; apply diff_uniqueness with O E E' CX CX; auto.
            apply diff_null; Col.
            }
          assert (HLe7 : LeP O E E' CX BX) by (apply bet_lt12_le13 with AX; auto).
          assert (L3 = BXMCX) by (apply l16_9_1 with O E E' BX CX; auto; left; auto).
          treat_equalities; split; auto.
          apply prod_assoc1 with IBC L2 Pr; auto; apply prod_comm; auto.
          apply prod_assoc1 with AYMCY L3 E; auto; apply prod_comm; auto.
          apply prod_1_l; Col.
          }

          {
          assert (L2 = CXMAX); treat_equalities.
            {
            apply opp_uniqueness with O E E' AXMCX; Col; apply opp_comm; auto.
            apply diff_opp with CX AX; auto.
            }
          assert (HLe6 : LtP O E E' AX CX).
            {
            assert (H : LeP O E E' AX CX).
              {
              apply compatibility_of_sum_with_order with O L2 AX; auto;
              try apply sum_O_B; Col; apply sum_comm; Col; apply diff_sum; auto.
              }
            elim H; clear H; intro H; auto; treat_equalities.
            exfalso; apply HDiff7; apply diff_uniqueness with O E E' AX AX; auto.
            apply diff_null; Col.
            }
          assert (HLe7 : LeP O E E' BX CX) by (apply bet_lt21_le31 with AX; auto).
          assert (L3 = CXMBX); treat_equalities.
            {
            apply l16_9_1 with O E E' CX BX; auto;
            left; auto; apply length_sym; auto.
            }
          destruct (opp_exists O E E' HNC E) as [ME HME]; Col.
          assert (HColT : Col O E T) by (unfold Prod, Ar2 in *; spliter; Col).
          assert (HColME : Col O E ME) by (unfold Opp, Sum, Ar2 in *; spliter; Col).
          destruct (prod_exists O E E' HNC ME T) as [OppT HMT]; Col.
          assert (Prod O E E' T BXMCX AXMCX); [|split; auto].
            {
            apply prod_assoc2 with ME L3 OppT; apply prod_comm; auto;
            [apply opp_prod; auto; apply diff_opp with CX BX; auto|
             apply prod_assoc2 with T ME L2; apply prod_comm; auto;
             apply prod_comm; apply opp_prod; auto].
            }
          destruct (opp_exists O E E' HNC IBC) as [MIBC HMIBC]; Col.
          apply prod_assoc1 with MIBC AXMCX Pr; auto; apply prod_comm; auto.

            {
            apply prod_assoc2 with ME IBC L2; auto; [|apply prod_comm];
            apply opp_prod; auto; apply diff_opp with AX CX; auto.
            }

            {
            destruct (opp_exists O E E' HNC Pr) as [MProd HMProd]; Col;
            [unfold Prod, Ar2 in *; spliter; Col|].
            apply prod_assoc2 with ME IBC MProd; auto;
            [apply opp_prod|apply prod_comm; apply opp_prod|]; auto.
            apply prod_assoc1 with AYMCY L3 E; auto; apply prod_comm; auto;
            try apply prod_1_l; Col.
            apply prod_assoc1 with ME BXMCX Pr; apply prod_comm; auto;
            apply opp_prod; auto; apply diff_opp with BX CX; auto.
            }
          }
        }
      }

      {
      assert (HBetX : Bet AX BX CX).
        {
        apply l5_12_b; [assert_diffs; ColR|
                apply length_leP_le_1 with O E E' L1 L2|
                apply length_leP_le_1 with O E E' L3 L2];
        auto; apply length_sym; auto.
        }
      rewrite characterization_of_betweenness;
      [|apply HCdA|apply HCdB|apply HCdC|
       apply HBXMAX|apply HBYMAY|apply HCXMAX|apply HCYMAY].
      assert (HDiff5 : O <> L2).
        {
        intro; treat_equalities; apply length_id in HL2; spliter; treat_equalities.
        apply HDiff1; apply diff_uniqueness with O E E' AX AX; auto;
        apply diff_null; Col.
        }
      assert (HLe3 : LeP O E E' O L2) by (apply length_pos with AX CX; auto).
      destruct (inv_exists O E E' L2) as [IAC HIAC]; Col.
      assert (HColIAC : Col O E IAC) by (unfold Prod, Ar2 in *; spliter; Col).
      assert (HLe4 : LeP O E E' O IAC) by (apply pos_inv_pos with L2; auto).
      destruct (prod_exists O E E' HNC L1 IAC) as [T HT]; Col; exists T.
      split; try (intro; treat_equalities; Col).
      split; [unfold Prod, Ar2 in *; spliter; Col|].
      assert (HLe5 : LeP O E E' O L1) by (apply length_pos with AX BX; auto).
      split; [apply compatibility_of_prod_with_order with L1 IAC; auto|].
      split; [apply le_pos_prod_le with L1 L2 IAC; auto; apply prod_comm; auto|].
      assert (HDiff6 : O <> E) by (assert_diffs; auto).
      destruct (prod_exists O E E' HNC AXMBX AYMBY) as [P HP]; Col.
      destruct (prod_exists O E E' HNC AXMCX AYMBY) as [Pr HProd1]; Col.
      assert (HSum : Sum O E E' XProd P Pr).
        {
        apply distr_l with AYMBY BXMCX AXMBX AXMCX; auto; try apply prod_comm; auto.
        apply sum_comm; Col; apply sum_diff_diff with AX BX CX; auto.
        }
      assert (HProd2 : Prod O E E' AYMCY AXMBX Pr).
        {
        destruct (prod_exists O E E' HNC AYMCY AXMBX) as [P' HP']; Col.
        assert (Pr = P'); treat_equalities; auto.
        apply sum_uniqueness with O E E' XProd P; auto.
        apply distr_l with AXMBX BYMCY AYMBY AYMCY; auto; try apply prod_comm; auto.
        apply sum_comm; Col; apply sum_diff_diff with AY BY CY; auto.
        }
      assert (HProd3 : Prod O E E' T L2 L1).
        {
        apply prod_assoc1 with L1 IAC E; auto; try apply prod_1_r; Col.
        }
      elim (eq_dec_points O L1); intro HDiff7; treat_equalities.

        {
        apply length_id in HL1; spliter; treat_equalities.
        assert (O = AXMBX)
          by (apply diff_uniqueness with O E E' AX AX; auto; apply diff_null; Col).
        treat_equalities; intuition.
        }

        {
        elim (length_eq_or_opp O E E' AX BX L1 AXMBX); auto;
        try apply length_sym; auto; intro HOpp; treat_equalities.

          {
          assert (HLe6 : LtP O E E' BX AX).
            {
            assert (H : LeP O E E' BX AX).
              {
              apply compatibility_of_sum_with_order with O L1 BX; auto;
              try apply sum_O_B; Col; apply sum_comm; Col; apply diff_sum; auto.
              }
            elim H; clear H; intro H; auto; treat_equalities.
            exfalso; apply HDiff7; apply diff_uniqueness with O E E' BX BX; auto.
            apply diff_null; Col.
            }
          assert (HLe7 : LeP O E E' CX AX) by (apply bet_lt21_le31 with BX; auto).
          assert (L2 = AXMCX) by (apply l16_9_1 with O E E' AX CX; auto; left; auto).
          treat_equalities.
          assert (HProd4 : Prod O E E' T CXMAX BXMAX); [|split; auto].
            {
            destruct (opp_exists O E E' HNC E) as [ME HME]; Col.
            assert (HColME : Col O E ME) by (unfold Opp, Sum, Ar2 in *; spliter; Col).
            apply prod_assoc1 with L1 IAC ME; auto;
            [|apply opp_prod; auto; apply diff_opp with AX BX; auto].
            apply prod_assoc2 with L2 ME E; auto; apply opp_prod; auto.
            apply diff_opp with AX CX; auto.
            }
          destruct (opp_exists O E E' HNC E) as [ME HME]; Col.
          assert (HColProd : Col O E Pr) by (unfold Prod, Ar2 in *; spliter; Col).
          destruct (opp_exists O E E' HNC Pr) as [MProd HMProd]; Col.
          apply prod_assoc1 with IAC L1 MProd; auto; apply prod_comm; auto;
          [apply prod_assoc1 with ME AYMCY Pr; auto; apply prod_comm;
           apply opp_prod; auto; apply diff_opp with AY CY; auto|].
          apply prod_assoc1 with BYMAY L2 E; apply prod_comm; auto;
          try apply prod_1_l; Col; apply prod_assoc2 with AYMBY ME Pr; auto;
          apply opp_prod; auto; apply diff_opp with AY BY; auto.
          }

          {
          assert (L1 = BXMAX); treat_equalities.
            {
            apply opp_uniqueness with O E E' AXMBX; Col; apply opp_comm; auto.
            apply diff_opp with BX AX; auto.
            }
          assert (HLe6 : LtP O E E' AX BX).
            {
            assert (H : LeP O E E' AX BX).
              {
              apply compatibility_of_sum_with_order with O L1 AX; auto;
              try apply sum_O_B; Col; apply sum_comm; Col; apply diff_sum; auto.
              }
            elim H; clear H; intro H; auto; treat_equalities.
            exfalso; apply HDiff7; apply diff_uniqueness with O E E' AX AX; auto.
            apply diff_null; Col.
            }
          assert (HLe7 : LeP O E E' AX CX) by (apply bet_lt12_le13 with BX; auto).
          assert (L2 = CXMAX); treat_equalities.
            {
            apply l16_9_1 with O E E' CX AX; auto; left; apply length_sym; auto.
            }
          split; auto.
          destruct (opp_exists O E E' HNC E) as [ME HME]; Col.
          apply prod_assoc1 with IAC L1 Pr; apply prod_comm; auto;
          [apply prod_assoc1 with AYMCY ME AXMBX; auto; [|apply prod_comm];
           apply opp_prod; auto; apply diff_opp with AY CY; auto|].
          apply prod_assoc1 with BYMAY L2 E; apply prod_comm; auto;
          try apply prod_1_l; Col.
          apply prod_assoc1 with AXMCX ME AYMBY; auto; [|apply prod_comm];
          apply opp_prod; auto;
          [apply diff_opp with AX CX|apply diff_opp with BY AY]; auto.
          }
        }
      }

      {
      assert (HBetX : Bet BX CX AX).
        {
        apply l5_12_b; [assert_diffs; ColR|
                apply length_leP_le_1 with O E E' L3 L1|
                apply length_leP_le_1 with O E E' L2 L1];
        auto; apply length_sym; auto.
        }
      rewrite characterization_of_betweenness;
      [|apply HCdB|apply HCdC|apply HCdA|
       apply HCXMBX|apply HCYMBY|apply HAXMBX|apply HAYMBY].
      assert (HDiff5 : O <> L1).
        {
        intro; treat_equalities; apply length_id in HL1; spliter; treat_equalities.
        apply HDiff1; apply diff_uniqueness with O E E' AX AX; auto;
        apply diff_null; Col.
        }
      assert (HLe3 : LeP O E E' O L1) by (apply length_pos with AX BX; auto).
      destruct (inv_exists O E E' L1) as [IAB HIAB]; Col.
      assert (HColIAB : Col O E IAB) by (unfold Prod, Ar2 in *; spliter; Col).
      assert (HLe4 : LeP O E E' O IAB) by (apply pos_inv_pos with L1; auto).
      destruct (prod_exists O E E' HNC L3 IAB) as [T HT]; Col; exists T.
      split; try (intro; treat_equalities; Col).
      split; [unfold Prod, Ar2 in *; spliter; Col|].
      assert (HLe5 : LeP O E E' O L3) by (apply length_pos with BX CX; auto).
      split; [apply compatibility_of_prod_with_order with L3 IAB; auto|].
      split; [apply le_pos_prod_le with L3 L1 IAB; auto; apply prod_comm; auto|].
      assert (HDiff6 : O <> E) by (assert_diffs; auto).
      assert (HProd1 : Prod O E E' T L1 L3).
        {
        apply prod_assoc1 with L3 IAB E; auto; try apply prod_1_r; Col.
        }
      elim (eq_dec_points O L3); intro HDiff7; treat_equalities.

        {
        apply length_id in HL3; spliter; treat_equalities.
        assert (O = BXMCX)
          by (apply diff_uniqueness with O E E' BX BX; auto; apply diff_null; Col).
        treat_equalities; intuition.
        }

        {
        elim (length_eq_or_opp O E E' BX CX L3 BXMCX); auto;
        try apply length_sym; auto; intro HOpp; treat_equalities.

          {
          assert (HLe6 : LtP O E E' CX BX).
            {
            assert (H : LeP O E E' CX BX).
              {
              apply compatibility_of_sum_with_order with O L3 CX; auto;
              try apply sum_O_B; Col; apply sum_comm; Col; apply diff_sum; auto.
              }
            elim H; clear H; intro H; auto; treat_equalities.
            exfalso; apply HDiff7; apply diff_uniqueness with O E E' CX CX; auto.
            apply diff_null; Col.
            }
          assert (HLe7 : LeP O E E' AX BX) by (apply bet_lt21_le31 with CX; auto).
          assert (L1 = BXMAX)
            by (apply l16_9_1 with O E E' BX AX; auto; left; apply length_sym; auto).
          treat_equalities.
          assert (HProd2 : Prod O E E' T AXMBX CXMBX); [|split; auto].
            {
            destruct (opp_exists O E E' HNC E) as [ME HME]; Col.
            assert (HColME : Col O E ME) by (unfold Opp, Sum, Ar2 in *; spliter; Col).
            apply prod_assoc1 with L3 IAB ME; auto;
            [|apply opp_prod; auto; apply diff_opp with BX CX; auto].
            apply prod_assoc2 with L1 ME E; auto; apply opp_prod; auto.
            apply diff_opp with BX AX; auto.
            }
          destruct (opp_exists O E E' HNC E) as [ME HME]; Col.
          apply prod_assoc1 with IAB L3 XProd; auto; apply prod_comm; auto.
          apply prod_assoc1 with CYMBY L1 E; apply prod_comm; auto;
          try apply prod_1_l; Col; apply prod_assoc1 with AXMBX ME BYMCY; auto;
          [|apply prod_comm]; apply opp_prod; auto;
          [apply diff_opp with AX BX|apply diff_opp with CY BY]; auto.
          }

          {
          assert (L3 = CXMBX); treat_equalities.
            {
            apply opp_uniqueness with O E E' BXMCX; Col; apply opp_comm; auto.
            apply diff_opp with CX BX; auto.
            }
          assert (HLe6 : LtP O E E' BX CX).
            {
            assert (H : LeP O E E' BX CX).
              {
              apply compatibility_of_sum_with_order with O L3 BX; auto;
              try apply sum_O_B; Col; apply sum_comm; Col; apply diff_sum; auto.
              }
            elim H; clear H; intro H; auto; treat_equalities.
            exfalso; apply HDiff7; apply diff_uniqueness with O E E' BX BX; auto.
            apply diff_null; Col.
            }
          assert (HLe7 : LeP O E E' BX AX) by(apply bet_lt12_le13 with CX; auto).
          assert (L1 = AXMBX) by (apply l16_9_1 with O E E' AX BX; auto; left; auto).
          treat_equalities.
          split; auto.
          destruct (opp_exists O E E' HNC E) as [ME HME]; Col.
          destruct (opp_exists O E E' HNC XProd) as [MProd HMProd]; Col.
          apply prod_assoc1 with IAB L3 MProd; apply prod_comm; auto;
          [apply prod_assoc2 with BXMCX ME XProd; auto; apply opp_prod; auto;
           apply diff_opp with BX CX; auto|].
          apply prod_assoc1 with CYMBY L1 E; apply prod_comm; auto;
          try apply prod_1_l; Col.
          apply prod_assoc2 with BYMCY ME XProd; auto; apply opp_prod; auto.
          apply diff_opp with BY CY; auto.
          }
        }
      }
    }
  }
Qed.

